{"meta":{"title":"Jiacan‘s Blog","subtitle":null,"description":null,"author":"Jiacan Liao","url":"http://liaojiacan.me"},"pages":[{"title":"分类","date":"2017-09-29T09:47:44.000Z","updated":"2017-09-29T09:47:44.000Z","comments":false,"path":"categories/index.html","permalink":"http://liaojiacan.me/categories/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-09-29T09:47:54.000Z","updated":"2017-09-29T09:47:54.000Z","comments":false,"path":"tags/index.html","permalink":"http://liaojiacan.me/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Source Tree 配置支持gerrit review","slug":"Source-Tree-配置支持gerrit-review","date":"2018-02-07T07:34:45.000Z","updated":"2018-02-07T07:41:35.209Z","comments":true,"path":"2018/02/07/Source-Tree-配置支持gerrit-review/","link":"","permalink":"http://liaojiacan.me/2018/02/07/Source-Tree-配置支持gerrit-review/","excerpt":"","text":"source tree 可以支持自定义菜单，我们自定义一个菜单，来实现gerrit push review操作 1.先创建一个脚本，这里我叫 git_push_gerrit.sh123456#!/bin/bash# Push for gerrit review# Created by Liaojiacan on 6.2.2017.# Copyright (c) 2018 liaojiacan. All rights reserved.branch=$(git symbolic-ref --short -q HEAD)git push origin HEAD:refs/for/$branch 2.在SourceTree创建一个自定义操作","categories":[],"tags":[]},{"title":"抽奖业务设计","slug":"抽奖业务设计","date":"2017-12-16T08:12:00.000Z","updated":"2017-12-16T08:22:20.264Z","comments":true,"path":"2017/12/16/抽奖业务设计/","link":"","permalink":"http://liaojiacan.me/2017/12/16/抽奖业务设计/","excerpt":"","text":"抽奖是一个比较常见的业务，关于抽奖的算法也有很多种实现，下面介绍一种比较容易实现的方式。 1.根据中奖概率的精确度，取一个权重的基线作为（概率-&gt;概率区间）的放大因子。比如，概率的精确度是到万分位，则基线取10000，保证转换后的区间&gt;=1 2.将奖品按对应的中奖概率*基线 转换成权重区间，并记录权重的上限值。 3.在权重上限值的范围内产生一个随机数，利用迭代查找或者二分查找算法找到对应的权重区间，即可获取到对应的奖品。 假设奖品的配置如下： 123456&quot;一等奖&quot;:0.01&quot;二等奖&quot;:0.1&quot;三等奖&quot;:0.15&quot;四等奖&quot;:0.2&quot;五等奖&quot;:0.25&quot;六等奖&quot;:0.29 概率转换到权重区间（放大10000倍）： 123456一等奖:[0.000000,100.000000)二等奖:[100.000000,1100.000000)三等奖:[1100.000000,2600.000000)四等奖:[2600.000000,4100.000000)五等奖:[4100.000000,6100.000000)六等奖:[6100.000000,8600.000000) 算法实现：Github 123456789101112131415161718192021222324252627282930313233343536373839public class LotteryPrize &#123; private String id; private String name; private double possibility; public LotteryPrize() &#123; &#125; public LotteryPrize(String id, String name, double possibility) &#123; this.id = id; this.name = name; this.possibility = possibility; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getPossibility() &#123; return possibility; &#125; public void setPossibility(double possibility) &#123; this.possibility = possibility; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class LotteryMachine &#123; private PossibilityArea[] table; private int bound = 1; private Random random = new Random(); private static final int BASE_WEIGHT = 10000; class PossibilityArea&#123; private LotteryPrize prize; private double start; private double end; public PossibilityArea(LotteryPrize prize, double start, double end) &#123; this.prize = prize; this.start = start; this.end = end; System.out.printf(&quot;%s:[%f,%f)\\n&quot;,prize.getName(),start,end); &#125; &#125; public LotteryMachine(List&lt;LotteryPrize&gt; prizes) &#123; table = new PossibilityArea[prizes.size()]; double start = 0; for(int i=0;i&lt;prizes.size();i++)&#123; LotteryPrize prize = prizes.get(i); double weight = prize.getPossibility() * BASE_WEIGHT; Double end = start + weight; PossibilityArea area = new PossibilityArea(prize,start,end); table[i]= area; bound = end.intValue(); start=end; &#125; &#125; private LotteryPrize binarySearch(int rnd)&#123; int low = 0; int hight = table.length; while (low&lt;hight)&#123; int mid = (low + hight) / 2; PossibilityArea area = table[mid]; if(area.start&lt;=rnd &amp;&amp; area.end&gt;rnd)&#123; return area.prize; &#125; if(area.end&lt;=rnd)&#123; low=mid+1; &#125; if(area.start&gt;rnd)&#123; hight=mid; &#125; &#125; return null; &#125; public LotteryPrize go()&#123; int rnd = random.nextInt(bound); return binarySearch(rnd); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://liaojiacan.me/categories/java/"}],"tags":[{"name":"业务开发","slug":"业务开发","permalink":"http://liaojiacan.me/tags/业务开发/"}]},{"title":"Java根据指定的country和lang格式化时间","slug":"Java根据指定的country和lang格式化时间","date":"2017-10-16T13:18:00.000Z","updated":"2017-10-16T13:22:40.000Z","comments":true,"path":"2017/10/16/Java根据指定的country和lang格式化时间/","link":"","permalink":"http://liaojiacan.me/2017/10/16/Java根据指定的country和lang格式化时间/","excerpt":"","text":"服务端或者客户端在做一些多语言的时候可能会涉及到时间戳的格式化，不同的语言或者不同的国家的时间的表达格式可能不同。 12345public String formatDate(Date date,String lang,String country)&#123; Locale locale = new Locale(lang,country,&quot;&quot;); DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.DEFAULT,DateFormat.MEDIUM,locale); return dateFormat.format(date);&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://liaojiacan.me/tags/java/"},{"name":"业务开发","slug":"业务开发","permalink":"http://liaojiacan.me/tags/业务开发/"}]},{"title":"Iedis破解思路","slug":"Iedis破解思路","date":"2017-10-12T07:01:00.000Z","updated":"2017-10-12T07:04:05.000Z","comments":true,"path":"2017/10/12/Iedis破解思路/","link":"","permalink":"http://liaojiacan.me/2017/10/12/Iedis破解思路/","excerpt":"","text":"Iedis是IDEA上的一个收费redis插件，java编写的，既然是java写的，收费这些自然是很容易绕过的。由于Java太容易被反编译，作者还是做了些代码混淆和字符串加密。 利用JD-GUI反编译出来的代码片段可以看出类名和字符串都被混淆和加密了，从代码上很难去定位和分析他的注册流程。1234567891011121314151617181920212223242526272829303132package com.seventh7.widget.iedis.config;import com.intellij.icons.AllIcons.General;import com.intellij.openapi.actionSystem.AnActionEvent;import com.intellij.openapi.ui.Messages;class i extends e&#123; private static final String[] ib; private static final String[] jb; i(n paramn) &#123; super(a(20539, 52876), a(20539, 52876), AllIcons.General.Remove, a(20537, 55341), paramn); &#125; void a(AnActionEvent paramAnActionEvent, P paramP) &#123; String str1 = String.format(a(20538, 25199), new Object[] &#123; paramP.f() &#125;); String str2 = a(20536, 20012); try &#123; if (Messages.showOkCancelDialog(a(), str1, str2, Messages.getQuestionIcon()) == 0) &#123; com.seventh7.widget.iedis.d.e.a().a(a(), paramP.b()); &#125; &#125; catch (RuntimeException localRuntimeException) &#123; throw d(localRuntimeException); &#125; &#125; 破解的2个思路 还原代码中的所有加密字符串，根据字符串的内定位到相关的代码，利用javassist修改class文件，将文件替换掉原来的文件 逆向出他的认证算法，然后做个注册机之类的。iedis是采用服务器认证的，每次启动都要去服务器查询激活，所以注册机不适合。但是我们可以本地架设一个认证服务。 架设认证服务器还是比较简单的，下面还是主要研究一下第一种思路。 还原字符串从那些混淆的代码去定位软件的运行逻辑很难下手，但是我们可以换个思路，将软件运行过程中字符串都打印出来，这样我们基本上就可以得到一份软件的运行日志，对java程序进行运行时插入语句看似很麻烦，其实JVM默认就支持javaagent，写个javaagent即可达到效果，javaagent的使用可以参考《javaagent-的使用》 编写javaagent程序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 给iedis的加密字符串函数 插入打印代码 */public class IedisTransformer implements ClassFileTransformer &#123; private final static String IDEA_LIB=&quot;/Applications/IntelliJ IDEA.app/Contents/lib/*&quot;; private final static String IDEIS_LIB=&quot;/Users/liaojiacan/Library/Application Support/IntelliJIdea2017.2/Iedis/lib/*&quot;; public IedisTransformer() &#123; try &#123; ClassPool.getDefault().appendClassPath(IDEA_LIB); ClassPool.getDefault().appendClassPath(IDEIS_LIB); &#125; catch (NotFoundException e) &#123; e.printStackTrace(); &#125; &#125; @Override public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException &#123; if(className.startsWith(&quot;com/seventh7/widget/iedis&quot;))&#123; try &#123; CtClass clazz = ClassPool.getDefault().makeClass(new ByteArrayInputStream(classfileBuffer)); CtMethod[] methods = clazz.getDeclaredMethods(); CtClass string = ClassPool.getDefault().getCtClass(String.class.getName()); for(CtMethod method :methods)&#123; if(method.getLongName().startsWith(&quot;com.seventh7.widget.iedis.a.p.f&quot;))&#123; System.out.println(&quot;Inject :: SUCCESS!&quot;); method.insertBefore(&quot;if(true)&#123;return true;&#125; &quot;); continue; &#125; if(method.getReturnType().equals(string))&#123; String name = method.getLongName(); System.out.println(&quot;transform the iedis method:&quot;+name); method.insertAfter(&quot;System.out.println(\\&quot;--------------------\\&quot;);&quot; + &quot; System.out.println(\\&quot;&quot;+name+&quot;\\&quot;); &quot; + &quot; System.out.println(java.util.Arrays.toString($args)); &quot; + &quot; System.out.println(\\&quot;return:\\&quot;+$_);&quot;); &#125; &#125; return clazz.toBytecode(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (NotFoundException e) &#123; e.printStackTrace(); &#125; catch (CannotCompileException e) &#123; e.printStackTrace(); &#125; &#125; return null; &#125;&#125; 修改System.out，把所有的print打印到我们指定的文件中 /tmp/system.out 12345678910111213141516171819202122232425262728public class Main &#123; public static void premain(String agentOps, Instrumentation inst) &#123; PrintStream out = null; try &#123; out = new PrintStream(&quot;/tmp/system.out&quot;); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; System.setOut(out); System.setErr(out); if (&quot;iedis&quot;.equals(agentOps))&#123; inst.addTransformer(new IedisTransformer()); &#125;else if(&quot;injectPrint&quot;.equals(agentOps)) &#123; inst.addTransformer(new InjectPrintTransformer()); &#125;else &#123; inst.addTransformer(new SimpleTransformer()); &#125; &#125; public static void main(String[] args) &#123; System.out.println(helloWorld()); &#125; public static String helloWorld()&#123; return &quot;This is a javaagent!&quot;; &#125;&#125; 配置idea启动配置，加入我们的javaagent 12345678910111213141516171819#修改idea.vmoptions文件加入下面一行配置-javaagent:/Users/liaojiacan/Workspace/tools/decomplie/javaagent/javaagent-1.0-SNAPSHOT.jar=iedis-Xms128m-Xmx750m-XX:ReservedCodeCacheSize=240m-XX:+UseCompressedOops-Dfile.encoding=UTF-8-XX:+UseConcMarkSweepGC-XX:SoftRefLRUPolicyMSPerMB=50-ea-Dsun.io.useCanonCaches=false-Djava.net.preferIPv4Stack=true-XX:+HeapDumpOnOutOfMemoryError-XX:-OmitStackTraceInFastThrow-Xverify:none-XX:ErrorFile=$USER_HOME/java_error_in_idea_%p.log-XX:HeapDumpPath=$USER_HOME/java_error_in_idea.hprof-Xbootclasspath/a:../lib/boot.jar 启动Idea 后我们可以在/tmp/system.out中可以看到这些关键的日志123456789101112131415161718192021222324252627282930--------------------com.seventh7.widget.iedis.L.a(java.lang.String)return:&#123;&quot;trailing&quot;:true,&quot;daysLeft&quot;:9,&quot;popup&quot;:true,&quot;activated&quot;:false&#125;--------------------com.seventh7.widget.iedis.B.a()return:186b474e0ffffffb70ffffff96680ffffffc0240ffffff89456b0fffffffa320ffffffa70ffffff92--------------------com.seventh7.widget.iedis.x.a(byte[])return:MTg2YjQ3NGUwZmZmZmZmYjcwZmZmZmZmOTY2ODBmZmZmZmZjMDI0MGZmZmZmZjg5NDU2YjBmZmZmZmZmYTMyMGZmZmZmZmE3MGZmZmZmZjkyOjI=--------------------com.seventh7.widget.iedis.L.a(java.lang.String)return:&#123;&quot;trailing&quot;:true,&quot;daysLeft&quot;:9,&quot;popup&quot;:true,&quot;activated&quot;:false&#125;--------------------com.seventh7.widget.iedis.L.a(java.lang.String)[https://www.codesmagic.com/q2?t=MTg2YjQ3NGUwZmZmZmZmYjcwZmZmZmZmOTY2ODBmZmZmZmZjMDI0MGZmZmZmZjg5NDU2YjBmZmZmZmZmYTMyMGZmZmZmZmE3MGZmZmZmZjkyOjI=]return:&#123;&quot;trailing&quot;:true,&quot;daysLeft&quot;:9,&quot;popup&quot;:true,&quot;activated&quot;:false&#125;--------------------com.seventh7.widget.iedis.a.p.b(int,int)[-13938, -6118]return:trailing--------------------com.seventh7.widget.iedis.a.p.b(int,int)[-13937, -25088]return:daysLeft--------------------com.seventh7.widget.iedis.a.p.b(int,int)[-13939, 7216]return:popup 从上面的日志可以看出一些关键点： https://www.codesmagic.com/q2?t= 是注册的服务器 com.seventh7.widget.iedis.a.o 这个类是很关键的类 认证服务器返回的认证结果为{“trailing”:true,”daysLeft”:9,”popup”:true,”activated”:false} 查看反编译的代码，可以看出这个类是一个抽象类，他的唯一子类是com.seventh7.widget.iedis.a.p，根据外面获取到的运行日志，大概可以推断出 f这个方法是认证的方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.seventh7.widget.iedis.a;import com.seventh7.widget.iedis.b.d.a;import java.util.Map;import java.io.IOException;import com.seventh7.widget.iedis.L;class p extends o&#123; private static final String[] kb; private static final String[] lb; //基本上可以推断出 这个就是认证的方法，最直接的方法就是直接return true @Override protected boolean f() throws IOException &#123; //this.d() 是调用https://www.codesmagic.com/q2去注册的 //Map的返回值&#123;&quot;trailing&quot;:true,&quot;daysLeft&quot;:9,&quot;popup&quot;:true,&quot;activated&quot;:false&#125; final Map d = this.d(); //trailing final boolean booleanValue = L.a(d, b(-13938, -6118)); //this.d()执行后的异常信息。 final a[] b = av.b(); //daysLeft final int b2 = L.b(d, b(-13937, -25088)); //popup final boolean booleanValue2 = L.a(d, b(-13939, 7216)); boolean booleanValue3 = false; Label_0104: &#123; Label_0074: &#123; boolean b3; try &#123; b3 = (booleanValue3 = booleanValue); if (b != null) &#123; break Label_0104; &#125; if (b3) &#123; break Label_0074; &#125; break Label_0074; &#125; catch (IOException ex) &#123; throw b(ex); &#125; try &#123; if (b3) &#123; this.a(b2, booleanValue2); return false; &#125; &#125; catch (IOException ex2) &#123; throw b(ex2); &#125; &#125; //actived booleanValue3 = L.a(d, b(-13940, 8507)); &#125; final boolean b4 = booleanValue3; //如果已经过了试用，就检测激活 Label_0122: &#123; boolean b5; try &#123; final boolean b6; b5 = (b6 = b4); // b = av.b() if (b != null) &#123; return b6; &#125; if (!b5) &#123; break Label_0122; &#125; return true; &#125; catch (IOException ex3) &#123; throw b(ex3); &#125; try &#123; if (!b5) &#123; this.c(); return false; &#125; &#125; catch (IOException ex4) &#123; throw b(ex4); &#125; &#125; return true; &#125; private static IOException b(final IOException ex) &#123; return ex; &#125; &#125; 从上面的分享结果可以看出，有两种破解思路 方法一 修改 com.seventh7.widget.iedis.a.p.f 永远return true 方法二 搭建一个认证服务器，本地替换host，认证服务器返回的结果为 1&#123; &quot;trailing&quot;: false, &quot;popup&quot;: true, &quot;activated&quot;: true, &quot;daysLeft&quot;: 0 &#125; 方法一的实现 123456789101112131415161718192021222324252627282930313233343536public class IedisCracker &#123; private final static String IDEA_LIB=&quot;/Applications/IntelliJ IDEA.app/Contents/lib/*&quot;; private final static String IDEIS_LIB=&quot;/Users/liaojiacan/Library/Application Support/IntelliJIdea2017.2/Iedis/lib/*&quot;; public static void main(String[] args) &#123; try &#123; ClassPool.getDefault().appendClassPath(IDEA_LIB); ClassPool.getDefault().appendClassPath(IDEIS_LIB); CtClass clazz = ClassPool.getDefault().getCtClass(&quot;com.seventh7.widget.iedis.a.p&quot;); CtMethod[] mds = clazz.getDeclaredMethods(); for(CtMethod method : mds)&#123; if(method.getLongName().startsWith(&quot;com.seventh7.widget.iedis.a.p.f&quot;))&#123; System.out.println(&quot;Inject :: SUCCESS!&quot;); try &#123; method.insertBefore(&quot;if(true)&#123;return true;&#125; &quot;); &#125; catch (CannotCompileException e) &#123; e.printStackTrace(); &#125; continue; &#125; &#125; clazz.writeFile(&quot;/tmp/p.class&quot;); &#125; catch (NotFoundException e) &#123; e.printStackTrace(); &#125; catch (CannotCompileException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"逆向","slug":"逆向","permalink":"http://liaojiacan.me/categories/逆向/"}],"tags":[{"name":"java逆向","slug":"java逆向","permalink":"http://liaojiacan.me/tags/java逆向/"}]},{"title":"proto变量类型与java类型对照表","slug":"proto变量类型与java类型对照表","date":"2017-10-11T02:53:00.000Z","updated":"2017-10-11T02:54:57.000Z","comments":true,"path":"2017/10/11/proto变量类型与java类型对照表/","link":"","permalink":"http://liaojiacan.me/2017/10/11/proto变量类型与java类型对照表/","excerpt":"","text":"proto type java type double double float float int32 int int64 long uint32 int uint64 long sint32 int sint64 long fixed32 int fixed64 long sfixed32 int sfixed32 long bool boolean string string bytes ByteString","categories":[],"tags":[{"name":"Protobuf","slug":"Protobuf","permalink":"http://liaojiacan.me/tags/Protobuf/"},{"name":"rpc","slug":"rpc","permalink":"http://liaojiacan.me/tags/rpc/"}]},{"title":"proto文件","slug":"proto文件","date":"2017-10-10T11:52:00.000Z","updated":"2017-10-10T11:57:15.000Z","comments":true,"path":"2017/10/10/proto文件/","link":"","permalink":"http://liaojiacan.me/2017/10/10/proto文件/","excerpt":"","text":"proto文件是Proto buffers的描述文件 syntax 指定pd编译器的版本，可以设置proto2或者proto3 message 类似java中的class关键字，在PB这里叫消息体 service 服务声明 修饰符 required 非空，必须存在 optional 可选 repeated 可重复出现，类似集合的概念吧 更多介绍参考官方文档，Protocal Buffers 123456789101112131415syntax = &quot;proto3&quot;;service SearchService&#123; rpc search(SearchRequest) returns (SearchResponse) &#123;&#125;&#125;message SearchRequest &#123; required string query = 1; optional int32 page_number = 2; optional int32 result_per_page = 3;&#125;message SearchResponse &#123; string result = 1;&#125;","categories":[],"tags":[{"name":"Protobuf","slug":"Protobuf","permalink":"http://liaojiacan.me/tags/Protobuf/"},{"name":"rpc","slug":"rpc","permalink":"http://liaojiacan.me/tags/rpc/"}]},{"title":"javaagent 的使用","slug":"javaagent-的使用","date":"2017-10-10T03:40:00.000Z","updated":"2017-10-10T03:43:58.000Z","comments":true,"path":"2017/10/10/javaagent-的使用/","link":"","permalink":"http://liaojiacan.me/2017/10/10/javaagent-的使用/","excerpt":"","text":"javaagent 是类似一个JVM的插件，利用JVM提供的Instrumentation API实现获取或者修改加载到JVM中的类字节码。 编写一个javagent的jar的方式如下： 1.实现一个ClassFileTransformer 12345678910public class SimpleTransformer implements ClassFileTransformer &#123; @Override public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException &#123; System.out.println(className); System.out.println(protectionDomain.toString()); return new byte[0]; &#125;&#125; 2.实现一个Premain-Class 12345678910public class Main &#123; public static void premain(String agentOps, Instrumentation inst) &#123; inst.addTransformer(new SimpleTransformer()); &#125; public static void main(String[] args) &#123; System.out.println(&quot;This is a javaagent!&quot;); &#125;&#125; 3.MANIFEST.MF配置 12345Manifest-Version: 1.0Premain-Class: com.github.liaojiacan.MainCan-Redefine-Classes: trueCan-Retransform-Classes: trueCan-Set-Native-Method-Prefix: true 4.运行命令 1java -javaagent:agent.jar -jar app.jar 代码和assembly的打包配置可以参考，github","categories":[{"name":"逆向","slug":"逆向","permalink":"http://liaojiacan.me/categories/逆向/"}],"tags":[{"name":"java逆向","slug":"java逆向","permalink":"http://liaojiacan.me/tags/java逆向/"},{"name":"java","slug":"java","permalink":"http://liaojiacan.me/tags/java/"}]},{"title":"Linux shell命令:cut命令","slug":"Linux Shell--cut命令","date":"2017-02-23T08:45:44.000Z","updated":"2017-09-29T09:50:37.000Z","comments":true,"path":"2017/02/23/Linux Shell--cut命令/","link":"","permalink":"http://liaojiacan.me/2017/02/23/Linux Shell--cut命令/","excerpt":"","text":"简介将一段数据经过分析，取出我们想要的 1234cut -- cut out selected portions of each line of a file SYNOPSIScut -b list [-n] [file ...]cut -c list [file ...]cut -f list [-d delim] [-s] [file ...] -b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。 -c ：以字符为单位进行分割。 -d ：自定义分隔符，默认为制表符。 -f ：与-d一起使用，指定显示哪个区域。 -n ：取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的范围之内，该字符将被写出；否则，该字符将被排除。 1who | cut -d 3-5 #截取 3-5列的内容 1who | cut -c 3-5 #截取 3-5列的内容 中文字符 1cat /etc/passwd|head -n 5|cut -d : -f -2 # 设置分隔符为：","categories":[{"name":"linux","slug":"linux","permalink":"http://liaojiacan.me/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://liaojiacan.me/tags/linux/"},{"name":"shell","slug":"shell","permalink":"http://liaojiacan.me/tags/shell/"}]}]}