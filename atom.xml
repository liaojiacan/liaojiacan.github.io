<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jiacan‘s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liaojiacan.me/"/>
  <updated>2019-03-17T08:46:51.535Z</updated>
  <id>http://liaojiacan.me/</id>
  
  <author>
    <name>Jiacan Liao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>自定义ClassLoader实现一个支持热加载的应用启动器</title>
    <link href="http://liaojiacan.me/2019/03/17/%E8%87%AA%E5%AE%9A%E4%B9%89ClassLoader%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%94%AF%E6%8C%81%E7%83%AD%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E5%99%A8/"/>
    <id>http://liaojiacan.me/2019/03/17/自定义ClassLoader实现一个支持热加载的应用启动器/</id>
    <published>2019-03-17T08:46:00.000Z</published>
    <updated>2019-03-17T08:46:51.535Z</updated>
    
    <content type="html"><![CDATA[<p>JVM 默认是不支持Class的热加载的，也就是说我们的代码有变动，就要重启JVM来达到加载新的Class目的，但是很多容器如Tomcat、Jetty等都可以支持热加载，其底层的原理就是自定义ClassLoader。OSGI更是将类加载器玩到极至。我们来看看怎么实现一个简单的支持热加载的应用启动器。</p><h3 id="一-实现的目标"><a class="markdownIt-Anchor" href="#一-实现的目标"></a> 一、实现的目标</h3><ul><li>支持热加载</li><li>可配置的启动类</li></ul><h3 id="二-实现"><a class="markdownIt-Anchor" href="#二-实现"></a> 二、实现</h3><h4 id="1-支持热加载"><a class="markdownIt-Anchor" href="#1-支持热加载"></a> 1. 支持热加载</h4><p>关于类的加载，必然要说一下ClassLoader，JDK中存在这几个ClassLoader：</p><ul><li>BootstrapClassLoader 加载基础类</li><li>ExtClassLoader 加载拓展类，父加载器是BootstrapClassLoader</li><li>AppClassLoader 加载应用程序类 ，父加载器是ExtClassLoader</li></ul><p><strong>双亲委派：</strong><br>官方建议开发者，实现类加载器时遵循双亲委派规则，就是加载一个类时，先交给父加载器加载，如果父加载器无法加载，再由当前类加载器加载，从代码上来说，AppClassLoader已经写好了这个模版类，我们只需要覆盖findClass的逻辑即可。</p><blockquote><p>实现热加载需要违背双亲委派规则吗？</p></blockquote><p>由于ClassLoader中的defineClass方法会对已加载的类进行校验，所以我们无法对一个类进行重复加载，要实现热加载只能创建一个新的ClassLoader，假如我们采用双亲委派规则，那么我们需要加载的类会先被父加载器（AppClassLoader）给加载缓存起来，之后我们无论怎么创建一个新的加载器也无法达到热加载的目的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class HotSwapClassLoader extends ClassLoader &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 指定目录下的类可以热加载</span><br><span class="line"> */</span><br><span class="line">private String basePath;</span><br><span class="line"></span><br><span class="line">public HotSwapClassLoader(String basePath) &#123;</span><br><span class="line">this.basePath = basePath;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">// 加载指定目录下的class</span><br><span class="line">if (c == null) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">c = findClass(name);</span><br><span class="line">if (c != null) &#123;</span><br><span class="line">return c;</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">return super.loadClass(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return super.loadClass(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">String classResourcePath = this.basePath + &quot;/&quot; + name.replaceAll(&quot;\\.&quot;, &quot;/&quot;);</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">FileInputStream fileInputStream = new FileInputStream(new File(classResourcePath));</span><br><span class="line">ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();</span><br><span class="line">int len;</span><br><span class="line">byte[] buffer = new byte[1024];</span><br><span class="line">while ((len = fileInputStream.read(buffer)) &gt; 0) &#123;</span><br><span class="line">byteArrayOutputStream.write(buffer, 0, len);</span><br><span class="line">&#125;</span><br><span class="line">byte[] bytes = byteArrayOutputStream.toByteArray();</span><br><span class="line">return defineClass(name, bytes, 0, bytes.length);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">throw new ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-启动器"><a class="markdownIt-Anchor" href="#2-启动器"></a> 2. 启动器</h4><p>上面我们已经实现了一个可以随时替换的ClassLoader，我们还需要一个引导类去维护我们的ClassLoader 还有我们的应用启动入口，管理启动和关闭的时机，就好比Tomcat的Catalina一样，或者说我们的任何类的Main函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Bootstrap &#123;</span><br><span class="line"></span><br><span class="line">private String basePath;</span><br><span class="line">private Object application;</span><br><span class="line">private String applicationClassName;</span><br><span class="line">private volatile ClassLoader applicationClassLoader;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public Bootstrap(String basePath, String applicationClassName) &#123;</span><br><span class="line">this.basePath = basePath;</span><br><span class="line">this.applicationClassLoader = new HotSwapClassLoader(this.basePath);</span><br><span class="line">this.applicationClassName = applicationClassName;</span><br><span class="line">try &#123;</span><br><span class="line">this.application = getApplication();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了上面的那些成员，我们就可以利用Java的反射来实现自定义的Application类的启动（这个类可以方在任意位置，就好比我们的war包可以方在任意位置，只要在tomcat的server.xml中配置好baseApps的路径就好了）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void startApplication() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">this.application.getClass().getDeclaredMethod(&quot;start&quot;, null).invoke(this.application, new Object[0]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void stopApplication() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">this.application.getClass().getDeclaredMethod(&quot;stop&quot;, null).invoke(this.application, new Object[0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，剩下最后一个问题就是，我们怎么知道我们的类需要加载呢？有2种方式就是主动刷新，还有一种就是程序监听文件夹的文件变动。我们可以利用jdk7之后提供的WatchService来监控文件或者目录的变动情况，一发生变动，则先注销之前的Application 然后再创建一个新的HotSwapClassLoader来启动新的Application。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private void registerResourceWatcher() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">WatchService watchService = FileSystems.getDefault().newWatchService();</span><br><span class="line">Path p = Paths.get(basePath);</span><br><span class="line">p.register(watchService, new WatchEvent.Kind[]&#123;ENTRY_MODIFY, ENTRY_CREATE, ENTRY_DELETE&#125;);</span><br><span class="line">while (true) &#123;</span><br><span class="line">WatchKey k = watchService.take();</span><br><span class="line">for (WatchEvent&lt;?&gt; e : k.pollEvents()) &#123;</span><br><span class="line">reloadApplication();</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">k.reset();</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-测试"><a class="markdownIt-Anchor" href="#三-测试"></a> 三、测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">public Integer version = 46;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 应用的启动入口</span><br><span class="line"> */</span><br><span class="line">public void start() &#123;</span><br><span class="line">System.out.println(&quot;Start... version=&quot; + version);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 应用的停止入口</span><br><span class="line"> */</span><br><span class="line">public void stop() &#123;</span><br><span class="line">System.out.println(&quot;Stop... version=&quot; + version);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws IOException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">new Bootstrap(&quot;/Users/liaojiacan/Workspace/java/personal/code-snippets/java-language/target/classes&quot;</span><br><span class="line">,&quot;com.github.liaojiacan.classloader.app.Application&quot;).boot();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动后，我们修改Application的 version=47，然后rebuild project，这个时候这个文件就会发生改变,输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Start... version=46</span><br><span class="line">Stop... version=46</span><br><span class="line">Start... version=47</span><br></pre></td></tr></table></figure><p>完整代码见Github :<a href="https://github.com/liaojiacan/code-snippets/tree/master/java-language/src/main/java/com/github/liaojiacan/classloader" target="_blank" rel="noopener">https://github.com/liaojiacan/code-snippets/tree/master/java-language/src/main/java/com/github/liaojiacan/classloader</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JVM 默认是不支持Class的热加载的，也就是说我们的代码有变动，就要重启JVM来达到加载新的Class目的，但是很多容器如Tomcat、Jetty等都可以支持热加载，其底层的原理就是自定义ClassLoader。OSGI更是将类加载器玩到极至。我们来看看怎么实现一个简单
      
    
    </summary>
    
      <category term="JDK" scheme="http://liaojiacan.me/categories/JDK/"/>
    
    
      <category term="ClassLoader" scheme="http://liaojiacan.me/tags/ClassLoader/"/>
    
      <category term="热加载" scheme="http://liaojiacan.me/tags/%E7%83%AD%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Java中的多线程和锁实现原理</title>
    <link href="http://liaojiacan.me/2019/03/11/Java%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://liaojiacan.me/2019/03/11/Java中的多线程和锁实现原理/</id>
    <published>2019-03-11T09:19:00.000Z</published>
    <updated>2019-03-23T09:40:54.721Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程的实现"><a class="markdownIt-Anchor" href="#线程的实现"></a> 线程的实现</h2><p>Java 规范里面并没有规定JVM要如何实现线程模型，在HotSpot VM 中使用的是1:1的线程模型，即1个java线程对应一个OS的线程（内核线程），在Thread中又很多native方法，就是调用OS的函数进行用户线程和内核线程的绑定。</p><ul><li>每个线程都又一个内核线程与之绑定，用户线程推出，内核线程也会一起退出。</li><li>内核线程的数量是有限制的</li><li>内核线程调用，上下文切换开销很大。</li></ul><h3 id="线程调度"><a class="markdownIt-Anchor" href="#线程调度"></a> 线程调度</h3><h4 id="线程的状态-threadstate枚举"><a class="markdownIt-Anchor" href="#线程的状态-threadstate枚举"></a> 线程的状态 （Thread.State枚举）</h4><ul><li>NEW :</li><li>RUNNABLE : 对应的就绪和运行态</li><li>BLOCKED : 阻塞状态，处于阻塞状态的线程会不断地请求资源，请求成功后就会进入就绪状态。</li><li>WAITING : 等待状态，当线程调用wait,join,park等函数。等待状态下会释放资源，让出CPU和释放锁。需要其他线程唤醒。</li><li>TIMED_WAITING  有限的等待。</li><li>TERMINATED</li></ul><h3 id="线程相关的一些文章"><a class="markdownIt-Anchor" href="#线程相关的一些文章"></a> 线程相关的一些文章</h3><ul><li><a href="https://www.zhihu.com/question/27491155/answer/36847691" target="_blank" rel="noopener">Java的线程管理器能保证每个线程都有执行的机会么?</a></li><li><a href="http://www.hainiubl.com/topics/29" target="_blank" rel="noopener">wait/notify实现原理</a></li></ul><h2 id="锁"><a class="markdownIt-Anchor" href="#锁"></a> 锁</h2><p>因为多线程的共享数据存在线程安全问题，需要通过一些控制来保证共享数据的读写，JVM层面提供sychronized的锁，而java层面current包下面有许多基于AQS的Lock的实现,在jdk1.6后,synchronized 和 ReentrantLock性能上以及没有太大的差距，ReentrantLock的使用更佳灵活，性能稳定，支持超时机制等，而采用synchronized不需要程序自己控制锁的加锁和释放，不容易出现死锁等问题。</p><h3 id="synchronized-的实现原理"><a class="markdownIt-Anchor" href="#synchronized-的实现原理"></a> synchronized 的实现原理</h3><p>JVM规范规定基于进入和退出monitor对象来控制方法和代码块的同步，也是就是monitorenter和monitorexit两个指令，当程序执行到monitorenter指令时会尝试获取对象的monitor所有权，也就是获取对象的锁。在最开始的JVM实现中是采用重量级锁的实现，线程的切换都涉及到用户态到内核态的切换，比较消化资源，所以在jdk1.6对锁进行优化。</p><h4 id="同步原理"><a class="markdownIt-Anchor" href="#同步原理"></a> 同步原理</h4><blockquote><ul><li>JVM是怎么控制多线程程序的交替访问的？</li></ul></blockquote><p>Java中每个对象都有一个内置锁与之对应，所有需要对该对象进行排他性或者一致性访问时需要获取对象的内置锁（synchronized 中的代码，monitorenter指令）。这个内置锁的信息存在对象的对象头中（一些基本信息，其他的condition，队列等是在native heap中的）。一个对象的Monitor只能被一个线程获取到，其他线程得等待持有的Monitor的线程释放。</p><blockquote><p>在一些官方的注释中说的是ObjectMonitor是一个内联锁对象的封装，就好比JVM层面实现的一个类似JUC框架下的Lock（不是说ObjectMonitor是JUC的Lock实现，说的是他们可能实现思路是一样的）。</p></blockquote><p>做好线程的同步协调，我认为需要这3样东西（ObjectMonitor 和J.U.C的AQS 都是这样的）：</p><ol><li>维护一个竞争的互斥量</li><li>一个队列</li><li>线程的挂起和唤醒</li></ol><blockquote><p>实现同步也可以只用一个互斥量，自旋锁就是这么实现的，但是锁竞争太激烈会导致CPU做无用功。</p></blockquote><p>想继续了解ObjectMonitor的实现可以看这几篇文章：</p><ul><li><a href="http://moonfacex.github.io/blog/java/2016/03/31/synchronized_and_monitor.html" target="_blank" rel="noopener">synchronized 与 object’s Monitor</a></li><li><a href="https://www.hollischuang.com/archives/2030" target="_blank" rel="noopener">Moniter实现原理</a></li></ul><h4 id="对象头"><a class="markdownIt-Anchor" href="#对象头"></a> 对象头</h4><blockquote><ul><li>Object的锁信息是存在在哪里的？</li><li>在获取对象的锁的过程中都用到了对象头的哪些数据？</li></ul></blockquote><p>锁的信息存在java对象头里面。如果对象是数组，这虚拟机会用3个Word(32位虚拟机，32bit)来存对象头，如果对象是非数组类型，则用2个Word来存对象头，其中 有一个word用来存储对象的hashcode和锁信息，32bit，叫Mark word。</p><ul><li>Mark Word 不是一个固定的数据结构，具体的信息分布需要先判断2bit的锁标志位，不同的锁标志位，剩余的30bit可能表示不同的意思。</li><li>32bit的信息是不够存Monitor线程同步（调度）所需要的信息的，所以重量级锁是有另外的native heap存储的，之后再把指针存在Mark word 中。</li></ul><table width="500" border="1" cellspacing="0" cellpadding="0"><tbody><tr><td rowspan="2" valign="top" width="76"><strong>锁状态</strong></td><td colspan="3" valign="top" width="106"><p align="center">25 bit</p></td><td rowspan="2" valign="top" width="85"><p align="center">4bit</p></td><td valign="top" width="85">1bit</td><td valign="top" width="78">2bit</td></tr><tr><td colspan="2" valign="top" width="70">23bit</td><td valign="top" width="56">2bit</td><td valign="top" width="120">是否是偏向锁</td><td valign="top" width="100">锁标志位</td></tr><tr><td valign="top" width="90">轻量级锁</td><td colspan="5" valign="top" width="276">指向栈中锁记录的指针</td><td valign="top" width="78">00</td></tr><tr><td valign="top" width="76">重量级锁</td><td colspan="5" valign="top" width="276">指向互斥量（重量级锁）的指针</td><td valign="top" width="78">10</td></tr><tr><td valign="top" width="76">GC标记</td><td colspan="5" valign="top" width="276">空</td><td valign="top" width="78">11</td></tr><tr><td valign="top" width="76">偏向锁</td><td valign="top" width="80">线程ID</td><td colspan="2" valign="top" width="80">Epoch</td><td valign="top" width="120">对象分代年龄</td><td valign="top" width="85">1</td><td valign="top" width="78">01</td></tr></tbody></table><h4 id="锁的优化"><a class="markdownIt-Anchor" href="#锁的优化"></a> 锁的优化</h4><p>在jdk1.6之前synchronized是单纯的重量级锁实现，由于重量级锁，线程获取不到锁就需要挂起等待唤醒，这种切换涉及到了用户态到内核态的转换，开销还是比较大的。在jdk1.6加入了偏向锁、轻量级锁。只有一个线程请求对象锁的时候，启用的是偏向锁，当有第二个线程竞争的时候（应该说是偏向状态出现锁竞争），这个时候会升级为轻量级锁（cas 自旋锁），处于轻量级锁状态下，如果自旋10次（可以配置）还是获取锁失败，则锁升级为重量级锁。</p><ul><li><p>偏向锁 ：在大部分情况下一个同步方法或者一个同步代码块不存在多线程的竞争，这样只需要在对象头和当前线程的栈帧中存一个线程ID，每次获取锁的时候只需要判断一些线程ID释放一致就行了，不用进行CAS的加锁和解锁。如果有第二个线程需要竞争锁，这个时候会通过CAS设置Mark Word中的锁状态位，成功则修改为偏向当前线程，失败的话就进行锁的升级，锁升级涉及到偏向锁的撤销，会将偏向锁线程挂起。</p><blockquote><p><a href="https://stackoverflow.com/questions/14717736/where-is-objects-hash-code-stored-if-biased-locking-is-enabled-in-hotspot-jvm" target="_blank" rel="noopener">偏向锁会将Mark Word设置为当前threadId，那么hashCode存哪里了?</a><br>如果处于偏向的的对象调用的hashCode方法就会触发撤销偏向锁</p></blockquote></li><li><p>轻量级锁：线程在获取锁之前，当前线程会在栈帧中创建一个Mark Word的拷贝作为锁记录，官方称为Displaced Mark Word。然后将对象头中替换成锁记录的指针（CAS），如果失败则会自旋10次（在1.6之后是采用自适应锁，这个时间已经不能自己配置了），之后升级为重量级锁。</p><blockquote><p>为什么一定要拷贝到Displaced Mark Word，而不直接就采用一个threadId？一个原因是需要恢复hash和GC分代的信息，一个就是解决重入锁的问题。</p></blockquote></li><li><p>重量级锁：ObjectMonitor有更多的空间来实现线程同步，可以更好像的实现线程同步（挂起和唤醒）。<a href="https://www.zhihu.com/question/41930877/answer/136699311" target="_blank" rel="noopener">轻量级锁为什么要膨胀？</a></p></li></ul><h4 id="优缺点"><a class="markdownIt-Anchor" href="#优缺点"></a> 优缺点</h4><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>使用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>只需比较threadId释放是否是当前线程<br>没有CAS的消耗</td><td>当出现锁竞争的时候会有锁撤销的消耗</td><td>单个线程</td></tr><tr><td>轻量级锁</td><td>线程一直在用户态，不用挂起。没有线程切换的消耗</td><td>自旋会导致CPU做无用功</td><td>同步代码块执行较快。</td></tr><tr><td>重量级锁</td><td>线程挂起，不用进行自旋</td><td>用户态到内核态转化，开销大</td><td>同步代码块执行时间较长，锁竞争激烈</td></tr></tbody></table><h3 id="juc中的锁"><a class="markdownIt-Anchor" href="#juc中的锁"></a> J.U.C中的锁</h3><p>上面锁的synchronzied是JVM的内置锁，在1.6之前性能比较差，Doug Lea就写个并发框架(java.util.current)，在1.6之后synchronized的性能已经跟Lock查不不多了，但是还少了锁的获取和释放的操作性，不支持超时，只有一个condition等。</p><h4 id="aqs"><a class="markdownIt-Anchor" href="#aqs"></a> AQS</h4><p>AbstractQueueSynchronizer是J.U.C中其他锁或者同步器的基础框架（ReentrantLock,ReentrantReadWriteLock,CountdDownLatch,CyclicBarrier等），这些框架在AQS的基础上进行了扩展，通常是继承AQS然后实现了AQS的几个抽象方法。</p><blockquote><p>我在上面说ObjectMonitor有说到，同步器为了完成同步工作，需要3个东西：</p></blockquote><ol><li>用于同步的状态量</li><li>一个队列或者一个保存等待线程的容器</li><li>线程的挂起和唤醒</li></ol><p>我们看下AQS是怎么围绕这3个部分进行实现的。</p><h5 id="1-同步的状态量互斥量"><a class="markdownIt-Anchor" href="#1-同步的状态量互斥量"></a> 1. 同步的状态量(互斥量)</h5><p>AQS中维护一个volatile 的int 变量state，线程通过cas来获取这个互斥量。AQS提供一下几个方法来对state变量进行操作。</p><ul><li>getState()</li><li>compareAndSetState(int expect, int update)</li><li>setState(int state)</li></ul><p>有了上面的3个方法，同步器就可以实现自旋锁，但是如果想实现公平锁，上面的三个方法或者说单用一个state变量是无法做到了。这个时候就需要一个FIFO的队列来维护这些线程。此外为了实现重入锁，我们还得需要一个变量来存当前持有的锁是什么线程。</p><h5 id="2等待线程队列"><a class="markdownIt-Anchor" href="#2等待线程队列"></a> 2.等待线程队列</h5><p>AQS 用了一个CLH的双向队列，Node的数据结构大概如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">statci final class Node&#123;</span><br><span class="line">    </span><br><span class="line">    volatile int waitStatus;</span><br><span class="line">    volatile Node prev;</span><br><span class="line">    volatile Node next;</span><br><span class="line">    Node nextWaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS维护一个头节点和一个尾节点，入队的时候通过CAS加入到未尾节点中。入队后开始开始自旋。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            // 前趋节点是头节点，并且获取到互斥量，说明获取锁成功。</span><br><span class="line">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = null; // help GC</span><br><span class="line">                failed = false;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            // 判断是否需要挂起</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码片段可以看出，加入队列的线程节点并不是完全的自旋，shouldParkAfterFailedAcquire方法判断当前线程是否需要挂起。</p><blockquote><p>下面的这个方法表明shouldParkAfterFailedAcquire 会在调用1到2次后会返回true（如果期间节点没有发生改变的话）。也就是自旋锁只自旋了2次就会被挂起。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">        int ws = pred.waitStatus;</span><br><span class="line">        if (ws == Node.SIGNAL)</span><br><span class="line">            /*</span><br><span class="line">             * This node has already set status asking a release</span><br><span class="line">             * to signal it, so it can safely park.</span><br><span class="line">             */</span><br><span class="line">            return true;</span><br><span class="line">        if (ws &gt; 0) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * Predecessor was cancelled. Skip over predecessors and</span><br><span class="line">             * indicate retry.</span><br><span class="line">             */</span><br><span class="line">            do &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /* </span><br><span class="line">             * 进行到这里说明前驱节点的waitStatus 是0 或者PROPAGATE ，利用CAS的设置为SIGNAL，这样下次自旋就会阻塞了，这里不返回true的目的是让当前线程再自旋一次，确保挂起前是无法获取到锁（避免发生刚挂起就被唤醒的情况）。</span><br><span class="line">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="line">             * need a signal, but don&apos;t park yet.  Caller will need to</span><br><span class="line">             * retry to make sure it cannot acquire before parking.</span><br><span class="line">             */</span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="3线程的挂起和唤醒"><a class="markdownIt-Anchor" href="#3线程的挂起和唤醒"></a> 3.线程的挂起和唤醒</h5><p>AQS中实现线程的挂起和唤醒是通过LockSupport这个工具，LockSupport的底层实现是调用Unsafe的native方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void unpark(Thread thread) &#123;</span><br><span class="line">    if (thread != null)</span><br><span class="line">        UNSAFE.unpark(thread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void park(Object blocker) &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    setBlocker(t, blocker);</span><br><span class="line">    UNSAFE.park(false, 0L);</span><br><span class="line">    setBlocker(t, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="conditionobject"><a class="markdownIt-Anchor" href="#conditionobject"></a> ConditionObject</h5><p>ConditionObject 是AQS实现类似object类的wait/notify/notifyAll方法的，ConditionObject提供的是aw<br>ait/awaitNanos(long nanos)/awaitUtil(Date date)/awaitUniterrutibly()/signal()/signalAll()。底层的实现也是各自维护一个队列，Node.nextWaiter。</p><ul><li>对于超时机制也是用LockSupport中的实现，但并不是所有情况下都使用系统的休眠，有个休眠的自旋时间阀值<code>spinForTimeoutThreshold = 1000L</code> ，默认是1000 纳秒，少于这个阀值的都不用休眠，而是直接自旋。</li></ul><h3 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h3><ul><li><a href="http://moonfacex.github.io/blog/java/2016/03/31/synchronized_and_monitor.html" target="_blank" rel="noopener">synchronized 与 object’s Monitor</a></li><li><a href="http://ifeve.com/introduce-abstractqueuedsynchronizer/" target="_blank" rel="noopener">AbstractQueuedSynchronizer的介绍和原理分析</a></li><li><a href="https://blog.csdn.net/chenssy/article/details/65449785" target="_blank" rel="noopener">J.U.C之AQS：阻塞和唤醒线程</a></li><li><a href="https://blog.csdn.net/m_xiaoer/article/details/73274642" target="_blank" rel="noopener">关于synchronized的Monitor Object机制的研究</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html" target="_blank" rel="noopener">Intrinsic Locks and Synchronization</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;线程的实现&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#线程的实现&quot;&gt;&lt;/a&gt; 线程的实现&lt;/h2&gt;
&lt;p&gt;Java 规范里面并没有规定JVM要如何实现线程模型，在HotSpot VM 中使用的是1:1的线程模型，即1个java线程对
      
    
    </summary>
    
      <category term="jdk" scheme="http://liaojiacan.me/categories/jdk/"/>
    
    
      <category term="多线程" scheme="http://liaojiacan.me/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="synchronized" scheme="http://liaojiacan.me/tags/synchronized/"/>
    
      <category term="AQS" scheme="http://liaojiacan.me/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>Innodb中的锁总结</title>
    <link href="http://liaojiacan.me/2019/02/28/Innodb%E4%B8%AD%E7%9A%84%E9%94%81%E6%80%BB%E7%BB%93/"/>
    <id>http://liaojiacan.me/2019/02/28/Innodb中的锁总结/</id>
    <published>2019-02-28T11:22:00.000Z</published>
    <updated>2019-02-28T11:23:06.288Z</updated>
    
    <content type="html"><![CDATA[<h3 id="锁的种类"><a class="markdownIt-Anchor" href="#锁的种类"></a> 锁的种类</h3><h4 id="表锁"><a class="markdownIt-Anchor" href="#表锁"></a> 表锁</h4><ul><li>LOCK TABLE <em>table_name</em> READ : 用读锁锁表，阻塞其他事务修改</li><li>LOCK TABLE <em>table_name</em> WRITE: 用写锁锁表，阻塞其他事务读和写</li></ul><h4 id="行锁"><a class="markdownIt-Anchor" href="#行锁"></a> 行锁</h4><ul><li>X锁：排他锁，允许对数据进行删除和更新/插入</li><li>S锁：共享锁，允许对数据进行读取，可理解为读锁</li></ul><blockquote><p>锁的兼容性：如果两个事务能对一行数据同时加锁，就认为这个锁是兼容的，如果是要等待其他事务释放，则认为这2个锁是不兼容的。</p></blockquote><table><thead><tr><th>*</th><th>X</th><th>S</th></tr></thead><tbody><tr><td>X</td><td>不兼容</td><td>不兼容</td></tr><tr><td>S</td><td>不兼容</td><td>兼容</td></tr></tbody></table><h4 id="意向锁"><a class="markdownIt-Anchor" href="#意向锁"></a> 意向锁</h4><p>MySQL innodb 是支持多粒度锁的，比如可以同时存在表锁和行锁，为了更好的实现多粒度锁，innodb引入了意向锁，在innodb中的意向锁是表级的锁，意向锁与意向锁之间是兼容了，假如不存在表锁，不会有事务在加意向锁的时候阻塞。</p><ul><li>IS锁：意向共享锁，表明表中存在一行或者多行的S锁，即在给一行数据加S锁之前必在这个表加IS锁。</li><li>IX锁：意向排他锁，表明表中存在一行或者多行的X锁，即在给一行数据加S锁之前必在这个表加IX锁。</li></ul><blockquote><p>思考：为什么需要这个意向锁？</p></blockquote><p>我们比如思考一下这个场景，事务1给某个表中的N行加了行锁，这个时候事务2想给这个表加个表锁，那么事务2需要确认的事情有：</p><ol><li>这个表是否存在不兼容的表锁，比如我想加个X锁，但是已经有其他事务加了S锁。</li><li>这个表中是否已经存在不兼容的行锁。</li></ol><p>显然在确认第二个条件时，如果采用全表扫描的话，效率太低，所以意向锁的目的就是在粗粒度的锁（表锁）可以快速判断是否与低粒度的锁存在冲突。</p><table><thead><tr><th>*</th><th>IX</th><th>S</th><th>IS</th></tr></thead><tbody><tr><td>X</td><td>不兼容</td><td>不兼容</td><td>不兼容</td></tr><tr><td>IX</td><td>不兼容</td><td>兼容</td><td>不兼容</td></tr><tr><td>S</td><td>不兼容</td><td>不兼容</td><td>兼容</td></tr><tr><td>IS</td><td>不兼容</td><td>兼容</td><td>兼容</td></tr></tbody></table><h3 id="innodb行锁的形式或者算法"><a class="markdownIt-Anchor" href="#innodb行锁的形式或者算法"></a> innodb行锁的形式或者算法</h3><blockquote><p>Innodb中行锁都是加在索引上的，针对不同的场景都有不同的加锁策略。</p></blockquote><h4 id="record-lock"><a class="markdownIt-Anchor" href="#record-lock"></a> Record Lock</h4><p>记录锁，顾名思义就是锁住记录本身，锁主主键和唯一索引，如果表中没有加任何索引，锁会加在隐式生成的主键上。</p><h4 id="gap-lock"><a class="markdownIt-Anchor" href="#gap-lock"></a> Gap Lock</h4><p>间隙锁，当存在范围扫描的时候，给扫描范围加间隙锁，[起始地址，终止)</p><ol><li>不同事务对同一个区间加间隙锁是不冲突的，所以S Gap Lock 和 X Gap Lock不存在区别。</li><li>READ_COMMITED 隔离级别下不会启用间隙锁。</li></ol><h4 id="next-key-lock"><a class="markdownIt-Anchor" href="#next-key-lock"></a> Next Key Lock</h4><p>临键锁，Record Lock + Gap Lock ,锁主当前值区间+下一个区间(不一定)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10, 11, 13, 20</span><br><span class="line">(negative infinity, 10]</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, positive infinity)</span><br></pre></td></tr></table></figure><ol><li>解决的是当前读下的幻读问题。</li></ol><h4 id="insert-intention-lock"><a class="markdownIt-Anchor" href="#insert-intention-lock"></a> Insert Intention Lock</h4><p>插入意向锁，是一种特殊的间隙锁；insert之前会向插入区间加上Insert Intention Lock。</p><ol><li>Gap Lock / Next key Lock 与 Insert Intention Lock不兼容。</li><li>Gap lock 和Next key lock 的目的就是防止有数据插入间隙</li></ol><h3 id="不同sql产生的锁"><a class="markdownIt-Anchor" href="#不同sql产生的锁"></a> 不同SQL产生的锁</h3><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locks-set.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-locks-set.html</a></p><ol><li>SELECT…FROM</li></ol><blockquote><p>一致性非锁定读，除了在 SERIALIZABLE隔离级别下会存在S锁，其他隔离级别下都不会有锁。</p></blockquote><ol start="2"><li>SELECT…FOR UPDATE/SELECT…LOCK IN SHARE MODE</li></ol><blockquote><ul><li>也叫做当前读，会在给扫描过程中的索引加X或S锁，跟Where条件实际上没有强关系，只跟扫描的过程有关，所以where条件是否能够命中索引比较重要。</li><li>在检索的过程中会给用到的索引加Next Key Lock。不过如果检索条件是唯一索引能定位到一行数据，则只加Record Lock</li></ul></blockquote><ol start="3"><li>UPDATE…WHERE…</li></ol><blockquote><p>同样给检索到的记录加next key lock, 如果WHERE条件中是使用主键或者唯一索引进行限定的话，只在索引加了Record Lock。<br>如果UPDATE的是聚簇索引记录，会对受影响的辅助索引加隐式锁，当有新的辅助索引插入前的重复检测，以及在执行插入新的辅助索引记录时，对受影响的索引记录加S锁。</p></blockquote><ol start="4"><li>DELETE FROM … WHERE …</li></ol><blockquote><p>与UPDATE基本一致</p></blockquote><ol start="5"><li>INSERT</li></ol><blockquote><ul><li>给插入索引的记录加一个X锁</li><li>插入前前会加个Insert Intention Lock。</li><li>如果发生唯一键异常（duplicate-key error ），会在原记录上加S锁，这个如果和delete和update一起使用可能会导致死锁。</li></ul></blockquote><ol start="6"><li>INSERT … ON DUPLICATE KEY UPDATE</li></ol><blockquote><ul><li>跟INSERT语句有点不同的就是，当发生重复键异常是，这里加的是排他锁，而不是共享锁。</li><li>如果是唯一键异常，则加的是Next key lock。</li></ul></blockquote><ol start="7"><li>REPLACE</li></ol><blockquote><ul><li>如果没有发生冲突，则行为跟INSERT是一致的。</li><li>如果发生冲突，则对唯一键加的是Next key lock。</li></ul></blockquote><ol start="8"><li>INSERT INTO T SELECT … FROM S WHERE …</li></ol><blockquote><ul><li>给子查询语句加的X锁。</li><li>如果是READ COMMITED 隔离基本，则采用的是快照读</li></ul></blockquote><ol start="9"><li>外键约束</li></ol><blockquote><p>在进行外键约束检测时，会给记录加行级共享锁。</p></blockquote><h3 id="死锁"><a class="markdownIt-Anchor" href="#死锁"></a> 死锁</h3><blockquote><p>死锁是只当2个或者2个以上的事务抢占各自的资源，导致的相互等待的现象。</p></blockquote><h4 id="案例"><a class="markdownIt-Anchor" href="#案例"></a> 案例</h4><ol><li><a href="http://liaojiacan.me/2019/02/27/Insert-ignore-%E5%92%8Cupdate-%E5%AF%BC%E8%87%B4%E7%9A%84%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/">Insert-ignore-和update-导致的死锁问题分析</a></li></ol><h4 id="解决死锁和进行死锁检测"><a class="markdownIt-Anchor" href="#解决死锁和进行死锁检测"></a> 解决死锁和进行死锁检测</h4><ol><li>设置超时时间,事务有限时间超时,回滚其中一个事务。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;%innodb_lock_wait_timeout%&quot;;</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">| Variable_name            | Value |</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">| innodb_lock_wait_timeout | 50    |</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">1 row in set (0.07 sec)</span><br></pre></td></tr></table></figure><ol start="2"><li>wait-graph 等待图死锁检测</li></ol><ul><li>锁的信息链</li><li>事务等待链</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;锁的种类&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#锁的种类&quot;&gt;&lt;/a&gt; 锁的种类&lt;/h3&gt;
&lt;h4 id=&quot;表锁&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#表锁&quot;&gt;&lt;/a&gt; 表锁&lt;/h4&gt;
&lt;ul&gt;
      
    
    </summary>
    
      <category term="数据库" scheme="http://liaojiacan.me/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Innodb" scheme="http://liaojiacan.me/tags/Innodb/"/>
    
  </entry>
  
  <entry>
    <title>Insert ignore 和update 导致的死锁问题分析</title>
    <link href="http://liaojiacan.me/2019/02/27/Insert-ignore-%E5%92%8Cupdate-%E5%AF%BC%E8%87%B4%E7%9A%84%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <id>http://liaojiacan.me/2019/02/27/Insert-ignore-和update-导致的死锁问题分析/</id>
    <published>2019-02-27T12:13:00.000Z</published>
    <updated>2019-02-27T12:13:59.560Z</updated>
    
    <content type="html"><![CDATA[<h3 id="业务逻辑以及死锁现象"><a class="markdownIt-Anchor" href="#业务逻辑以及死锁现象"></a> 业务逻辑以及死锁现象</h3><p>业务逻辑大概如下：</p><ol><li>在粉丝表新增一条关系记录。</li><li>假如关注者也是当前用户的粉丝，则更新2者的标记为相互关注。</li></ol><p>业务代码如下, 最初是考虑用insert ignore 来解决幂等的问题，所以<strong>允许重复调用</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//是否 关注的用户是操作者的粉丝（互粉）</span><br><span class="line">boolean isHisFans = fansDao.isFans(fansUserId,followingUserId);</span><br><span class="line"></span><br><span class="line">//insert ignore into </span><br><span class="line">//  fans(fans_user_id,following_user_id,following_each_other)</span><br><span class="line">//values(#&#123;fansUserId&#125;, #&#123;followingUserId&#125;,#&#123;followingEachOther&#125;)</span><br><span class="line">int updateNum = fansDao.addFans(fansUserId, followingUserId,isHisFans);</span><br><span class="line"></span><br><span class="line">boolean addAndCheck = false;</span><br><span class="line"></span><br><span class="line">if(isHisFans)&#123;</span><br><span class="line">    // update fans</span><br><span class="line">// set following_each_other = #&#123;followingEachOther&#125;</span><br><span class="line">// where (fans_user_id = #&#123;fansUserId&#125; and following_user_id =  #&#123;followingUserId&#125; ) or (fans_user_id = #&#123;followingUserId&#125; and following_user_id = #&#123;fansUserId&#125; )</span><br><span class="line">int num = fansDao.setFollowingEachOther(followingUserId,fansUserId,true);</span><br><span class="line">if( num &gt;0 )&#123;</span><br><span class="line">//重新调整数据</span><br><span class="line">addAndCheck = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线上产生的死锁的信息(show engine innodb status)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">LATEST DETECTED DEADLOCK</span><br><span class="line">------------------------</span><br><span class="line">2019-02-12 23:24:45 7fa406a4f700</span><br><span class="line">*** (1) TRANSACTION:</span><br><span class="line">TRANSACTION 515545684, ACTIVE 0 sec starting index read</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">LOCK WAIT 3 lock struct(s), heap size 1184, 2 row lock(s)</span><br><span class="line">MySQL thread id 2121, OS thread handle 0x7fa406b12700, query id 1702086 10.10.17.63 jb-glive Searching rows for update</span><br><span class="line">update fans</span><br><span class="line">set following_each_other = 1</span><br><span class="line">where (fans_user_id = &apos;1776093&apos; and following_user_id = &apos;1331089&apos; ) or (fans_user_id = &apos;1331089&apos; and following_user_id = &apos;1776093&apos; )</span><br><span class="line">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 1023 page no 37913 n bits 400 index `UK_USER_ID` of table `glive`.`fans` trx id 515545684 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 334 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 7; hex 31333331303839; asc 1331089;;</span><br><span class="line"> 1: len 7; hex 31373736303933; asc 1776093;;</span><br><span class="line"> 2: len 8; hex 8000000001282c31; asc      (,1;;</span><br><span class="line"></span><br><span class="line">*** (2) TRANSACTION:</span><br><span class="line">TRANSACTION 515545683, ACTIVE 0 sec starting index read</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">5 lock struct(s), heap size 1184, 4 row lock(s)</span><br><span class="line">MySQL thread id 3485, OS thread handle 0x7fa406a4f700, query id 1702085 10.10.17.61 jb-glive Searching rows for update</span><br><span class="line">update fans</span><br><span class="line">set following_each_other = 1</span><br><span class="line">where (fans_user_id = &apos;1776093&apos; and following_user_id = &apos;1331089&apos; ) or (fans_user_id = &apos;1331089&apos; and following_user_id = &apos;1776093&apos; )</span><br><span class="line">*** (2) HOLDS THE LOCK(S):</span><br><span class="line">RECORD LOCKS space id 1023 page no 37913 n bits 400 index `UK_USER_ID` of table `glive`.`fans` trx id 515545683 lock_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 334 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 7; hex 31333331303839; asc 1331089;;</span><br><span class="line"> 1: len 7; hex 31373736303933; asc 1776093;;</span><br><span class="line"> 2: len 8; hex 8000000001282c31; asc      (,1;;</span><br><span class="line"></span><br><span class="line">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 1023 page no 38446 n bits 360 index `UK_USER_ID` of table `glive`.`fans` trx id 515545683 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 294 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 7; hex 31373736303933; asc 1776093;;</span><br><span class="line"> 1: len 7; hex 31333331303839; asc 1331089;;</span><br><span class="line"> 2: len 8; hex 8000000001282c59; asc      (,Y;;</span><br><span class="line"></span><br><span class="line">*** WE ROLL BACK TRANSACTION (1)</span><br></pre></td></tr></table></figure><p>锁分析：</p><ol><li>事务T2持有 (fans_user_id=1331089,following_user_id=1776093,主键=hex8000000001282c31) X 锁；</li><li>事务T2等待行锁<br>(fans_user_id=1776093,following_user_id=1331089,主键=hex8000000001282c59) X 锁；</li><li>事务T1等待T2持有的锁。</li><li>事务T1此时应该还持有T2等待的锁，只是没显示出来。</li></ol><blockquote><p>看起来就是典型的AB-BA问题</p></blockquote><h2 id="重现"><a class="markdownIt-Anchor" href="#重现"></a> 重现</h2><p>我们先简化上面的业务代码逻辑，假设fans_user_id=11000,following_user_id=10086，其实就是执行2个SQL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. insert ignore into fans(fans_user_id,following_user_id) values(11000,10086);</span><br><span class="line">2. update fans set following_each_other = 1</span><br><span class="line">where (fans_user_id = &apos;11000&apos; and following_user_id = &apos;10086&apos; ) </span><br><span class="line">or (fans_user_id = &apos;10086&apos; and following_user_id = &apos;11000&apos; );</span><br></pre></td></tr></table></figure><p>场景一：不存在fans_user_id=11000,following_user_id=10086的这条数据。</p><table><thead><tr><th>T1</th><th>T2</th></tr></thead><tbody><tr><td>&gt;begin;</td><td>&gt;begin;</td></tr><tr><td>insert ignore into fans(fans_user_id,following_user_id)<br> values(11000,10086);</td><td>*</td></tr><tr><td>*</td><td>insert ignore into fans(fans_user_id,following_user_id)<br> values(11000,10086); //阻塞</td></tr><tr><td>update fans<br> set following_each_other = 1 <br> where (fans_user_id = ‘11000’ and following_user_id = ‘10086’ ) <br> or (fans_user_id = ‘10086’ and following_user_id = ‘11000’ )</td><td>*</td></tr><tr><td>commit;</td><td>insert 语句开始执行</td></tr><tr><td>*</td><td>update fans<br> set following_each_other = 1 <br> where (fans_user_id = ‘11000’ and following_user_id = ‘10086’ ) <br> or (fans_user_id = ‘10086’ and following_user_id = ‘11000’ )</td></tr><tr><td>*</td><td>commit;</td></tr></tbody></table><blockquote><p>分析：</p><ol><li>由于数据库并没有这条记录，所以<strong>事务T1</strong>在执行insert ignore into 时可以执行成功，并给这行数据加了X锁。</li><li><strong>事务T2</strong>在执行insert ignore into 时由于获取不到行锁，直接阻塞。</li><li>后面都是顺序执行，所以并不会出现死锁的问题。</li></ol></blockquote><p>场景二：数据库已经存在fans_user_id=11000,following_user_id=10086的这条数据。</p><table><thead><tr><th>T1</th><th>T2</th></tr></thead><tbody><tr><td>&gt;begin;</td><td>&gt;begin;</td></tr><tr><td>insert ignore into fans(fans_user_id,following_user_id)<br> values(11000,10086);</td><td>*</td></tr><tr><td>*</td><td>insert ignore into fans(fans_user_id,following_user_id)<br> values(11000,10086); //执行成功</td></tr><tr><td>update fans<br> set following_each_other = 1 <br> where (fans_user_id = ‘11000’ and following_user_id = ‘10086’ ) <br> or (fans_user_id = ‘10086’ and following_user_id = ‘11000’ )</td><td>*</td></tr><tr><td>阻塞等待</td><td>*</td></tr><tr><td>*</td><td>update fans<br> set following_each_other = 1 <br> where (fans_user_id = ‘11000’ and following_user_id = ‘10086’ ) <br> or (fans_user_id = ‘10086’ and following_user_id = ‘11000’ )</td></tr><tr><td>*</td><td>Deadlock found when trying to get lock; <br>try restarting transaction</td></tr></tbody></table><blockquote><p>分析：</p><ol><li>由于数据库已经存在该记录，所以事务T1执行insert ignore into 会插入失败，并给该记录加了个S锁。</li><li>由于S锁是相互兼容的，所以事务T2也给该记录加了S锁。</li><li>T1继续执行update语句，尝试给2行数据加X锁，但是其中有一行数据已经被T2加了S锁，此时T1回到等待队列中继续等待。</li><li>T2继续执行update语句，尝试给2行数据加X锁，但是发现T1已经对这2行数据请求了X锁，且在等待T2释放S锁，而T1又因为T2不释放S锁而无法升级为X锁。</li></ol><p>可以参考mysql官方的例子，原理是一样的。<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-deadlock-example.html" target="_blank" rel="noopener">innodb-死锁例子</a></p></blockquote><p>下面是场景二的DEADLOCK信息（show engine innodb status），你会发现其实跟生产环境的锁是又区别的，线上的死锁信息中T2 持有的是一个X锁（这个不知道怎么解释，无法重现）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">LATEST DETECTED DEADLOCK</span><br><span class="line">------------------------</span><br><span class="line">2019-02-27 14:15:00 0x7000034b5000</span><br><span class="line">*** (1) TRANSACTION:</span><br><span class="line">TRANSACTION 620686, ACTIVE 19 sec starting index read</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">LOCK WAIT 5 lock struct(s), heap size 1136, 4 row lock(s)</span><br><span class="line">MySQL thread id 63, OS thread handle 123145355350016, query id 1172740 localhost 127.0.0.1 root updating</span><br><span class="line">update fans</span><br><span class="line">set following_each_other = 1</span><br><span class="line">where (fans_user_id = &apos;11000&apos; and following_user_id = &apos;10086&apos; ) or (fans_user_id = &apos;10086&apos; and following_user_id = &apos;11000&apos; )</span><br><span class="line">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 107 page no 7 n bits 624 index UK_USER_ID of table `test`.`fans` trx id 620686 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 280 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 5; hex 3131303030; asc 11000;;</span><br><span class="line"> 1: len 5; hex 3130303836; asc 10086;;</span><br><span class="line"> 2: len 8; hex 800000000143abeb; asc      C  ;;</span><br><span class="line"></span><br><span class="line">*** (2) TRANSACTION:</span><br><span class="line">TRANSACTION 620687, ACTIVE 16 sec starting index read</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">3 lock struct(s), heap size 1136, 2 row lock(s)</span><br><span class="line">MySQL thread id 61, OS thread handle 123145357578240, query id 1172741 localhost 127.0.0.1 root updating</span><br><span class="line">update fans</span><br><span class="line">set following_each_other = 1</span><br><span class="line">where (fans_user_id = &apos;11000&apos; and following_user_id = &apos;10086&apos; ) or (fans_user_id = &apos;10086&apos; and following_user_id = &apos;11000&apos; )</span><br><span class="line">*** (2) HOLDS THE LOCK(S):</span><br><span class="line">RECORD LOCKS space id 107 page no 7 n bits 624 index UK_USER_ID of table `test`.`fans` trx id 620687 lock mode S</span><br><span class="line">Record lock, heap no 280 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 5; hex 3131303030; asc 11000;;</span><br><span class="line"> 1: len 5; hex 3130303836; asc 10086;;</span><br><span class="line"> 2: len 8; hex 800000000143abeb; asc      C  ;;</span><br><span class="line"></span><br><span class="line">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 107 page no 7 n bits 624 index UK_USER_ID of table `test`.`fans` trx id 620687 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 279 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 5; hex 3130303836; asc 10086;;</span><br><span class="line"> 1: len 5; hex 3131303030; asc 11000;;</span><br><span class="line"> 2: len 8; hex 800000000143abdb; asc      C  ;;</span><br><span class="line"></span><br><span class="line">*** WE ROLL BACK TRANSACTION (2)</span><br></pre></td></tr></table></figure><h2 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h2><p>在这个案例中，发生死锁的原因主要是insert ignore 在数据已经存在时只是加了S锁。所以解决的办法其实又几个。</p><ol><li>使用其他的幂等处理办法，不要依赖insert ignore。在这个案例中，其实应该直接使用insert，不允许重复执行，可以捕获唯一key异常来获取updateNum进行下个业务处理。</li><li>直接在业务开头使用select for … update 来加排他锁保证业务是串形执行（只是从死锁这个问题考虑，如果考虑性能需要找其他方案）。</li><li>假如就非得使用insert ignore 和 update，那么我们可以考虑在这个业务加个重试，数据库的死锁并不是致命的，设置好数据库的事物超时时间，然后遇到死锁问题，我们可以在业务进行重试解决。</li></ol><h2 id="未分析清楚的点"><a class="markdownIt-Anchor" href="#未分析清楚的点"></a> 未分析清楚的点</h2><ol><li>为什么线上的锁他是一个X锁，并不是一个S锁？是否有场景三？MySQL官方文档有一段话，感觉有点关联，但是无法对应上现象,说的是insert 和 delete 语句其实并不是真正原子的行锁。</li></ol><blockquote><p>InnoDB uses automatic row-level locking. You can get deadlocks even in the case of transactions that just insert or delete a single row. That is because these operations are not really “atomic”; they automatically set locks on the (possibly several) index records of the row inserted or deleted.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;业务逻辑以及死锁现象&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#业务逻辑以及死锁现象&quot;&gt;&lt;/a&gt; 业务逻辑以及死锁现象&lt;/h3&gt;
&lt;p&gt;业务逻辑大概如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在粉丝表新增一条关系记录。&lt;/li&gt;
&lt;li&gt;假如
      
    
    </summary>
    
      <category term="死锁" scheme="http://liaojiacan.me/categories/%E6%AD%BB%E9%94%81/"/>
    
    
      <category term="MySQL" scheme="http://liaojiacan.me/tags/MySQL/"/>
    
      <category term="innodb" scheme="http://liaojiacan.me/tags/innodb/"/>
    
  </entry>
  
  <entry>
    <title>JDK1.7 ConcurrentHashMap的源码解读</title>
    <link href="http://liaojiacan.me/2019/02/26/JDK1-7-ConcurrentHashMap%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>http://liaojiacan.me/2019/02/26/JDK1-7-ConcurrentHashMap的源码解读/</id>
    <published>2019-02-26T03:18:00.000Z</published>
    <updated>2019-02-26T03:20:32.824Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-concurrenthashmap的数据结构jdk7"><a class="markdownIt-Anchor" href="#一-concurrenthashmap的数据结构jdk7"></a> 一、 ConcurrentHashMap的数据结构(JDK7)。</h3><ol><li>segments[] : Segment&lt;K,V&gt; extends ReentrantLock</li></ol><blockquote><p><strong>分段锁</strong>，HashMap 用一个Entry[] table 去存数据，ConcurrentHashMap 则是将 这个table 拆分出 n 个段（一个最接近concurrencyLevel的2的幂）分别存储，Segment 中的 用一个HashEntry table[] 来存数据，table中hash冲突的解决算法基本与HashMap一致。同一个段的put和get操作是需要加锁的，Segment继承了ReentrantLock 故有了锁的功能。</p></blockquote><ol start="2"><li>concurrencyLevel : int</li></ol><blockquote><p><strong>并发等级</strong>，默认是16，可以在构造函数指定该值，这个值直接影响segment数组的大小。如果这个值不是2的幂，则会计算出一个最接近（向上取）的2的幂来初始化segments数组。</p></blockquote><ol start="3"><li>segmentMask : int</li></ol><blockquote><p><strong>掩码</strong>，是一个bit位都是1的数，跟segments的长度有关，比如默认segments的长度是16=2的4次方（二进制为10000）。假如我们需要获取到一个数落在[0,16) 这个区间，则只需要用这个数跟1111做与运算, 得到的结果肯定是落在0到16之间，这个比取模运算更加高效。</p></blockquote><ol start="4"><li>segmentShift : int</li></ol><blockquote><p><strong>位移数</strong>，获取高ssize(segments size)位需要的左移的位数（32-ssize），hash函数算出来的是一个32 位int的整型，ConcurrentHashMap对segments的hash算法采用的是一个取高位进行hash的做法。比如一个key算出来的值为1024，如果我想取高ssize位 ，假如ssize为4，那么就要将1024&gt;&gt;&gt;(32-4)，取得高4位。获取到高4位后会与segmentMask进行与运算获取到一个[0,ssize)的数。这就是ConcurrentHashMap中对segment采用的hash算法。</p></blockquote><ul><li>为什么要采用高位运算？</li></ul><blockquote><p>源码中似乎没有说明，我猜是为了跟segment中的HashEntry[] table 的hash算法区分开来，降低冲突的概率。假如采用同样的hash算法，有2个key Hash到同一个segment中那么再进行 段中的二次hash的时候可能还是命中到同一个节点导致链越来越长。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// segment[] 的hash算法 （hash的高位参与运算）</span><br><span class="line"> int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">// table[] 的hash算法 （hash的低位参与运算）</span><br><span class="line"> int index = (tab.length - 1) &amp; hash;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/liaojiacan/assets/blob/master/issue/ConcurrentHashMap_jdk1.7.png?raw=true" alt="image"></p><h3 id="二-segment中独占锁的加锁逻辑"><a class="markdownIt-Anchor" href="#二-segment中独占锁的加锁逻辑"></a> 二、segment中独占锁的加锁逻辑</h3><blockquote><p>分段锁的目的就是将锁冲突分离开，只有hash到同一个segment中的操作才会存在锁竞争，CurrentHashMap 中put和remove以及size是有加锁操作的。</p></blockquote><p>put操作加锁</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashEntry&lt;K,V&gt; node = tryLock() ? null :scanAndLockForPut(key, hash, value);</span><br></pre></td></tr></table></figure><p>reomve操作加锁</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (!tryLock())</span><br><span class="line">   scanAndLock(key, hash);</span><br></pre></td></tr></table></figure><p>如果 tryLock() 不能能加锁成功则进行自旋，scanAndLockForPut和scanAndLock有点区别但是逻辑差不多。</p><p>1.有限重试次数，多核心CPU的话是64次，单核1次，超过次数则阻塞等待获取锁。</p><p>2.获取锁之前和获取到锁期间头节点不能发生改变，否则需要从头开始重试。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void scanAndLock(Object key, int hash) &#123;</span><br><span class="line">    // similar to but simpler than scanAndLockForPut</span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(this, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    int retries = -1;</span><br><span class="line">    while (!tryLock()) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; f;</span><br><span class="line">        if (retries &lt; 0) &#123;</span><br><span class="line">            if (e == null || key.equals(e.key))</span><br><span class="line">                retries = 0;</span><br><span class="line">            else</span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果头节点发生改变，从头开始扫描</span><br><span class="line">        else if ((retries &amp; 1) == 0 &amp;&amp;</span><br><span class="line">                 (f = entryForHash(this, hash)) != first) &#123;</span><br><span class="line">            e = first = f;</span><br><span class="line">            retries = -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>get没有加排他锁，是否有线程安全问题？</li></ul><p>先说下结论，ConcurrentHashMap get方法不存在线程安全问题，他的线程安全是由CAS 和 &quot;volatile&quot;保证的:</p><pre><code>1. UNSAFE.putOrderedObject/UNSAFE.getObjectVolatile2. volatile HashEntry&lt;K,V&gt; next;3. volatile V value;</code></pre><p>我们整理下，要保证get不发生线程安全问题需要保证什么？</p><pre><code>1. get操作和put或remove操作并行的时候，get能操作能够获取到正确的segment和头节点table[i]。2. 在entries的遍历中能顺利走到未节点。3. 在1和2的前提下get操作时能够保证value值的可见性。</code></pre><p>我们先看第1点时怎么保证的，我们都知道java中有个volatile用了保证变量在多线程下的可见性，volatile可以保证可见性，但是不能保证线程安全，如果当前赋值语句依赖当前值时是线程不安全的，比如a +=1 这种操作就是不安全的，显然在ConcurrentHashMap的并不需要这种操作，只存在简单的引用赋值操作。</p><p>但是需要注意的是一点，volatile修饰引用型变量时，只能保证当前引用的可见性，对于引用对象的内部变量仍然是无法保证可见性的，这就是为什么在对segments[] 数组和table[] 数组的的操作需要借助Unsafe类，而不是直接segments[i] = new Segment(…);</p><p>由前面的分析看，volatile/Unsafe.getObjectVolatile/Unsafe.putOrderedOject保证链当get操作晚与put操作时是可以获取到刚插入的节点(作为一个新头节点连接到旧节点并更新table)，对与一个早于put操作的get操作一个情况就是新插入的元素表头，但是get操作已经获取到了旧表头，所以并不影响get操作进行链表的遍历查找。</p><p>我们在看进行remove时是否会影响entries的遍历，从源码中看，HashEntry中的next成员是被volatile修饰的，这就保证了get可以安全得遍历到未节点。</p><h3 id="三-size的实现逻辑"><a class="markdownIt-Anchor" href="#三-size的实现逻辑"></a> 三、size的实现逻辑</h3><p>  假如ConcurrentHashMap采用HashMap维护一个全局的size来变量统计大小，那么为了线程安全，也必定得改用原子类AtomicLong或者全局加锁。这显然与分段锁的设计背离。那么有没有一种比较折衷的办法呢？</p><p>  ConcurrentHashMap中将size的统计拆分到各个segment取去护，每次执行size的时候将每个segment的count加起来，最终得到的结果就是map的大小。这个看似乎很合理，但是如果在进行统计的过程中有一个segment发生put或者remove操作呢，这样得到的结果就是错误的，显然我们可以在统计前先将每个segment给锁起来，再sum，得到的结果肯定是正确的。</p><p>  <strong>存在一种情况就是你的程序中并发很少，出现并发更新的情况很少，这个时候你执行size的时候将所有的segment加锁和不加锁的情况可能得到的结果是一样的，因为这个时候没有其他线程进行修改。似乎我们可以乐观地考虑一下大部分情况下是不需要进行锁操作的。</strong></p><p>  Doug Lea采用类一种跟JDK集合类中大多数存在的fail-safe错误检查机制，对在每个segment中于更新操作维护一个modCount来记录更新的次数，统计前和统计后的modCount是一样的说明没有发生变化，当前的统计结果有效。ConcurrentHashMap的size方法的实现逻辑如下：</p><ul><li>先采用无锁的方式统计2次，如果前后的modCount总和是一样的，此次统计结果有效，返回结果。</li><li>假如前后的modCount总和不一样，第三次进行有锁的统计。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public int size() &#123;</span><br><span class="line">        // Try a few times to get accurate count. On failure due to</span><br><span class="line">        // continuous async changes in table, resort to locking.</span><br><span class="line">        final Segment&lt;K,V&gt;[] segments = this.segments;</span><br><span class="line">        int size;</span><br><span class="line">        boolean overflow; // true if size overflows 32 bits</span><br><span class="line">        long sum;         // sum of modCounts</span><br><span class="line">        long last = 0L;   // previous sum</span><br><span class="line">        int retries = -1; // first iteration isn&apos;t retry</span><br><span class="line">        try &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                //第三次进行上锁</span><br><span class="line">                if (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                    for (int j = 0; j &lt; segments.length; ++j)</span><br><span class="line">                        ensureSegment(j).lock(); // force creation</span><br><span class="line">                &#125;</span><br><span class="line">                sum = 0L;</span><br><span class="line">                size = 0;</span><br><span class="line">                overflow = false;</span><br><span class="line">                for (int j = 0; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                    Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                    if (seg != null) &#123;</span><br><span class="line">                        sum += seg.modCount;</span><br><span class="line">                        int c = seg.count;</span><br><span class="line">                        if (c &lt; 0 || (size += c) &lt; 0)</span><br><span class="line">                            overflow = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // 前后2次的统计结果一致，可以返回</span><br><span class="line">                if (sum == last)</span><br><span class="line">                    break;</span><br><span class="line">                last = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                for (int j = 0; j &lt; segments.length; ++j)</span><br><span class="line">                    segmentAt(segments, j).unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="四-unsafegetobjectvolatileunsafeputorderedoject对偏移量的计算问题"><a class="markdownIt-Anchor" href="#四-unsafegetobjectvolatileunsafeputorderedoject对偏移量的计算问题"></a> 四、Unsafe.getObjectVolatile/Unsafe.putOrderedOject对偏移量的计算问题</h3><p>  ConcurrentHashMap中使用量Unsafe类来对segment数组和table数组进行数组填充和取值操作，其中对位置i的内存偏移计算用了位运算来代替乘法运算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// segment[0] 的偏移地址</span><br><span class="line">int baseOffset = UNSAFE.arrayBaseOffset(Segment[].class);</span><br><span class="line">// 每个位置的大小</span><br><span class="line">int indexScale = UNSAFE.arrayIndexScale(Segment[].class);</span><br><span class="line">//那么第i个元素的内存偏移就是</span><br><span class="line">long offset = baseOffset+i*indexScale ;</span><br></pre></td></tr></table></figure><p>上面的计算方法是利用乘法来计算的，但是乘法的计算还是比较慢的，如果能用位运算更佳。由于jvm给对象分配内存的时候会进行内存对对齐，也就是说indexScale其实会是一个2的n次方的数。一个整数i乘以一个2的n次方可以转化成 i&lt;&lt;n;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">3 * 2 = 3 &lt;&lt; 1</span><br><span class="line">3 * 4 = 3 &lt;&lt; 2</span><br><span class="line">3 * 8 = 3 &lt;&lt; 3</span><br><span class="line">3 * 16 = 3 &lt;&lt; 4</span><br><span class="line">3 * 32 = 3 &lt;&lt; 5</span><br><span class="line">3 * 64 = 3 &lt;&lt; 6</span><br><span class="line">3 * 128 = 3 &lt;&lt; 7</span><br><span class="line">3 * 256 = 3 &lt;&lt; 8</span><br></pre></td></tr></table></figure><p>所以你会看到ConcurrentHashMap中有这样的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 31 - Integer.numberOfLeadingZeros(ssize) 这个是求一个数x的2对数 </span><br><span class="line"> SSHIFT = 31 - Integer.numberOfLeadingZeros(ssize);</span><br><span class="line"> ...</span><br><span class="line"> // 所以元素i在内存中的偏移就是</span><br><span class="line"> long offset = SBASE +(i&lt;&lt;SSHIFT)</span><br></pre></td></tr></table></figure><p><a href="https://github.com/liaojiacan/code-snippets/blob/master/java-language/src/main/java/com/github/liaojiacan/unsafe/UnsafeArrayOperationTests.java" target="_blank" rel="noopener">测试用例-ConcurrentHashMap中利用Unsafe进行数组操作的测试用例</a>;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-concurrenthashmap的数据结构jdk7&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-concurrenthashmap的数据结构jdk7&quot;&gt;&lt;/a&gt; 一、 ConcurrentHashMap的数据结构(JDK7)
      
    
    </summary>
    
      <category term="源码解读" scheme="http://liaojiacan.me/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="JDK" scheme="http://liaojiacan.me/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/JDK/"/>
    
    
      <category term="J.U.C" scheme="http://liaojiacan.me/tags/J-U-C/"/>
    
      <category term="ConcurrentHashMap" scheme="http://liaojiacan.me/tags/ConcurrentHashMap/"/>
    
  </entry>
  
  <entry>
    <title>谈谈多语言设计（三）Spring-i18n 拓展之自定义MessageSource</title>
    <link href="http://liaojiacan.me/2018/04/13/%E8%B0%88%E8%B0%88%E5%A4%9A%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%89%EF%BC%89Spring-i18n-%E6%8B%93%E5%B1%95%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89MessageSource/"/>
    <id>http://liaojiacan.me/2018/04/13/谈谈多语言设计（三）Spring-i18n-拓展之自定义MessageSource/</id>
    <published>2018-04-13T08:08:00.000Z</published>
    <updated>2018-04-13T08:11:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>  Spring框架中有两个MessageSource的实现，分别是ResourceBundleMessageSource和ReloadableResourceBundleMessageSource，前者第一次初始化就固定下来，后者可以根据配置文件是否发生变进行更新。</p><p>  对于Web网页（UI上的文案），这种配置在配置文件的方式是可以接受的，因为一般这些文案都是固定的。但是对于一些需要动态新增配置的场景显然就是不适合了，比如商品信息，抽奖的奖品，直播间的道具，礼物等，这些都是根据运营人员需要动态调整的，显然需要把配置存储在数据库中。</p><p>  在写这部分的实现的时候，参考了一个开源项目，<a href="https://github.com/synyx/messagesource" target="_blank" rel="noopener">https://github.com/synyx/messagesource</a>。<br>感兴趣的同学，可以在我的Github查看完整的代码。<a href="https://github.com/liaojiacan/spring-i18n-support" target="_blank" rel="noopener">https://github.com/liaojiacan/spring-i18n-support</a></p><h2 id="uml"><a class="markdownIt-Anchor" href="#uml"></a> UML</h2><p><img src="/images/pasted-3.png" alt="upload successful"></p><h2 id="关于messagesourceprovider"><a class="markdownIt-Anchor" href="#关于messagesourceprovider"></a> 关于MessageSourceProvider</h2><p>   在MessageSource的实现中 ，抽出一个Provider层将存储介质解耦，可以在最后的应用中，选择使用JDBC还是Redis还是远程的配置服务中心的实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface MessageSourceProvider &#123;</span><br><span class="line"></span><br><span class="line">List&lt;MessageEntry&gt; load();</span><br><span class="line"></span><br><span class="line">int addMessage(Locale locale,String code,String type,String message);</span><br><span class="line"></span><br><span class="line">int updateMessage(Locale locale,String code,String type,String message);</span><br><span class="line"></span><br><span class="line">int deleteMessage(Locale locale,String code);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="jdbcmessagesoucreprovider"><a class="markdownIt-Anchor" href="#jdbcmessagesoucreprovider"></a> JdbcMessageSoucreProvider</h2><p>   因为只是简单的对数据进行CURD，所以采用JdbcTemple的方式减少相关的依赖，采用java原生的jdbc也是可以的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- ----------------------------</span><br><span class="line">-- Table structure for i18n_message</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP TABLE IF EXISTS `i18n_message`;</span><br><span class="line">CREATE TABLE `i18n_message` (</span><br><span class="line">  `code` varchar(250) NOT NULL COMMENT &apos;mapping code&apos;,</span><br><span class="line">  `locale` varchar(100) NOT NULL COMMENT &apos;language tag&apos;,</span><br><span class="line">  `type` varchar(100) DEFAULT NULL COMMENT &apos;type for group&apos;,</span><br><span class="line">  `message` text NOT NULL COMMENT &apos;message content&apos;,</span><br><span class="line">  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT &apos;create time&apos;,</span><br><span class="line">  `update_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &apos;last modify time&apos;,</span><br><span class="line">  PRIMARY KEY (`code`,`locale`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;i18n message data&apos;;</span><br><span class="line"></span><br><span class="line">SET FOREIGN_KEY_CHECKS = 1;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">public class JdbcMessageSoucreProvider implements MessageSourceProvider &#123;</span><br><span class="line"></span><br><span class="line">private JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">protected static final String QUERY_TPL_INSERT_MESSAGE_ENTRY =</span><br><span class="line">&quot;INSERT INTO %s (%s, %s, %s, %s) VALUES (?, ?, ?, ?)&quot;;</span><br><span class="line">protected static final String QUERY_TPL_DELETE_MESSAGE_ENTRY = &quot;DELETE FROM %s WHERE %s = ? and %s= ?&quot;;</span><br><span class="line">protected static final String QUERY_TPL_SELECT_MESSAGE_ENTRIES = &quot;SELECT %s,%s,%s,%s FROM %s&quot;;</span><br><span class="line">protected static final String QUERY_TPL_UPDATE_MESSAGE_ENTRY = &quot;UPDATE %s set %s=?,%s=?,%s=? WHERE %s=? and %s=?&quot;;</span><br><span class="line"></span><br><span class="line">private String localeColumn = &quot;locale&quot;;</span><br><span class="line">private String typeColumn = &quot;type&quot;;</span><br><span class="line">private String codeColumn = &quot;code&quot;;</span><br><span class="line">private String messageColumn = &quot;message&quot;;</span><br><span class="line">private String tableName = &quot;i18n_message&quot;;</span><br><span class="line">private String delimiter = &quot;`&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public List&lt;MessageEntry&gt; load() &#123;</span><br><span class="line">// @formatter:off</span><br><span class="line">String sql = String.format(getQueryTplSelectMessageEntries(),</span><br><span class="line">addDelimiter(getCodeColumn()),</span><br><span class="line">addDelimiter(getLocaleColumn()),</span><br><span class="line">addDelimiter(getTypeColumn()),</span><br><span class="line">addDelimiter(getMessageColumn()),</span><br><span class="line">addDelimiter(getTableName()));</span><br><span class="line">return jdbcTemplate.query(sql,new BeanPropertyRowMapper(MessageEntry.class));</span><br><span class="line">// @formatter:on</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int addMessage(Locale locale, String code, String type, String message) &#123;</span><br><span class="line">// @formatter:off</span><br><span class="line">String sql = String.format(getQueryTplInsertMessageEntry(),</span><br><span class="line">addDelimiter(getTableName()),</span><br><span class="line">addDelimiter(getLocaleColumn()),</span><br><span class="line">addDelimiter(getCodeColumn()),</span><br><span class="line">addDelimiter(getTypeColumn()),</span><br><span class="line">addDelimiter(getMessageColumn()));</span><br><span class="line">// @formatter:on</span><br><span class="line">return jdbcTemplate.update(sql,locale.toLanguageTag(),code,type,message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int updateMessage(Locale locale, String code, String type, String message) &#123;</span><br><span class="line">// @formatter:off</span><br><span class="line">String sql = String.format(getQueryTplUpdateMessageEntry(),</span><br><span class="line">addDelimiter(getTableName()),</span><br><span class="line">addDelimiter(getLocaleColumn()),</span><br><span class="line">addDelimiter(getTypeColumn()),</span><br><span class="line">addDelimiter(getMessageColumn()),</span><br><span class="line">addDelimiter(getCodeColumn()),addDelimiter(getLocaleColumn()));</span><br><span class="line">// @formatter:on</span><br><span class="line">return jdbcTemplate.update(sql,locale.toLanguageTag(),type,message,code,locale.toLanguageTag());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int deleteMessage(Locale locale, String code) &#123;</span><br><span class="line">String sql = String.format(getQueryTplDeleteMessageEntry(),addDelimiter(getTableName()),addDelimiter(getCodeColumn()),addDelimiter(getLocaleColumn()));</span><br><span class="line">return jdbcTemplate.update(sql,code,locale.toLanguageTag());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Method that &quot;wraps&quot; a field-name (or table-name) into the delimiter.</span><br><span class="line"> * @param name the name of the field/table</span><br><span class="line"> * @return the wrapped field/table</span><br><span class="line"> */</span><br><span class="line">protected String addDelimiter(String name) &#123;</span><br><span class="line">return String.format(&quot;%s%s%s&quot;, delimiter, name, delimiter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public JdbcTemplate getJdbcTemplate() &#123;</span><br><span class="line">return jdbcTemplate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;</span><br><span class="line">this.jdbcTemplate = jdbcTemplate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static String getQueryTplInsertMessageEntry() &#123;</span><br><span class="line">return QUERY_TPL_INSERT_MESSAGE_ENTRY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static String getQueryTplDeleteMessageEntry() &#123;</span><br><span class="line">return QUERY_TPL_DELETE_MESSAGE_ENTRY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static String getQueryTplSelectMessageEntries() &#123;</span><br><span class="line">return QUERY_TPL_SELECT_MESSAGE_ENTRIES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static String getQueryTplUpdateMessageEntry() &#123;</span><br><span class="line">return QUERY_TPL_UPDATE_MESSAGE_ENTRY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getLocaleColumn() &#123;</span><br><span class="line">return localeColumn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setLocaleColumn(String localeColumn) &#123;</span><br><span class="line">this.localeColumn = localeColumn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getTypeColumn() &#123;</span><br><span class="line">return typeColumn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setTypeColumn(String typeColumn) &#123;</span><br><span class="line">this.typeColumn = typeColumn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getCodeColumn() &#123;</span><br><span class="line">return codeColumn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setCodeColumn(String codeColumn) &#123;</span><br><span class="line">this.codeColumn = codeColumn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getMessageColumn() &#123;</span><br><span class="line">return messageColumn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setMessageColumn(String messageColumn) &#123;</span><br><span class="line">this.messageColumn = messageColumn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getTableName() &#123;</span><br><span class="line">return tableName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setTableName(String tableName) &#123;</span><br><span class="line">this.tableName = tableName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getDelimiter() &#123;</span><br><span class="line">return delimiter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setDelimiter(String delimiter) &#123;</span><br><span class="line">this.delimiter = delimiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="refreshablemessagesource"><a class="markdownIt-Anchor" href="#refreshablemessagesource"></a> RefreshableMessageSource</h2><p>  RefreshableMessageSource的实现相对简单，在初始化的时候将MessageSourceProvider的数据解析成MessageFormat存在Map中，解析的时候根据code和locale索引到对应的MessageFormat。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author liaojiacan https://github.com/liaojiacan</span><br><span class="line"> */</span><br><span class="line">public class RefreshableMessageSource extends AbstractMessageSource implements Refreshable,InitializingBean&#123;</span><br><span class="line"></span><br><span class="line">private MessageSourceProvider provider;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Setting : return origin code when the message not found.</span><br><span class="line"> */</span><br><span class="line">protected Boolean returnUnresolvedCode = false;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The MessageFormat cache</span><br><span class="line"> */</span><br><span class="line">private Map&lt;String,Map&lt;Locale,MessageFormat&gt;&gt; messageEntryMap = Collections.emptyMap();</span><br><span class="line"></span><br><span class="line">public RefreshableMessageSource(MessageSourceProvider provider) &#123;</span><br><span class="line">this.provider = provider;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void refresh()&#123;</span><br><span class="line">List&lt;MessageEntry&gt; messageEntries = provider.load();</span><br><span class="line">if(!CollectionUtils.isEmpty(messageEntries))&#123;</span><br><span class="line">final Map&lt;String,Map&lt;Locale,MessageFormat&gt;&gt; finalMap = new HashMap&lt;&gt;();</span><br><span class="line">messageEntries.forEach(messageEntry -&gt; &#123;</span><br><span class="line">String code  = messageEntry.getCode();</span><br><span class="line">Locale locale = Locale.forLanguageTag(messageEntry.getLocale());</span><br><span class="line">Map&lt;Locale, MessageFormat&gt; localeMapping = finalMap.get(code);</span><br><span class="line">if(localeMapping == null)&#123;</span><br><span class="line">localeMapping = new HashMap&lt;&gt;();</span><br><span class="line">finalMap.put(code,localeMapping);</span><br><span class="line">&#125;</span><br><span class="line">localeMapping.put(locale,createMessageFormat(messageEntry.getMessage(),locale));</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">messageEntryMap = finalMap;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected MessageFormat resolveCode(String code, Locale locale) &#123;</span><br><span class="line">Map&lt;Locale, MessageFormat&gt; localeMessageMap = messageEntryMap.get(code);</span><br><span class="line">if(localeMessageMap != null )&#123;</span><br><span class="line">MessageFormat mf = localeMessageMap.get(locale);</span><br><span class="line">if(mf!=null)&#123;</span><br><span class="line">return  mf;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(returnUnresolvedCode)&#123;</span><br><span class="line">return createMessageFormat(code,locale);</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">this.refresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public MessageSourceProvider getProvider() &#123;</span><br><span class="line">return provider;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setProvider(MessageSourceProvider provider) &#123;</span><br><span class="line">this.provider = provider;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Boolean getReturnUnresolvedCode() &#123;</span><br><span class="line">return returnUnresolvedCode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setReturnUnresolvedCode(Boolean returnUnresolvedCode) &#123;</span><br><span class="line">this.returnUnresolvedCode = returnUnresolvedCode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  Spring框架中有两个MessageSource的实现，分别是ResourceBundleMessageSource和ReloadableResourceBundleMessageSource，前者第一次初始化就固定下来，后者可以根据配置文件是否发生变进行更新。&lt;/p
      
    
    </summary>
    
      <category term="架构总结" scheme="http://liaojiacan.me/categories/%E6%9E%B6%E6%9E%84%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="多语言" scheme="http://liaojiacan.me/tags/%E5%A4%9A%E8%AF%AD%E8%A8%80/"/>
    
      <category term="i18n" scheme="http://liaojiacan.me/tags/i18n/"/>
    
  </entry>
  
  <entry>
    <title>Idea使用骨架生成项目卡住的解决办法</title>
    <link href="http://liaojiacan.me/2018/03/09/Idea%E4%BD%BF%E7%94%A8%E9%AA%A8%E6%9E%B6%E7%94%9F%E6%88%90%E9%A1%B9%E7%9B%AE%E5%8D%A1%E4%BD%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://liaojiacan.me/2018/03/09/Idea使用骨架生成项目卡住的解决办法/</id>
    <published>2018-03-09T11:01:00.000Z</published>
    <updated>2018-03-09T11:04:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>  Idea在使用骨架生成项目时（Create from archetype）有时候会发现卡住了，控制台停留在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Generating project in Batch mode</span><br></pre></td></tr></table></figure><p>通过debug日志发现是搜索archetype-catalog.xml卡住了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Generating project in Batch mode</span><br><span class="line">[DEBUG] Searching for remote catalog: http://repo.maven.apache.org/maven2/archetype-catalog.xml</span><br></pre></td></tr></table></figure><p>解决方法：</p><p>   修改archetypeCatalog参数，archetypeCatalog=internal。Idea可以在maven的runner配置中指定。如图：</p><p><img src="/images/pasted-2.png" alt="upload successful"></p><p>archetypeCatalog参数取值可以从maven的文档查到.<a href="http://maven.apache.org/archetype/maven-archetype-plugin/examples/generate-alternative-catalog.html" target="_blank" rel="noopener">Generate project using an alternative catalog<br></a></p><p>archetypeCatalog 可配置的值有</p><ul><li>internal to use the internal catalog only.</li><li>local to use the local catalog only.</li><li>remote to use the maven’s remote catalog.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">No catalog is currently provided.</span><br><span class="line">The default value is remote,local. Thus the local catalog is shown just after the remote one.</span><br></pre></td></tr></table></figure><p>默认是remote,local. 这里解决方法其实有两个，<br>一个就是上面所说修改archetypeCatalog=internal,直接使用网络。另外一个就是修改远程仓库，如使用阿里的镜像。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  Idea在使用骨架生成项目时（Create from archetype）有时候会发现卡住了，控制台停留在&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span clas
      
    
    </summary>
    
      <category term="工具使用" scheme="http://liaojiacan.me/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="Idea" scheme="http://liaojiacan.me/tags/Idea/"/>
    
      <category term="archetypeCatalog" scheme="http://liaojiacan.me/tags/archetypeCatalog/"/>
    
  </entry>
  
  <entry>
    <title>谈谈多语言设计（二）之Spring多语言</title>
    <link href="http://liaojiacan.me/2018/03/08/%E8%B0%88%E8%B0%88%E5%A4%9A%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B9%8BSpring%E5%A4%9A%E8%AF%AD%E8%A8%80/"/>
    <id>http://liaojiacan.me/2018/03/08/谈谈多语言设计（二）之Spring多语言/</id>
    <published>2018-03-08T11:07:00.000Z</published>
    <updated>2018-03-08T11:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>  现在大部分成熟的web框架默认就支持多语言，如果业务比较简单，使用框架自身的多语言支持就可以了。本文将以SpringMvc为例介绍一下JavaWeb的多语言中的一些关键类。</p><h2 id="关键字"><a class="markdownIt-Anchor" href="#关键字"></a> 关键字</h2><ul><li>i18n</li><li>Locale</li><li>LocaleContext</li><li>MessageSource</li></ul><h2 id="i18n"><a class="markdownIt-Anchor" href="#i18n"></a> I18N</h2><p>   i18n(其来源是英文单词 internationalization的首末字符i和n，18为中间的字符数),除了i18n还有L10n、g11n、m17n。</p><h2 id="locale"><a class="markdownIt-Anchor" href="#locale"></a> Locale</h2><p>  Locale是区域信息，通常locale信息包含应该语言信息和区域标识符，如zh_CN:zh为中文,CN为中国的国家代码。常见的Locale代码可以上网获取。<a href="https://www.science.co.il/language/Locale-codes.php" target="_blank" rel="noopener"> Locale Codes</a>。java中的Locale.java 也定义了常见的区域信息。我们应该尽量使用Locale类型来表达地域信息变量，不应该使用String类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">static public final Locale ENGLISH = createConstant(&quot;en&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">   /** Useful constant for language.</span><br><span class="line">    */</span><br><span class="line">   static public final Locale FRENCH = createConstant(&quot;fr&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">   /** Useful constant for language.</span><br><span class="line">    */</span><br><span class="line">   static public final Locale GERMAN = createConstant(&quot;de&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">   /** Useful constant for language.</span><br><span class="line">    */</span><br><span class="line">   static public final Locale ITALIAN = createConstant(&quot;it&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">   /** Useful constant for language.</span><br><span class="line">    */</span><br><span class="line">   static public final Locale JAPANESE = createConstant(&quot;ja&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">   /** Useful constant for language.</span><br><span class="line">    */</span><br><span class="line">   static public final Locale KOREAN = createConstant(&quot;ko&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">   /** Useful constant for language.</span><br><span class="line">    */</span><br><span class="line">   static public final Locale CHINESE = createConstant(&quot;zh&quot;, &quot;&quot;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> //从Locale的构造方法中，也看出Locale中可包含语言（language）,国家(country),变体（variant）</span><br><span class="line"> public Locale(String language, String country, String variant) &#123;</span><br><span class="line">        if (language== null || country == null || variant == null) &#123;</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        baseLocale = BaseLocale.getInstance(convertOldISOCodes(language), &quot;&quot;, country, variant);</span><br><span class="line">        localeExtensions = getCompatibilityExtensions(language, &quot;&quot;, country, variant);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="localecontext"><a class="markdownIt-Anchor" href="#localecontext"></a> LocaleContext</h2><p>   Spring中存储用户地域信息的上下文，LocaleContext中采用的是ThreadLocal变量来存储信息，线程隔离，这样就可以让locale参数从各层的方法参数中移除。我们在写业务代码时也尽量不要将Locale参数通过方法参数中传入，利用LocaleContext可以让代码显得更优雅点。此外Spring也提供一些LocaleChangeInterceptor 的实现，并不需要我们自己维护这些信息。</p><ul><li>AcceptHeaderLocaleResolver  通过Accept-Language加载locale信息</li><li>CookieLocaleResolver 通过Cookie加载locale信息</li><li>FixedLocaleResolver  全局静态的，返回一个默认的Locale</li><li>SessionLocaleResolver 通过SessionLocaleResolver加载locale信息</li></ul><h2 id="messagesource"><a class="markdownIt-Anchor" href="#messagesource"></a> MessageSource</h2><p>   对于多语言的翻译，无非就是先定义一些key，然后根据给这些key配置各种locale对应的文本。而Spring中的MessageSource就是维护这些配置信息的组件，Spring中有ResourceBundleMessageSource 和 ReloadableResourceBundleMessageSource的实现，可以将多语言的配置在<span class="katex-error" title="ParseError: KaTeX parse error: Expected group after &#039;_&#039; at position 11: {basename}_̲">{basename}_</span>{locale}.properties文件中。ResourceBundleMessageSource 每次修改配置需要重启服务才能生效，而ReloadableResourceBundleMessageSource可以热更新。</p><p>   当然我们也可以自己实现一个MessageSource从DB或者从其他存储源加载配置，后面我将单独写一篇文章介绍如何自定义MessageSource进行拓展的。</p><h2 id="多语言的处理流程"><a class="markdownIt-Anchor" href="#多语言的处理流程"></a> 多语言的处理流程</h2><p><img src="/images/pasted-1.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  现在大部分成熟的web框架默认就支持多语言，如果业务比较简单，使用框架自身的多语言支持就可以了。本文将以SpringMvc为例介绍一下JavaWeb的多语言中的一些关键类。&lt;/p&gt;
&lt;h2 id=&quot;关键字&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; hr
      
    
    </summary>
    
      <category term="架构总结" scheme="http://liaojiacan.me/categories/%E6%9E%B6%E6%9E%84%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="多语言" scheme="http://liaojiacan.me/tags/%E5%A4%9A%E8%AF%AD%E8%A8%80/"/>
    
      <category term="i18n" scheme="http://liaojiacan.me/tags/i18n/"/>
    
  </entry>
  
  <entry>
    <title>谈谈多语言设计（一）之客户端多语言与服务端多语言</title>
    <link href="http://liaojiacan.me/2018/03/07/%E8%B0%88%E8%B0%88%E5%A4%9A%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8B-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%9A%E8%AF%AD%E8%A8%80%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A4%9A%E8%AF%AD%E8%A8%80/"/>
    <id>http://liaojiacan.me/2018/03/07/谈谈多语言设计（一）之-客户端多语言与服务端多语言/</id>
    <published>2018-03-07T03:56:00.000Z</published>
    <updated>2018-03-08T11:10:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>  2017年的一个风口就是移动互联网的出海，很多公司都战略性地在海外做起了互联网商业化，最近也是接触了一些国际的项目，用户散落在各个国家地区，刚开始大部分是由客户端进行多语言的适配，后来由于产品觉得灵活性太差，于是把部分功能移到服务端来实现，但是发现无论是客户端实现还是服务端实现都存在一些弊端。</p><h2 id="我们先思考一下以下几个问题"><a class="markdownIt-Anchor" href="#我们先思考一下以下几个问题"></a> 我们先思考一下以下几个问题：</h2><ol><li>完全由服务端实现多语言有什么弊端?</li></ol><blockquote><p>对于大部分应用场景，多语言都可以在服务端实现，但有一种情况不适合使用服务端多语言。比如目标用户语言非唯一，IM群发，推送等业务场景，虽然大部分消息推送服务可以按用户属性或者标签进行推送，服务端可以分开推送来实现，但是对于用户群推地域很分散的应用显然不是很合适。</p></blockquote><ol start="2"><li>完全由客户端实现多语言由什么弊端？</li></ol><blockquote><p>大部分情况下都是采用的客户端写多语言配置进行适配，不管是android 还是iOS 还是常见的前端框架都是支持i18n的配置。这种方式有个缺点就是灵活性比较差，修改文案必须发包。</p></blockquote><ol start="3"><li>对于移动应用多语言是该客户端做还是服务端做，如何找到一个平衡点？</li></ol><blockquote><p>无论是客户端多语言还是服务端多语言都有各自的优劣，主要还是看应用场景。<br>个人认为对于移动应用的多语言，应该把两者结合起来使用。对于UI等相对固定的部分采用客户端多语言。对于变动比较大的部分，采用服务端进行多语言的处理，比如名称，描述这些可能会根据运营场景进行调整的信息。</p></blockquote><ol start="4"><li>为什么不采用服务端生成配置客户端加载配置的方式？</li></ol><blockquote><p>这种方式是一种比较灵活的方式，但是对于协议的定义不是很友好（key必须唯一，势必导致接口的返回体变大），而且无论是客户端还是服务端解析也比较耗资源，接口可读性比较差。而且把业务跟多语言的耦合太重，无论是客户端和服务端在编码的时候应该把多语言与业务解构，即便没有多语言部分也不影响业务的执行。</p></blockquote><ol start="5"><li><p>如果将客户端多语言和服务端多语言结合使用，怎么规范比较适合？</p><blockquote><p>简单来说，就是以下几点:</p></blockquote><ul><li>UI部分由客户端实现多语言</li><li>所有客户端主动向服务端拉取的由服务端实现</li><li>对于群发等应用场景，由服务端生成语言包，客户端在一定时机拉取并加载到应用中。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  2017年的一个风口就是移动互联网的出海，很多公司都战略性地在海外做起了互联网商业化，最近也是接触了一些国际的项目，用户散落在各个国家地区，刚开始大部分是由客户端进行多语言的适配，后来由于产品觉得灵活性太差，于是把部分功能移到服务端来实现，但是发现无论是客户端实现还是服
      
    
    </summary>
    
      <category term="架构总结" scheme="http://liaojiacan.me/categories/%E6%9E%B6%E6%9E%84%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="多语言" scheme="http://liaojiacan.me/tags/%E5%A4%9A%E8%AF%AD%E8%A8%80/"/>
    
      <category term="i18n" scheme="http://liaojiacan.me/tags/i18n/"/>
    
  </entry>
  
  <entry>
    <title>Source Tree 配置支持gerrit review</title>
    <link href="http://liaojiacan.me/2018/02/07/Source-Tree-%E9%85%8D%E7%BD%AE%E6%94%AF%E6%8C%81gerrit-review/"/>
    <id>http://liaojiacan.me/2018/02/07/Source-Tree-配置支持gerrit-review/</id>
    <published>2018-02-07T07:34:45.000Z</published>
    <updated>2018-02-08T06:58:59.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>source tree 可以支持自定义菜单，我们自定义一个菜单，来实现gerrit push review操作</p></blockquote><p>1.先创建一个脚本，这里我叫 git_push_gerrit.sh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># Push for gerrit review</span><br><span class="line"># Created by Liaojiacan on 6.2.2017.</span><br><span class="line"># Copyright (c) 2018 liaojiacan. All rights reserved.</span><br><span class="line">branch=$(git symbolic-ref --short -q HEAD)</span><br><span class="line">git push origin HEAD:refs/for/$branch</span><br></pre></td></tr></table></figure><p>2.在SourceTree创建一个自定义操作</p><p><img src="/images/pasted-0.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;source tree 可以支持自定义菜单，我们自定义一个菜单，来实现gerrit push review操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.先创建一个脚本，这里我叫 git_push_gerrit.sh&lt;/p&gt;
&lt;figure c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>抽奖业务设计</title>
    <link href="http://liaojiacan.me/2017/12/16/%E6%8A%BD%E5%A5%96%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/"/>
    <id>http://liaojiacan.me/2017/12/16/抽奖业务设计/</id>
    <published>2017-12-16T08:12:00.000Z</published>
    <updated>2018-02-08T06:58:59.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>抽奖是一个比较常见的业务，关于抽奖的算法也有很多种实现，下面介绍一种比较容易实现的方式。</p></blockquote><p>1.根据中奖概率的精确度，取一个权重的基线作为（概率-&gt;概率区间）的放大因子。比如，概率的精确度是到万分位，则基线取10000，保证转换后的区间&gt;=1</p><p>2.将奖品按对应的中奖概率*基线 转换成权重区间，并记录权重的上限值。</p><p>3.在权重上限值的范围内产生一个随机数，利用迭代查找或者二分查找算法找到对应的权重区间，即可获取到对应的奖品。</p><p>假设奖品的配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;一等奖&quot;:0.01</span><br><span class="line">&quot;二等奖&quot;:0.1</span><br><span class="line">&quot;三等奖&quot;:0.15</span><br><span class="line">&quot;四等奖&quot;:0.2</span><br><span class="line">&quot;五等奖&quot;:0.25</span><br><span class="line">&quot;六等奖&quot;:0.29</span><br></pre></td></tr></table></figure><p>概率转换到权重区间（放大10000倍）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一等奖:[0.000000,100.000000)</span><br><span class="line">二等奖:[100.000000,1100.000000)</span><br><span class="line">三等奖:[1100.000000,2600.000000)</span><br><span class="line">四等奖:[2600.000000,4100.000000)</span><br><span class="line">五等奖:[4100.000000,6100.000000)</span><br><span class="line">六等奖:[6100.000000,8600.000000)</span><br></pre></td></tr></table></figure><p>算法实现：<a href="https://github.com/liaojiacan/code-snippets/tree/master/function-design/src/main/java/com/github/liaojiacan/lottery" target="_blank" rel="noopener">Github</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class LotteryPrize &#123;</span><br><span class="line">private String id;</span><br><span class="line">private String name;</span><br><span class="line">private double possibility;</span><br><span class="line"></span><br><span class="line">public LotteryPrize() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public LotteryPrize(String id, String name, double possibility) &#123;</span><br><span class="line">this.id = id;</span><br><span class="line">this.name = name;</span><br><span class="line">this.possibility = possibility;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getId() &#123;</span><br><span class="line">return id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setId(String id) &#123;</span><br><span class="line">this.id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public double getPossibility() &#123;</span><br><span class="line">return possibility;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setPossibility(double possibility) &#123;</span><br><span class="line">this.possibility = possibility;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class LotteryMachine &#123;</span><br><span class="line"></span><br><span class="line">private PossibilityArea[] table;</span><br><span class="line">private int bound = 1;</span><br><span class="line">private Random random = new Random();</span><br><span class="line"></span><br><span class="line">private static final int BASE_WEIGHT = 10000;</span><br><span class="line"></span><br><span class="line">class PossibilityArea&#123;</span><br><span class="line">private LotteryPrize prize;</span><br><span class="line">private double start;</span><br><span class="line">private double end;</span><br><span class="line">public PossibilityArea(LotteryPrize prize, double start, double end) &#123;</span><br><span class="line">this.prize = prize;</span><br><span class="line">this.start = start;</span><br><span class="line">this.end = end;</span><br><span class="line">System.out.printf(&quot;%s:[%f,%f)\n&quot;,prize.getName(),start,end);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LotteryMachine(List&lt;LotteryPrize&gt; prizes) &#123;</span><br><span class="line">table = new PossibilityArea[prizes.size()];</span><br><span class="line">double start = 0;</span><br><span class="line">for(int i=0;i&lt;prizes.size();i++)&#123;</span><br><span class="line">LotteryPrize prize = prizes.get(i);</span><br><span class="line">double weight = prize.getPossibility() * BASE_WEIGHT;</span><br><span class="line">Double end = start + weight;</span><br><span class="line">PossibilityArea area = new PossibilityArea(prize,start,end);</span><br><span class="line">table[i]= area;</span><br><span class="line">bound = end.intValue();</span><br><span class="line">start=end;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private LotteryPrize binarySearch(int rnd)&#123;</span><br><span class="line">int low = 0;</span><br><span class="line">int hight = table.length;</span><br><span class="line">while (low&lt;hight)&#123;</span><br><span class="line">int mid = (low + hight) / 2;</span><br><span class="line">PossibilityArea area = table[mid];</span><br><span class="line">if(area.start&lt;=rnd &amp;&amp; area.end&gt;rnd)&#123;</span><br><span class="line">return  area.prize;</span><br><span class="line">&#125;</span><br><span class="line">if(area.end&lt;=rnd)&#123;</span><br><span class="line">low=mid+1;</span><br><span class="line">&#125;</span><br><span class="line">if(area.start&gt;rnd)&#123;</span><br><span class="line">hight=mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LotteryPrize go()&#123;</span><br><span class="line">int rnd = random.nextInt(bound);</span><br><span class="line">return binarySearch(rnd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;抽奖是一个比较常见的业务，关于抽奖的算法也有很多种实现，下面介绍一种比较容易实现的方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.根据中奖概率的精确度，取一个权重的基线作为（概率-&amp;gt;概率区间）的放大因子。比如，概率的精确度是到万分位，则
      
    
    </summary>
    
      <category term="java" scheme="http://liaojiacan.me/categories/java/"/>
    
    
      <category term="业务开发" scheme="http://liaojiacan.me/tags/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java根据指定的country和lang格式化时间</title>
    <link href="http://liaojiacan.me/2017/10/16/Java%E6%A0%B9%E6%8D%AE%E6%8C%87%E5%AE%9A%E7%9A%84country%E5%92%8Clang%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%B6%E9%97%B4/"/>
    <id>http://liaojiacan.me/2017/10/16/Java根据指定的country和lang格式化时间/</id>
    <published>2017-10-16T13:18:00.000Z</published>
    <updated>2018-02-08T06:58:59.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>服务端或者客户端在做一些多语言的时候可能会涉及到时间戳的格式化，不同的语言或者不同的国家的时间的表达格式可能不同。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public  String formatDate(Date date,String lang,String country)&#123;</span><br><span class="line">    Locale locale = new Locale(lang,country,&quot;&quot;);</span><br><span class="line">    DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.DEFAULT,DateFormat.MEDIUM,locale);</span><br><span class="line">    return dateFormat.format(date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;服务端或者客户端在做一些多语言的时候可能会涉及到时间戳的格式化，不同的语言或者不同的国家的时间的表达格式可能不同。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
    
      <category term="java" scheme="http://liaojiacan.me/tags/java/"/>
    
      <category term="业务开发" scheme="http://liaojiacan.me/tags/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Iedis破解思路</title>
    <link href="http://liaojiacan.me/2017/10/12/Iedis%E7%A0%B4%E8%A7%A3%E6%80%9D%E8%B7%AF/"/>
    <id>http://liaojiacan.me/2017/10/12/Iedis破解思路/</id>
    <published>2017-10-12T07:01:00.000Z</published>
    <updated>2018-02-08T06:58:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Iedis是IDEA上的一个收费redis插件，java编写的，既然是java写的，收费这些自然是很容易绕过的。由于Java太容易被反编译，作者还是做了些代码混淆和字符串加密。</p></blockquote><h3 id="利用jd-gui反编译出来的代码片段"><a class="markdownIt-Anchor" href="#利用jd-gui反编译出来的代码片段"></a> 利用JD-GUI反编译出来的代码片段</h3><p>可以看出类名和字符串都被混淆和加密了，从代码上很难去定位和分析他的注册流程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package com.seventh7.widget.iedis.config;</span><br><span class="line"></span><br><span class="line">import com.intellij.icons.AllIcons.General;</span><br><span class="line">import com.intellij.openapi.actionSystem.AnActionEvent;</span><br><span class="line">import com.intellij.openapi.ui.Messages;</span><br><span class="line"></span><br><span class="line">class i</span><br><span class="line">  extends e</span><br><span class="line">&#123;</span><br><span class="line">  private static final String[] ib;</span><br><span class="line">  private static final String[] jb;</span><br><span class="line">  </span><br><span class="line">  i(n paramn)</span><br><span class="line">  &#123;</span><br><span class="line">    super(a(20539, 52876), a(20539, 52876), AllIcons.General.Remove, a(20537, 55341), paramn);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  void a(AnActionEvent paramAnActionEvent, P paramP)</span><br><span class="line">  &#123;</span><br><span class="line">    String str1 = String.format(a(20538, 25199), new Object[] &#123; paramP.f() &#125;);</span><br><span class="line">    String str2 = a(20536, 20012);</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      if (Messages.showOkCancelDialog(a(), str1, str2, Messages.getQuestionIcon()) == 0) &#123;</span><br><span class="line">        com.seventh7.widget.iedis.d.e.a().a(a(), paramP.b());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (RuntimeException localRuntimeException)</span><br><span class="line">    &#123;</span><br><span class="line">      throw d(localRuntimeException);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="破解的2个思路"><a class="markdownIt-Anchor" href="#破解的2个思路"></a> 破解的2个思路</h3><ul><li>还原代码中的所有加密字符串，根据字符串的内定位到相关的代码，利用javassist修改class文件，将文件替换掉原来的文件</li><li>逆向出他的认证算法，然后做个注册机之类的。iedis是采用服务器认证的，每次启动都要去服务器查询激活，所以注册机不适合。但是我们可以本地架设一个认证服务。</li></ul><blockquote><p>架设认证服务器还是比较简单的，下面还是主要研究一下第一种思路。</p></blockquote><h3 id="还原字符串"><a class="markdownIt-Anchor" href="#还原字符串"></a> 还原字符串</h3><p>从那些混淆的代码去定位软件的运行逻辑很难下手，但是我们可以换个思路，将软件运行过程中字符串都打印出来，这样我们基本上就可以得到一份软件的运行日志，对java程序进行运行时插入语句看似很麻烦，其实JVM默认就支持javaagent，写个javaagent即可达到效果，javaagent的使用可以参考<a href="http://liaojiacan.me/2017/10/10/javaagent-%E7%9A%84%E4%BD%BF%E7%94%A8/">《javaagent-的使用》</a></p><ol><li>编写javaagent程序</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 给iedis的加密字符串函数 插入打印代码</span><br><span class="line"> */</span><br><span class="line">public class IedisTransformer implements ClassFileTransformer &#123;</span><br><span class="line"></span><br><span class="line">private final static String IDEA_LIB=&quot;/Applications/IntelliJ IDEA.app/Contents/lib/*&quot;;</span><br><span class="line">private final static String IDEIS_LIB=&quot;/Users/liaojiacan/Library/Application Support/IntelliJIdea2017.2/Iedis/lib/*&quot;;</span><br><span class="line"></span><br><span class="line">public IedisTransformer() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">ClassPool.getDefault().appendClassPath(IDEA_LIB);</span><br><span class="line">ClassPool.getDefault().appendClassPath(IDEIS_LIB);</span><br><span class="line">&#125; catch (NotFoundException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException &#123;</span><br><span class="line"></span><br><span class="line">if(className.startsWith(&quot;com/seventh7/widget/iedis&quot;))&#123;</span><br><span class="line">try &#123;</span><br><span class="line">CtClass clazz = ClassPool.getDefault().makeClass(new ByteArrayInputStream(classfileBuffer));</span><br><span class="line">CtMethod[] methods = clazz.getDeclaredMethods();</span><br><span class="line">CtClass string = ClassPool.getDefault().getCtClass(String.class.getName());</span><br><span class="line">for(CtMethod method :methods)&#123;</span><br><span class="line"></span><br><span class="line">if(method.getLongName().startsWith(&quot;com.seventh7.widget.iedis.a.p.f&quot;))&#123;</span><br><span class="line">System.out.println(&quot;Inject :: SUCCESS!&quot;);</span><br><span class="line">method.insertBefore(&quot;if(true)&#123;return true;&#125; &quot;);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(method.getReturnType().equals(string))&#123;</span><br><span class="line">String name = method.getLongName();</span><br><span class="line">System.out.println(&quot;transform the iedis method:&quot;+name);</span><br><span class="line">method.insertAfter(&quot;System.out.println(\&quot;--------------------\&quot;);&quot; +</span><br><span class="line">&quot; System.out.println(\&quot;&quot;+name+&quot;\&quot;); &quot; +</span><br><span class="line">&quot; System.out.println(java.util.Arrays.toString($args)); &quot; +</span><br><span class="line">&quot; System.out.println(\&quot;return:\&quot;+$_);&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return clazz.toBytecode();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (NotFoundException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (CannotCompileException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>修改System.out，把所有的print打印到我们指定的文件中 /tmp/system.out</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">public static void premain(String agentOps, Instrumentation inst) &#123;</span><br><span class="line">PrintStream out = null;</span><br><span class="line">try &#123;</span><br><span class="line">out = new PrintStream(&quot;/tmp/system.out&quot;);</span><br><span class="line">&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.setOut(out);</span><br><span class="line">System.setErr(out);</span><br><span class="line"></span><br><span class="line">if (&quot;iedis&quot;.equals(agentOps))&#123;</span><br><span class="line">inst.addTransformer(new IedisTransformer());</span><br><span class="line">&#125;else if(&quot;injectPrint&quot;.equals(agentOps)) &#123;</span><br><span class="line">inst.addTransformer(new InjectPrintTransformer());</span><br><span class="line">&#125;else &#123;</span><br><span class="line">inst.addTransformer(new SimpleTransformer());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(helloWorld());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static String helloWorld()&#123;</span><br><span class="line">return &quot;This is a javaagent!&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>配置idea启动配置，加入我们的javaagent</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#修改idea.vmoptions文件加入下面一行配置</span><br><span class="line">-javaagent:/Users/liaojiacan/Workspace/tools/decomplie/javaagent/javaagent-1.0-SNAPSHOT.jar=iedis</span><br><span class="line">-Xms128m</span><br><span class="line">-Xmx750m</span><br><span class="line">-XX:ReservedCodeCacheSize=240m</span><br><span class="line">-XX:+UseCompressedOops</span><br><span class="line">-Dfile.encoding=UTF-8</span><br><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-XX:SoftRefLRUPolicyMSPerMB=50</span><br><span class="line">-ea</span><br><span class="line">-Dsun.io.useCanonCaches=false</span><br><span class="line">-Djava.net.preferIPv4Stack=true</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:-OmitStackTraceInFastThrow</span><br><span class="line">-Xverify:none</span><br><span class="line"></span><br><span class="line">-XX:ErrorFile=$USER_HOME/java_error_in_idea_%p.log</span><br><span class="line">-XX:HeapDumpPath=$USER_HOME/java_error_in_idea.hprof</span><br><span class="line">-Xbootclasspath/a:../lib/boot.jar</span><br></pre></td></tr></table></figure><p>启动Idea 后我们可以在/tmp/system.out中可以看到这些关键的日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">--------------------</span><br><span class="line">com.seventh7.widget.iedis.L.a(java.lang.String)</span><br><span class="line">return:&#123;&quot;trailing&quot;:true,&quot;daysLeft&quot;:9,&quot;popup&quot;:true,&quot;activated&quot;:false&#125;</span><br><span class="line">--------------------</span><br><span class="line">com.seventh7.widget.iedis.B.a()</span><br><span class="line">return:186b474e0ffffffb70ffffff96680ffffffc0240ffffff89456b0fffffffa320ffffffa70ffffff92</span><br><span class="line">--------------------</span><br><span class="line">com.seventh7.widget.iedis.x.a(byte[])</span><br><span class="line">return:MTg2YjQ3NGUwZmZmZmZmYjcwZmZmZmZmOTY2ODBmZmZmZmZjMDI0MGZmZmZmZjg5NDU2YjBmZmZm</span><br><span class="line">ZmZmYTMyMGZmZmZmZmE3MGZmZmZmZjkyOjI=</span><br><span class="line">--------------------</span><br><span class="line">com.seventh7.widget.iedis.L.a(java.lang.String)</span><br><span class="line">return:&#123;&quot;trailing&quot;:true,&quot;daysLeft&quot;:9,&quot;popup&quot;:true,&quot;activated&quot;:false&#125;</span><br><span class="line">--------------------</span><br><span class="line"></span><br><span class="line">com.seventh7.widget.iedis.L.a(java.lang.String)</span><br><span class="line">[https://www.codesmagic.com/q2?t=MTg2YjQ3NGUwZmZmZmZmYjcwZmZmZmZmOTY2ODBmZmZmZmZjMDI0MGZmZmZmZjg5NDU2YjBmZmZmZmZmYTMyMGZmZmZmZmE3MGZmZmZmZjkyOjI=]</span><br><span class="line">return:&#123;&quot;trailing&quot;:true,&quot;daysLeft&quot;:9,&quot;popup&quot;:true,&quot;activated&quot;:false&#125;</span><br><span class="line">--------------------</span><br><span class="line">com.seventh7.widget.iedis.a.p.b(int,int)</span><br><span class="line">[-13938, -6118]</span><br><span class="line">return:trailing</span><br><span class="line">--------------------</span><br><span class="line">com.seventh7.widget.iedis.a.p.b(int,int)</span><br><span class="line">[-13937, -25088]</span><br><span class="line">return:daysLeft</span><br><span class="line">--------------------</span><br><span class="line">com.seventh7.widget.iedis.a.p.b(int,int)</span><br><span class="line">[-13939, 7216]</span><br><span class="line">return:popup</span><br></pre></td></tr></table></figure><p>从上面的日志可以看出一些关键点：</p><ul><li><p><a href="https://www.codesmagic.com/q2?t=" target="_blank" rel="noopener">https://www.codesmagic.com/q2?t=</a> 是注册的服务器</p></li><li><p>com.seventh7.widget.iedis.a.o 这个类是很关键的类</p></li><li><p>认证服务器返回的认证结果为<br>{“trailing”:true,“daysLeft”:9,“popup”:true,“activated”:false}</p></li></ul><blockquote><p>查看反编译的代码，可以看出这个类是一个抽象类，他的唯一子类是com.seventh7.widget.iedis.a.p，根据外面获取到的运行日志，大概可以推断出 f这个方法是认证的方法。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">package com.seventh7.widget.iedis.a;</span><br><span class="line"></span><br><span class="line">import com.seventh7.widget.iedis.b.d.a;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import com.seventh7.widget.iedis.L;</span><br><span class="line"></span><br><span class="line">class p extends o</span><br><span class="line">&#123;</span><br><span class="line">    private static final String[] kb;</span><br><span class="line">    private static final String[] lb;</span><br><span class="line">    </span><br><span class="line">    //基本上可以推断出 这个就是认证的方法，最直接的方法就是直接return true</span><br><span class="line">    @Override</span><br><span class="line">    protected boolean f() throws IOException &#123;</span><br><span class="line">        //this.d() 是调用https://www.codesmagic.com/q2去注册的</span><br><span class="line">        //Map的返回值&#123;&quot;trailing&quot;:true,&quot;daysLeft&quot;:9,&quot;popup&quot;:true,&quot;activated&quot;:false&#125;</span><br><span class="line">        final Map d = this.d();</span><br><span class="line">        //trailing</span><br><span class="line">        final boolean booleanValue = L.a(d, b(-13938, -6118));</span><br><span class="line">        //this.d()执行后的异常信息。</span><br><span class="line">        final a[] b = av.b();</span><br><span class="line">        //daysLeft</span><br><span class="line">        final int b2 = L.b(d, b(-13937, -25088));</span><br><span class="line">        //popup</span><br><span class="line">        final boolean booleanValue2 = L.a(d, b(-13939, 7216));</span><br><span class="line">        boolean booleanValue3 = false;</span><br><span class="line">        Label_0104: &#123;</span><br><span class="line">            Label_0074: &#123;</span><br><span class="line">                boolean b3;</span><br><span class="line">                try &#123;</span><br><span class="line">                    b3 = (booleanValue3 = booleanValue);</span><br><span class="line">                    if (b != null) &#123;</span><br><span class="line">                        break Label_0104;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (b3) &#123;</span><br><span class="line">                        break Label_0074;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break Label_0074;</span><br><span class="line">                &#125;</span><br><span class="line">                catch (IOException ex) &#123;</span><br><span class="line">                    throw b(ex);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (b3) &#123;</span><br><span class="line">                        this.a(b2, booleanValue2);</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                catch (IOException ex2) &#123;</span><br><span class="line">                    throw b(ex2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //actived</span><br><span class="line">            booleanValue3 = L.a(d, b(-13940, 8507));</span><br><span class="line">        &#125;</span><br><span class="line">        final boolean b4 = booleanValue3;</span><br><span class="line">        </span><br><span class="line">        //如果已经过了试用，就检测激活</span><br><span class="line">        Label_0122: &#123;</span><br><span class="line">            boolean b5;</span><br><span class="line">            try &#123;</span><br><span class="line">                final boolean b6;</span><br><span class="line">                b5 = (b6 = b4);</span><br><span class="line">                // b = av.b()</span><br><span class="line">                if (b != null) &#123;</span><br><span class="line">                    return b6;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!b5) &#123;</span><br><span class="line">                    break Label_0122;</span><br><span class="line">                &#125;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            catch (IOException ex3) &#123;</span><br><span class="line">                throw b(ex3);</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (!b5) &#123;</span><br><span class="line">                    this.c();</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            catch (IOException ex4) &#123;</span><br><span class="line">                throw b(ex4);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private static IOException b(final IOException ex) &#123;</span><br><span class="line">        return ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的分享结果可以看出，有两种破解思路</p><ul><li><p>方法一 修改 com.seventh7.widget.iedis.a.p.f 永远return true</p></li><li><p>方法二 搭建一个认证服务器，本地替换host，认证服务器返回的结果为</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;trailing&quot;: false, &quot;popup&quot;: true, &quot;activated&quot;: true, &quot;daysLeft&quot;: 0 &#125;</span><br></pre></td></tr></table></figure><p>方法一的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class IedisCracker &#123;</span><br><span class="line"></span><br><span class="line">private final static String IDEA_LIB=&quot;/Applications/IntelliJ IDEA.app/Contents/lib/*&quot;;</span><br><span class="line">private final static String IDEIS_LIB=&quot;/Users/liaojiacan/Library/Application Support/IntelliJIdea2017.2/Iedis/lib/*&quot;;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">ClassPool.getDefault().appendClassPath(IDEA_LIB);</span><br><span class="line">ClassPool.getDefault().appendClassPath(IDEIS_LIB);</span><br><span class="line"></span><br><span class="line">CtClass clazz = ClassPool.getDefault().getCtClass(&quot;com.seventh7.widget.iedis.a.p&quot;);</span><br><span class="line"></span><br><span class="line">CtMethod[] mds = clazz.getDeclaredMethods();</span><br><span class="line">for(CtMethod method : mds)&#123;</span><br><span class="line">if(method.getLongName().startsWith(&quot;com.seventh7.widget.iedis.a.p.f&quot;))&#123;</span><br><span class="line">System.out.println(&quot;Inject :: SUCCESS!&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">method.insertBefore(&quot;if(true)&#123;return true;&#125; &quot;);</span><br><span class="line">&#125; catch (CannotCompileException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">clazz.writeFile(&quot;/tmp/p.class&quot;);</span><br><span class="line"></span><br><span class="line">&#125; catch (NotFoundException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (CannotCompileException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Iedis是IDEA上的一个收费redis插件，java编写的，既然是java写的，收费这些自然是很容易绕过的。由于Java太容易被反编译，作者还是做了些代码混淆和字符串加密。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;利用jd-gui反
      
    
    </summary>
    
      <category term="逆向" scheme="http://liaojiacan.me/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="java逆向" scheme="http://liaojiacan.me/tags/java%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>proto变量类型与java类型对照表</title>
    <link href="http://liaojiacan.me/2017/10/11/proto%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%B8%8Ejava%E7%B1%BB%E5%9E%8B%E5%AF%B9%E7%85%A7%E8%A1%A8/"/>
    <id>http://liaojiacan.me/2017/10/11/proto变量类型与java类型对照表/</id>
    <published>2017-10-11T02:53:00.000Z</published>
    <updated>2018-02-08T06:58:50.000Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>proto type</th><th>java type</th></tr></thead><tbody><tr><td>double</td><td>double</td></tr><tr><td>float</td><td>float</td></tr><tr><td>int32</td><td>int</td></tr><tr><td>int64</td><td>long</td></tr><tr><td>uint32</td><td>int</td></tr><tr><td>uint64</td><td>long</td></tr><tr><td>sint32</td><td>int</td></tr><tr><td>sint64</td><td>long</td></tr><tr><td>fixed32</td><td>int</td></tr><tr><td>fixed64</td><td>long</td></tr><tr><td>sfixed32</td><td>int</td></tr><tr><td>sfixed32</td><td>long</td></tr><tr><td>bool</td><td>boolean</td></tr><tr><td>string</td><td>string</td></tr><tr><td>bytes</td><td>ByteString</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;proto type&lt;/th&gt;
&lt;th&gt;java type&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;float
      
    
    </summary>
    
    
      <category term="Protobuf" scheme="http://liaojiacan.me/tags/Protobuf/"/>
    
      <category term="rpc" scheme="http://liaojiacan.me/tags/rpc/"/>
    
  </entry>
  
  <entry>
    <title>proto文件</title>
    <link href="http://liaojiacan.me/2017/10/10/proto%E6%96%87%E4%BB%B6/"/>
    <id>http://liaojiacan.me/2017/10/10/proto文件/</id>
    <published>2017-10-10T11:52:00.000Z</published>
    <updated>2018-02-08T06:58:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>proto文件是Proto buffers的描述文件</p></blockquote><ul><li>syntax 指定pd编译器的版本，可以设置proto2或者proto3</li><li>message 类似java中的class关键字，在PB这里叫消息体</li><li>service 服务声明</li><li>修饰符<ul><li>required 非空，必须存在</li><li>optional 可选</li><li>repeated 可重复出现，类似集合的概念吧</li></ul></li><li>更多介绍参考官方文档，<a href="https://developers.google.com/protocol-buffers/docs/proto3#simple" target="_blank" rel="noopener">Protocal Buffers</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">service SearchService&#123;</span><br><span class="line">    rpc search(SearchRequest) returns (SearchResponse) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message SearchRequest &#123;</span><br><span class="line">  required string query = 1;</span><br><span class="line">  optional int32 page_number = 2;</span><br><span class="line">  optional int32 result_per_page = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message SearchResponse &#123;</span><br><span class="line">  string result = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;proto文件是Proto buffers的描述文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;syntax 指定pd编译器的版本，可以设置proto2或者proto3&lt;/li&gt;
&lt;li&gt;message 类似java中的class关键字
      
    
    </summary>
    
    
      <category term="Protobuf" scheme="http://liaojiacan.me/tags/Protobuf/"/>
    
      <category term="rpc" scheme="http://liaojiacan.me/tags/rpc/"/>
    
  </entry>
  
  <entry>
    <title>javaagent 的使用</title>
    <link href="http://liaojiacan.me/2017/10/10/javaagent-%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://liaojiacan.me/2017/10/10/javaagent-的使用/</id>
    <published>2017-10-10T03:40:00.000Z</published>
    <updated>2018-02-08T06:58:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>javaagent 是类似一个JVM的插件，利用JVM提供的Instrumentation API实现获取或者修改加载到JVM中的类字节码。</p></blockquote><p>编写一个javagent的jar的方式如下：</p><p>1.实现一个ClassFileTransformer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleTransformer implements ClassFileTransformer &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException &#123;</span><br><span class="line">System.out.println(className);</span><br><span class="line">System.out.println(protectionDomain.toString());</span><br><span class="line">return new byte[0];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.实现一个Premain-Class</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">public static void premain(String agentOps, Instrumentation inst) &#123;</span><br><span class="line">inst.addTransformer(new SimpleTransformer());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(&quot;This is a javaagent!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.MANIFEST.MF配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Premain-Class: com.github.liaojiacan.Main</span><br><span class="line">Can-Redefine-Classes: true</span><br><span class="line">Can-Retransform-Classes: true</span><br><span class="line">Can-Set-Native-Method-Prefix: true</span><br></pre></td></tr></table></figure><p>4.运行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:agent.jar -jar app.jar</span><br></pre></td></tr></table></figure><p>代码和assembly的打包配置可以参考，<a href="https://github.com/liaojiacan/code-snippets/tree/master/javaagent" target="_blank" rel="noopener">github</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;javaagent 是类似一个JVM的插件，利用JVM提供的Instrumentation API实现获取或者修改加载到JVM中的类字节码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;编写一个javagent的jar的方式如下：&lt;/p&gt;
&lt;p&gt;1.
      
    
    </summary>
    
      <category term="逆向" scheme="http://liaojiacan.me/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="java逆向" scheme="http://liaojiacan.me/tags/java%E9%80%86%E5%90%91/"/>
    
      <category term="java" scheme="http://liaojiacan.me/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Linux shell命令:cut命令</title>
    <link href="http://liaojiacan.me/2017/02/23/Linux%20Shell--cut%E5%91%BD%E4%BB%A4/"/>
    <id>http://liaojiacan.me/2017/02/23/Linux Shell--cut命令/</id>
    <published>2017-02-23T08:45:44.000Z</published>
    <updated>2018-02-08T06:58:50.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h4><p>将一段数据经过分析，取出我们想要的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cut -- cut out selected portions of each line of a file SYNOPSIS</span><br><span class="line">cut -b list [-n] [file ...]</span><br><span class="line">cut -c list [file ...]</span><br><span class="line">cut -f list [-d delim] [-s] [file ...]</span><br></pre></td></tr></table></figure><ul><li>-b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。</li><li>-c ：以字符为单位进行分割。</li><li>-d ：自定义分隔符，默认为制表符。</li><li>-f ：与-d一起使用，指定显示哪个区域。</li><li>-n ：取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的范围之内，该字符将被写出；否则，该字符将被排除。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who | cut -d 3-5 #截取 3-5列的内容</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who | cut -c 3-5 #截取 3-5列的内容 中文字符</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd|head -n 5|cut -d : -f -2 # 设置分隔符为：</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h4&gt;
&lt;p&gt;将一段数据经过分析，取出我们想要的&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
      <category term="linux" scheme="http://liaojiacan.me/categories/linux/"/>
    
    
      <category term="linux" scheme="http://liaojiacan.me/tags/linux/"/>
    
      <category term="shell" scheme="http://liaojiacan.me/tags/shell/"/>
    
  </entry>
  
</feed>
