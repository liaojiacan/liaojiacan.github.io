<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jiacan‘s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liaojiacan.me/"/>
  <updated>2020-10-04T12:03:00.189Z</updated>
  <id>http://liaojiacan.me/</id>
  
  <author>
    <name>Jiacan Liao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【游戏】网络游戏开发中的帧同步</title>
    <link href="http://liaojiacan.me/2020/10/03/%E3%80%90%E6%B8%B8%E6%88%8F%E3%80%91%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%B8%A7%E5%90%8C%E6%AD%A5%E5%92%8C%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5/"/>
    <id>http://liaojiacan.me/2020/10/03/【游戏】网络游戏开发中的帧同步和状态同步/</id>
    <published>2020-10-03T12:03:00.000Z</published>
    <updated>2020-10-04T12:03:00.189Z</updated>
    
    <content type="html"><![CDATA[<h4 id="两种同步模式"><a class="markdownIt-Anchor" href="#两种同步模式"></a> 两种同步模式</h4><ul><li>帧同步：顾名思义，多个客户端的数据以帧的形式安严格的顺序进行同步。</li><li>状态同步：每个运动物体在各个端维护当前的状态和运动的向量数据，以事件驱动的机制，同步当前物体最新的状态数据和运动向量。（状态数据指类似位置，血量等非行为数据，目的是用于状态纠错）</li></ul><table><thead><tr><th></th><th>帧同步</th><th>状态同步</th></tr></thead><tbody><tr><td>游戏类型</td><td>MOBA/RTS…</td><td>RPG/FPS…</td></tr><tr><td>C/S 复杂度</td><td>客户端实现复杂</td><td>服务端实现复杂</td></tr><tr><td>防作弊难度</td><td>客户端存在全图的数据，难以防止全图挂，视野挂等</td><td>状态和事件由服务端控制下发，容易校验玩家的状态</td></tr><tr><td>风险</td><td>容易出现一致性问题，随机数。浮点数的实现都得考虑跨平台。</td><td>服务端需要跑1:1的游戏逻辑，服务器的资源要求高，      同时在线多的游戏还得考虑状态同步量大导致的网络瓶颈</td></tr></tbody></table><h4 id="帧同步"><a class="markdownIt-Anchor" href="#帧同步"></a> 帧同步</h4><p>帧同步的是英文LockStepSync的翻译，严格的讲应该叫步调一致（协调）的同步，其中主要有两种实现针对不同的场景，局域网模式，也就是P2P网络的游戏采用的是严格的锁定帧同步，比如DOTA。还有一种是有中心服务器的，C（client）S（Server）模式的游戏，比如LOL，王者荣誉等，采用的则是非锁定的帧同步。</p><ul><li>锁定帧同步：客户端的每一帧的推进，都需要得到同一局的所有玩家确认，所以一个玩家掉线游戏就会暂停。但是因为是局域网所以这种情况比较少，是可以接受的。</li><li>非锁定帧同步：每个客户端和服务端以一定的帧率进行帧数据的同步，服务端只管当帧时间抵达时，将数据整理成一个帧数据包广播给所有的客户端。客户端收到帧数据包后对帧号进行比对，判断是否需要进行追帧，和执行逻辑。这种模式下，客户端的网络只会影响自己的游戏体验，其它网络正常的玩家是可以正常游戏的。</li></ul><blockquote><p>P2P网络做非锁定帧同步是不太合适的，因为如果作为主机的客户端，离线或者出现数据丢失，其它客户端是没办法恢复一致的状态的。而有中心服务器的模式，游戏的帧数据会先保存起来再广播出去，即便客户端重启，也是可以获取到帧数据队列进行追帧重放。</p></blockquote><h4 id="帧同步的原理"><a class="markdownIt-Anchor" href="#帧同步的原理"></a> 帧同步的原理</h4><p>帧同步的实现，可以将整个游戏理解为一个状态机。 游戏开始时下发的玩家数据，游戏中每个角色，玩家信息等状态是一致的。我们将这个起始状态下所有的游戏状态集合当做S0，序列帧为F0，当游戏进行到序列帧F100，状态集合为S100，期间，客户端安严格帧顺序的控制指令集合（状态转移指令），每个客户端从F0到F100期间，应用这些状态转移指令，同样的执行指令，同样的执行逻辑，最终的状态也肯定是一致。</p><h4 id="网络部分的伪代码"><a class="markdownIt-Anchor" href="#网络部分的伪代码"></a> 网络部分的伪代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">message Command1&#123;</span><br><span class="line">    int64 uid;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Command2&#123;</span><br><span class="line">     int64 uid;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Command3&#123;</span><br><span class="line">    int64 uid;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Frame&#123;</span><br><span class="line">    int64 frameId;</span><br><span class="line">    repeated Command1 command1;</span><br><span class="line">    repeated Command2 command2;</span><br><span class="line">    repeated Command3 command3;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class GameRoom&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Queue&lt;Object&gt; commandQueue = new ConcurrentLinkedList();</span><br><span class="line">    /**300ms 一帧关键帧**/</span><br><span class="line">    public finnal static int TICK_INTERVAL = 300;</span><br><span class="line">    /**任务调度器**/</span><br><span class="line">    TaskScheduler taskScheduler = ...;</span><br><span class="line">    /**不会并发执行，只需要保证可见性**/</span><br><span class="line">    public volatile int frameId = 0;</span><br><span class="line"></span><br><span class="line">    public void onGameStart()&#123;</span><br><span class="line">        long now =  System.currentTimeMillis()</span><br><span class="line">        // 更新 游戏状态等.....</span><br><span class="line">        pushGameStart();</span><br><span class="line">        // 主要的帧推送代码</span><br><span class="line">        taskScheduler.scheduler(()-&gt;nextTick(), Instant.now().plusMillis(TICK_INTERVAL))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void nextTick()&#123;</span><br><span class="line">        long start =  System.currentTimeMillis()</span><br><span class="line">        frameId ++;</span><br><span class="line">        while(!commandQueue.isEmpty())&#123;</span><br><span class="line">            Frame frame = ....</span><br><span class="line">            ...</span><br><span class="line">            push2RoomUser(frame);</span><br><span class="line">        &#125;</span><br><span class="line">        // 构造结构体和推送消息的耗时</span><br><span class="line">        long timeUse = System.currentTimeMillis() - start;</span><br><span class="line"></span><br><span class="line">        // 计算下一帧的剩余时间</span><br><span class="line">        long nextTickTimeLeft = TICK_INTERVAL - timeUse;</span><br><span class="line">        // 加入调度队列</span><br><span class="line">         taskScheduler.scheduler(()-&gt;nextTick(), Instant.now().plusMillis(nextTickTimeLeft &lt; 0 ? 0 : nextTickTimeLeft))</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onReciveUserCommand1(Command1 command1)&#123;</span><br><span class="line">        //预处理逻辑</span><br><span class="line">        commandQueue.offer(command1)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 其它处理如断线重连，帧数据落地等......</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="防作弊"><a class="markdownIt-Anchor" href="#防作弊"></a> 防作弊</h4><p>帧同步的实现方式，大部分的逻辑可以在客户端实现，轻量级的游戏，完全可以采用通用的帧同步服务，微信小游戏开发平台就提供了这样的一个通用的帧同步服务。由于大部分的逻辑在客户端实现，这就给防作弊带来了一定的难度。对于帧同步常规的防作弊主要侧重两方面，一是让作弊玩家只能自嗨，二是关键的状态特别是结算相关的玩家状态进行必须校验或者做云端处理。</p><ol><li>状态数据抽样：服务端隔一段时间收集每个客户端指定帧的帧数据，进行对比。少数服从多数，出现异常的客户端要求重连。</li><li>逻辑服：将客户端的逻辑实现抽象出来，服务端跑一个逻辑服务器，跟游戏进行同步运行或者结算的时候运行。关键状态数据以逻辑服上报的结果为主，如果逻辑出现异常，再以1上报的结果作为兜底的策略。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;两种同步模式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#两种同步模式&quot;&gt;&lt;/a&gt; 两种同步模式&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;帧同步：顾名思义，多个客户端的数据以帧的形式安严格的顺序进行同步。&lt;/li&gt;
&lt;li&gt;状态同步：每个运动物体
      
    
    </summary>
    
      <category term="游戏" scheme="http://liaojiacan.me/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>谈谈对分布式一致性算法Raft的理解</title>
    <link href="http://liaojiacan.me/2019/06/15/%E8%B0%88%E8%B0%88%E5%AF%B9%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95Raft%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://liaojiacan.me/2019/06/15/谈谈对分布式一致性算法Raft的理解/</id>
    <published>2019-06-15T09:45:44.000Z</published>
    <updated>2019-06-17T09:40:57.956Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>说到分布式一致性算法，鼻祖就是Paxos，但是Paxos算法复杂难理解。而Raft则简化了算法，更容易理解，在教学和工程落地上更加贴地气。工程上应用Raft的也有很多，如TiDB，Redis Sentinel，etcd 等，作为一名工程师如果想深入了解这些底层实现，就很有必要先了解一下Raft算法。</p><blockquote><p>先说下我现在对Raft的一个整体的理解，对于分布式系统副本的一致性问题，都是通过复制状态机来实现的，也就是同步的不是一个状态值，而是命令本身，我们需要一种机制让分布式系统的这些命令日志能够安全的按顺序复制并应用到本地的状态机中，Raft 通过 Leader election的机制，选出一个能购保证安全性的主节点来控制或者说处理命令，也就是发送日志到其他节点（半数以上）和应用状态机。怎么保证日志条目能够按顺序被应用且应用后不可修改就是Raft或者其他一致性算法主要解决的问题。</p></blockquote><h2 id="正文"><a class="markdownIt-Anchor" href="#正文"></a> 正文</h2><h3 id="一-核心概念概括"><a class="markdownIt-Anchor" href="#一-核心概念概括"></a> 一、核心概念概括：</h3><h5 id="系统中的角色"><a class="markdownIt-Anchor" href="#系统中的角色"></a> 系统中的角色：</h5><ul><li><p>Leader ： 领导人，负责发起日志复制，以及处理客户端请求。</p></li><li><p>Follower：跟随者，负责投票，以及处理Leader发过来的复制请求。</p></li><li><p>Candidate：候选人，Follower到Leader的中间状态，只有当Leader的心跳超时后，Follower才转化为候选人进行选举。</p></li></ul><h5 id="解决的问题"><a class="markdownIt-Anchor" href="#解决的问题"></a> 解决的问题：</h5><ol><li>Leader election ： 主节点选举</li><li>Log replication：日志复制，也是复制状态机的核心</li><li>Safety：安全性问题，怎么保证一些事情不会发生和保证某些事情一定会发生。</li></ol><h5 id="复制状态机"><a class="markdownIt-Anchor" href="#复制状态机"></a> 复制状态机：</h5><p>分布式的一致性，是在不同的节点各自维护一个状态机来实现的，状态机的机制保证只要是相同的命令顺序输入（将命令日志按顺序Append到各个节点的Log中），那么输出状态和结果肯定是一样的。</p><p><img src="https://raw.githubusercontent.com/liaojiacan/assets/master/img/raft-%E5%9B%BE1.png" alt></p><h5 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点：</h5><ol><li><p>强Leader机制，日志都是由Leader同步到其他节点，对复制状态机的实现更加简单。</p></li><li><p>Leader选举：采用随机计时器来发起投票，解决冲突的方式简单快捷。</p></li></ol><h5 id="主要的两种rpc通信"><a class="markdownIt-Anchor" href="#主要的两种rpc通信"></a> 主要的两种RPC通信：</h5><ol><li><p>RequestVote Rpc：  候选人发起的选举请求</p></li><li><p>AppendEntries  Rpc： Leader发起的日志复制请求和心跳机制。</p></li></ol><h3 id="二-核心问题"><a class="markdownIt-Anchor" href="#二-核心问题"></a> 二、核心问题</h3><h4 id="1领导人选举leader-election"><a class="markdownIt-Anchor" href="#1领导人选举leader-election"></a> （1）领导人选举（Leader election ）</h4><ol><li><p>最开始所有的节点都是Follower。Follower只要能从Leader 或者 Candidate收到心跳，则永远保持Follower身份。</p></li><li><p>如果在一段时间没有收到心跳，也就是Leader超时了，那么就发起选举。</p></li><li><p>发起选举的Follower 需要将term+1 并且将自己的角色转换为Candidate，然后向集群中其他节点发起RequestVote 的RPC。</p></li></ol><p><strong>选举过程中可能存在的情况：</strong></p><ul><li><p>顺利的情况下：Candidate 发启的RequestVote得到了多数派的响应，这个时候Candidate将自己转换为Leader并里面向其他服务器发起心跳来确立自己Leader的位置和组织其他Leader的产生。</p></li><li><p>在投票期间，收到了AppendEntries的日志复制请求（可能是自己的Leader突然活了，也可能是新的Leader产生了），如果收到的AppendEnrties RPC 的Term 大于或等于自己的term 则承认领导人并自己转换为Follower。如果term小于自己的term则拒绝这次RPC 并且保持Candidate状态，直到Leader选出。</p></li><li><p>在投票期间，有多个Candidate 或得的票数相同，无法决出胜负，那么每个Candidate会继续增加任期（term+1） 然后进行发起RequestVote RPC 直到选出为止（选举超时的时间是随机的，所以他们发起的时间是错开的，这种冲突很快就会被解决）</p></li></ul><h4 id="2日志复制log-replication"><a class="markdownIt-Anchor" href="#2日志复制log-replication"></a> （2）日志复制（Log Replication）：</h4><p>只有Leader才能处理客户端的请求，如果是非Leader的节点收到请求后要求转发到Leader处理，客户端的每个请求包含一条待执行的复制状态机命令，Leader将这条命令作为新的日志条目附加到自己的日志中去，然后发起AppendEntries RPC 请求到其他节点，让其他节点复制当前的这条日志，如果这条日志被安全复制（半数以上节点复制成功），Leader就将这条日志应用到自己的状态机中，并响应客户端，如果有些节点没有复制成功，Leader在接下来的时间会继续尝试发起AppendEnties RPC请求复制，尽管已经回复了客户端了。</p><blockquote><p>怎么判断当前的附加请求是否合法？</p></blockquote><p>* 每个AppendEntries RPC请求 中会带上待复制的日志条目的上一条日志的term和Index，Follower 会检查本地的日志条目是否有相同的index和term的日志条目（好比乐观锁），如果匹配则附加到本地日志条目中，不匹配则拒绝请求。</p><p>* 集群中的节点的日志可能存在很多种可能，有可能少，也有可能存在Leader没有的日志，但是可以保证被应用到状态机中的日志肯定是Leader中有的。</p><h4 id="3安全性safety"><a class="markdownIt-Anchor" href="#3安全性safety"></a> （3）安全性（Safety）：</h4><p>说到安全性，指得是在系统要保证有些事情是不能发生，还有保证一些事情是肯定要发生的。对于Raft来说，他要保证的就是:</p><blockquote><p>如果有任意节点将一个确定的日志条目应用到它的状态机中，那么其他节点不能在同一位置应用一个不同的命令。</p></blockquote><p>在上面Leader election 和 Log replication的流程中，还暂时无法保证Leader的日志是最新的，所以要引入一些手段来保证。</p><p>在Leader election 中 加入一个投票成功的条件，Candidate在发起RequestVote RPC 的时候会带上以下信息</p><ul><li>lastLogIndex候选人的最后日志条目的索引值</li></ul><ul><li>lastLogTerm候选人最后日志条目的任期号</li></ul><p>其他服务器收到后跟自己的日志条目进行比较，判断是否Candidate的日志是否包含自己的日志，如果包含则投票给他。这样只有Candidate是拥有最新的日志，他才可能通过半数以上的投票成为Leader。</p><h3 id="三-其他"><a class="markdownIt-Anchor" href="#三-其他"></a> 三、其他</h3><h4 id="rpc-重试机制和幂等"><a class="markdownIt-Anchor" href="#rpc-重试机制和幂等"></a> Rpc 重试机制和幂等：</h4><p>在上面的流程中AppendEntries Rpc 请求是一个并发的请求，如果中途Follower 挂了，那么Leader会不断的重试Leader会记录这台机器最后的复制的Index），而Follower处理请求的时候需要解决幂等问题。</p><h4 id="读一致性问题"><a class="markdownIt-Anchor" href="#读一致性问题"></a> 读一致性问题：</h4><ul><li><p>在Raft一致性读写都是通过Leader，一般情况下读请求不需要写日志，但是可能会出现脏读（Leader挂了后重新选出的Leader还不知道哪些日志被提交了，他只是有最新复制的日志。），Raft解决的办法是，Leader在选举出来后通过发送一个空的AppendEntries Rpc 到集群中来确定已经被提交的日志。这样就能保证Leader一定能读到最新状态的数据。</p></li><li><p>还有一种情况就是客户端当时认为的集群的Leader 可能已经不是Leader了，所以还是可能存在脏读，Raft 的实现，在处理读请求前先跟大多数节点来次心跳的同步（Zookeeper也有类似的情况，所以zookeeper要实现强一致，每次在读的时候要调用一次sync来同步一下数据）。</p></li></ul><h3 id="参考阅读"><a class="markdownIt-Anchor" href="#参考阅读"></a> 参考阅读</h3><ol><li>Raft 论文翻译： <a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md" target="_blank" rel="noopener">https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md</a></li><li>Raft 在线演示：<a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">http://thesecretlivesofdata.com/raft/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;说到分布式一致性算法，鼻祖就是Paxos，但是Paxos算法复杂难理解。而Raft则简化了算法，更容易理解，在教学和工程落地上更加贴地气。工程上
      
    
    </summary>
    
      <category term="分布式" scheme="http://liaojiacan.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://liaojiacan.me/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="一致性算法" scheme="http://liaojiacan.me/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/"/>
    
      <category term="Raft" scheme="http://liaojiacan.me/tags/Raft/"/>
    
  </entry>
  
  <entry>
    <title>谈谈对分布式一致性算法Paxos的理解</title>
    <link href="http://liaojiacan.me/2019/06/06/%E8%B0%88%E8%B0%88%E5%AF%B9%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95Paxos%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://liaojiacan.me/2019/06/06/谈谈对分布式一致性算法Paxos的理解/</id>
    <published>2019-06-06T09:45:44.000Z</published>
    <updated>2019-06-13T16:45:03.103Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>最开始知道这个Paxos协议，是在研究MySQL的高可用的时候接触到的，从MySQL的复制机制了解到有基于semi-sync 的半同步复制，还有组复制MySQL Group Replication (MGR), 后来了解到这个MGR就是基于Paxos来实现的。 除了MGR，还有蚂蚁金服的OceanBase，Google的 Spanner 、chubby 都是基于Paxos协议（Multi-Paxos）的实现(<a href="%5Bhttps://zh.wikipedia.org/wiki/%E7%8A%B6%E6%80%81%E6%9C%BA%E5%A4%8D%E5%88%B6%5D(https://zh.wikipedia.org/wiki/%E7%8A%B6%E6%80%81%E6%9C%BA%E5%A4%8D%E5%88%B6)">复制状态机</a>)。对于他们是怎么落地实现的，我还没有深入去研究，只是看过蚂蚁金服的中间件团队写的一本书有介绍到，所以这篇文章不是讲Paxos怎么应用（How），也不是讲Paxos的证明（Why），只是总结一下Paxos是什么（What）。</p><h2 id="正文"><a class="markdownIt-Anchor" href="#正文"></a> 正文</h2><p>Paxos算法是Lamport提出的一种基于消息传递的一致性算法,<a href="https://www.microsoft.com/en-us/research/publication/paxos-made-simple/?from=http%3A%2F%2Fresearch.microsoft.com%2Fen-us%2Fum%2Fpeople%2Flamport%2Fpubs%2Fpaxos-simple.pdf" target="_blank" rel="noopener">《Paxos Made Simple》</a>，Paxos算法解决的是在分布式系统中对<strong>某个值</strong>达成一致的问题（就像CAS是并发环境下保证原子操作的一种手段，Paxos的这种保证也是分布式系统一致性的理论基础）。下面说的Paxos都是指Basic Paxos，除此之外还有一个优化的Multi-Paxos。</p><blockquote><p>这里的分布式系统模型是非拜占庭将军模型，也就是消息或者命令可能丢失，但是不会有恶意消息/命令的情况。</p></blockquote><h3 id="paxos-的特点"><a class="markdownIt-Anchor" href="#paxos-的特点"></a> Paxos 的特点</h3><ul><li>只能确定一个值或者说单个事件的一致性，达成一致后无法修改</li><li>任何节点都可以发起提案</li><li>可容忍消息丢失、延时、乱序和重复。</li><li>利用多数派Majority机制保障2F+1的容错能力，也就是说只要保证集群半数以上节点存活，集群能正常服务。</li></ul><blockquote><p>把Paxos当作一个理论来看，可能比较好理解，在看这部分的时候，我总想往实际场景套，发现很难套上去，Paxos算法只是解决了单个值的共识问题，实际场景上落地需要实现连续的复制状态机，总之有点难理解，等我看下OceanBase团队的博客系统文章后再来回顾一下，《Paxos Made Simple》这篇论文后面有提到一个状态机的实现。</p></blockquote><h3 id="paxos算法中的角色"><a class="markdownIt-Anchor" href="#paxos算法中的角色"></a> Paxos算法中的角色</h3><ul><li>提议者（Proposer）：发起提案的节点</li><li>接受者（Acceptor）：参与决策，对提案进行承诺和接受的节点</li><li>学习者（Learner）: 不参与决策，对已经确定共识的提案进行学习记录的节点</li></ul><h3 id="paxos算法流程"><a class="markdownIt-Anchor" href="#paxos算法流程"></a> Paxos算法流程</h3><p><img src="https://raw.githubusercontent.com/liaojiacan/assets/master/img/paxos_%E4%BC%AA%E4%BB%A3%E7%A0%81.jpg" alt></p><ol><li><p>Prepare阶段：</p><ul><li><p>Proposer 准备一个提案（Proposal），只需要确定一个提案号N ，这个N是单调递增的 。</p></li><li><p>Proposer 将这个preapre消息 【Proposal Number （N）】 广播到所有的Acceptor节点，直到得到多数派的响应。</p></li><li><p>Acceptor 收到prepare消息后对N进行判断，然后作出响应。</p><blockquote><p>1.承诺不再响应编号小于N的提案</p><p>2.如果存在已经通过的提案，则在响应内容中体现。</p></blockquote></li></ul></li><li><p>Accept阶段：</p><ul><li><p>如果Proposer收到半数以上的Acceptor对它的编号为N的prepare请求的响应集合{(n,Vi)};那么，Proposer将在这个集合中挑选一个最大提案的value（如果不存在，也就是prepare阶段Acceptors的响应不包含提案，则这个值由当前Proposer决定）和 当前编号N 构造一个accept请求发给acceptors。</p><blockquote><p><strong>如果发现有已经被accept的提案，当前的Proposer需要将自己的value修改为这个最大值，这很关键，因为accept 阶段可能只有部分acceptor成功了，但是acceptors中能在下一次prepare阶段反馈给Proposer完成一个&quot;妥协&quot;</strong></p></blockquote></li><li><p>Acceptor收到accept请求后，只要它还未对编号大于N的Prepare请求作出响应，则它就可以通过这个提案。</p></li></ul></li><li><p>Learn阶段：</p><p>一个值被accept后，acceptor就要通知learner，哪个值被选定了。</p></li></ol><p><img src="https://raw.githubusercontent.com/liaojiacan/assets/master/img/Basic%20Paxos.png" alt></p><center>图1. Paxos 提案表决时序图</center><h3 id="paxos-的一些缺点"><a class="markdownIt-Anchor" href="#paxos-的一些缺点"></a> Paxos 的一些缺点</h3><ol><li><p>实现难度大</p></li><li><p>效率低，需要2次RPC调用。</p></li><li><p>存在活锁问题（多个Proposer在Prepare阶段存在交替请求promise的情况，导致大家都冲突了）。</p><blockquote><p>可以使用随机休眠时间来缓解这个问题，当发生冲突的时候，各自休眠一段时间2～5s。</p><p>或者使用一个主Proposer来发起提案，主Proposer的选举还是利用一次Paxos算法来决定。</p></blockquote></li></ol><h3 id="multi-paxos"><a class="markdownIt-Anchor" href="#multi-paxos"></a> Multi-Paxos</h3><p>Multi-Paxos 针对Basic Paxos的一些缺点进行优化，主要改进如下</p><ol><li>将2次RPC减少到1次（最开始还是需要2次），通过选出一个主Proposer来发起提案。</li><li>简化角色，集群中所有的节点既可以是Proposer也可以是acceptor。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;最开始知道这个Paxos协议，是在研究MySQL的高可用的时候接触到的，从MySQL的复制机制了解到有基于semi-sync 的半同步复制，还有
      
    
    </summary>
    
      <category term="分布式" scheme="http://liaojiacan.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://liaojiacan.me/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="一致性算法" scheme="http://liaojiacan.me/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/"/>
    
      <category term="Paxos" scheme="http://liaojiacan.me/tags/Paxos/"/>
    
  </entry>
  
  <entry>
    <title>【高可用架构】高可用架构的一般思路总结</title>
    <link href="http://liaojiacan.me/2019/06/01/%E3%80%90%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E3%80%91%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E7%9A%84%E4%B8%80%E8%88%AC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/"/>
    <id>http://liaojiacan.me/2019/06/01/【高可用架构】高可用架构的一般思路总结/</id>
    <published>2019-06-01T08:41:14.000Z</published>
    <updated>2019-06-02T15:07:01.474Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>“高可用”，“高并发”，&quot;一致性&quot;都是老生常谈的问题了，他们的定义在百科都可以查到，本文不谈具体的架构，只是谈谈一般思路，总结一些概念切入点。想一想几个问题:</p><ol><li>高可用解决的痛点是什么？</li><li>高可用架构设计难点在哪里？</li><li>有没有必要把所有的系统都按高可用设计？</li></ol><h2 id="正文"><a class="markdownIt-Anchor" href="#正文"></a> 正文</h2><p>一般我们说的系统主要由处理程序和存储构成，我们的一个个服务的本质就是将数据按一定的逻辑处理输入输出，怎么让我们的输入输出能在可接受的时间内无人工介入地正常运行，就是我们做高可用要做的工作。</p><h3 id="高可用解决的痛点是什么"><a class="markdownIt-Anchor" href="#高可用解决的痛点是什么"></a> 高可用解决的痛点是什么？</h3><p>评估一个系统的高可用一般会用可用性去表示，可用性=平均故障间隔/(平均故障间隔+平均修复时间)，也就是我们常说的多少个9，99.9%，99.99% 。 我们技术人员经常在写kpi的时候也会有一个服务的稳定性的指标和故障处理能力指标，如平均故障处理时间，平均故障反馈时间等。</p><ul><li>做好高可用，减少了运营期间，研发人员的介入，提高了用户体验，毕竟自动化的程序比手工操作来的快。</li><li>提高了数据的安全性，没有100%可靠的程序，我们能做的就是把损失降到最低，通俗讲就是鸡蛋不能都放一个篮子里面。</li></ul><h3 id="有没有必要把所有的系统都按高可用设计"><a class="markdownIt-Anchor" href="#有没有必要把所有的系统都按高可用设计"></a> 有没有必要把所有的系统都按高可用设计？</h3><p>很多小成本或者说一个创新产品（随时都可能下掉）的系统很少会考虑高可用，其实很容易理解，毕竟技术是为业务服务的吗，成本也是一个值得考量的因素。</p><ul><li>小公司，没有完善的基础建设，为一个不确定的产品考虑太多，一是影响开发进度，二是增加了早期投入的运营成本而且同机房的单点故障其实概率很低（前提是选择了靠谱的IDC托管，靠谱的云厂商），大部分程序可能运行个几年也就偶然几次小故障。<strong>可以在业务进入另一个里程碑的时候，结合预算进行架构演进，预算多了后，无论从用户角度还是从研发成本角度考虑都是有比较高的投入回报的</strong>。</li><li>大公司，基础设施完善，任何一个模块都有比较成熟稳定的高可用解决方案，早期的投入并不会很高，而且大部分都是资源共享的，不用白不用嘛，这个时候就可以一开始就将这部分考虑到系统架构设计中。</li></ul><h4 id="处理程序的高可用"><a class="markdownIt-Anchor" href="#处理程序的高可用"></a> 处理程序的高可用</h4><p>处理程序一般都是无状态的，我们多增加处理程序来防止单点故障，对于有状态的，比如我们的Web服务，一般都会部署多台，然后通过负载均衡来让多个服务同时提供处理。</p><ul><li>就好比飞机有2个发动机，坏了一个还能继续飞。</li><li>把一个域名DNS解析到2个Nginx，每个Nginx又负载均衡到N个节点上。</li><li>多个Master，通过分布式锁，或者选主（利用zookeeper），让一个时刻只有一个点进行处理，一但故障出现时可以自动切换。</li><li>多个Master，通过keepalived，然后通过vip进行提供服务。</li></ul><h4 id="存储的高可用"><a class="markdownIt-Anchor" href="#存储的高可用"></a> 存储的高可用</h4><p>说到存储或者说数据库高可用，业界有个理论，<strong>CAP理论</strong>，说的是对一个系统来说，一致性(Consistency)、可用性(Availability)、分区容错性（Partition tolerance），只能同时满足其中的两项。网上也有其论证的文章，感兴趣的可以去查一下，我这里用一个比较直观的例子来描述我的理解。</p><ol><li>假如我们现在有个单体的应用比如是http+web+mysql 的这种架构，对于web部分，我们可以参考上面说的处理程序的高可用进行设计。对于数据库Mysql来说，单点故障怎么解决？</li><li>俗话说鸡蛋不能放同一个篮子里面，同样我们的数据如果存在一个节点上，随时可能出现数据丢失或者说长时间无法恢复服务，为了降低风险，我们就必须冗余处理，如果一个点的故障率是1%，那么2个点同时故障的概率就降低到0.01%，这样我们的可用性(A) 就基本满足了。</li><li>但是当我们把数据进行多副本存储的时候，就必须面临的网络分区的问题，也就是P一般是要作为前提条件考虑的。</li><li>当出现网络分区了我们又面临了一个问题，我到底该往哪个节点写数据，该读哪个节点的数据，一个数据在不同节点可能存在不同的状态，这就是我们要考虑的一致性（C）的问题。</li></ol><p>就如CAP理论所说，我们似乎陷入了一个死循环，但是人嘛总有些取舍，我们又不是机器即1非0，总有一种情况是可以被大家接受的。我们说的可用性，不会说是100%，通常是99.9%，99.99% , 99.999%。 似乎我们看到了一个跳出循环的办法，我们考虑C和P，同时把A的提升到一个我们能接受的范围不就可以了吗，这也是大部分热门的分布式数据库的做法。</p><blockquote><p>三副本、四副本、五副本，两地三中心、两地四中心。</p></blockquote><p>好了，到了这里我们已经明确了我们的方向，我们选择C和P，可用性上我们采用副本的方式来提高可用性。那么这里又有个问题了，既然选择了C那么多个副本的一致性怎么保证？</p><p><strong>以MySQL的复制机制举例，有半同步复制，还有全同步复制，也有异步的复制。</strong></p><ul><li>semisync 插件实现半同步复制，这种机制下，可以保证binlog 至少同步到一个副本的relaylog后才提交事务，能保证数据不丢失。</li><li>全同步机制，顾名思义就是要等到所有的副本全部写log成功后才提交事务，所以性能会受很大影响。</li><li>异步复制是传统的Master -Slaver模式，副本都是异步同步的，只能做到最总一致性，但是性能是最高的。</li></ul><p><strong>到了这里，显然这个半同步复制更符合我们的要求，但是只要求写一个从成功能保证一致性吗？</strong></p><p>Quorum机制了解一下？N个节点，只要保证W(写)+R(读)&gt;N 即可保证数据的一致性，也就是常说的写半数以上节点。</p><p>当发送故障时需要在R个副本（最新写成功的节点）中选出一个节点作为主节点。</p><p>怎么选这个主节点出来，就要涉及到一些分布式的共识算法如Paxos，和Raft中。Leader election等</p><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><p>在系统设计中，如果要实现高可用，必然需要采用多副本的模式，多副本下的写机制一般采用写半数以上节点的同步写机制，在这种分布式系统中，没有固定的Master，同一时刻只有一个节点作为Master提供服务，当这个节点出现问题时，通过选举算法在写成功的那些节点中选出一个新的Master提供服务。</p><blockquote><p>上面对CAP的一些理解可能不是正在意义上的CAP，理解CAP理论也不是说为了让我们的系统就要按这个来设计一个AP或者CP的系统，个人觉得CAP理论更应该是作为一个&quot;尺&quot;，可以作为我们在设计系统的时候对 业务和成本等因素的一个权衡标准，也不一定要其中的2个，我们也可以选90%C，90%A，100%P，不是吗？。</p></blockquote><h3 id="进阶学习"><a class="markdownIt-Anchor" href="#进阶学习"></a> 进阶学习</h3><ul><li>Paxos 、Multi-paxos、Raft</li><li>Redis sentinel的 领头选举</li><li>Zookeeper的选举，ZAB协议</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;“高可用”，“高并发”，&amp;quot;一致性&amp;quot;都是老生常谈的问题了，他们的定义在百科都可以查到，本文不谈具体的架构，只是谈谈一般思路，总
      
    
    </summary>
    
      <category term="高可用架构" scheme="http://liaojiacan.me/categories/%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="系统设计" scheme="http://liaojiacan.me/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="架构设计" scheme="http://liaojiacan.me/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="分布式" scheme="http://liaojiacan.me/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="高可用" scheme="http://liaojiacan.me/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>生产环境MQ消息堆积的一般处理办法</title>
    <link href="http://liaojiacan.me/2019/05/30/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83MQ%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E7%9A%84%E4%B8%80%E8%88%AC%E5%A4%84%E7%90%86%E5%8A%9E%E6%B3%95/"/>
    <id>http://liaojiacan.me/2019/05/30/生产环境MQ消息堆积的一般处理办法/</id>
    <published>2019-05-30T09:45:44.000Z</published>
    <updated>2019-06-02T15:06:49.948Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>MQ，消息队列经常会用来解耦系统，由于前期的量预估不足，可能在某些时候导致MQ的消息堆积，导致业务异常，对于生产环境的业务，我们应该尽可能做到用户无感知地恢复服务。</p><h2 id="正文"><a class="markdownIt-Anchor" href="#正文"></a> 正文</h2><p>当我们的生产速率大于我们的消费速率的时候，就会表现出消息堆积，不同系统对消息堆积（处理延时）的容忍程度不同。</p><h3 id="案例"><a class="markdownIt-Anchor" href="#案例"></a> 案例</h3><p>假如现在有一个在线的业务，突然量大了起来，消费端或者说下游系统突然处理不过来了，MQ出现了大量的消息堆积，业务写入MQ异常，有什么办法可以相对平缓得解决呢？</p><h3 id="解决思路"><a class="markdownIt-Anchor" href="#解决思路"></a> 解决思路</h3><ol><li><p>从生产者端解决</p><p>一般我们的系统容量或者处理能力都是规划好的，出现消息堆积的情况，大部分是由于流量暴增引起，这个时候可以考虑控制生产者的速率，对前端机器流量进行限速限流。</p></li><li><p>从消费者端解决。</p><p>消费者端解决的思路有两种</p><ul><li>假如消费者数还有增加的空间，那么我们加消费者解决。</li><li>假如没有拓展的可能，但吞吐量还没达到MQ的上限，只是消费者消费能力不足，比如消费者总体消费能力已经到达上线（数据库写入能力等），或者类似Kafka的消费者数量与partition数有关，如果前期设计没有做好水平拓展的设计，这个时候多少个partition就只能对应多少个消费者。<strong>这个时候我们可以先把一部分消息先打到另外一个MQ中或者先落到日志文件中，再拓展消费者进行消费，优先恢复上游业务</strong>。</li></ul></li><li><p>从整理系统上进行解决。</p><p>第2点有提到就是有些MQ的设计限制，导致的消费者数是没法动态拓展的，这个时候可以考虑将原先队列进行拆分，比如新建一个topic 分担一部分消息，这个方式需要对系统的上下游都要进行调整，在实际操作难度可能比较高，处理起来可能也比较耗时，如果在事前有做好这个设计那事发后就能很好进行调整。</p></li></ol><h3 id="补充"><a class="markdownIt-Anchor" href="#补充"></a> 补充</h3><ol><li><p>如果采用先将消息消费到日志文件的方式，怎么保证时序性？</p><p>一般消息队列都有时序问题，我们需要根据业务，对消息进行分区路由，比如根据用户纬度，只保证同一个用户的消息时序就行了，比如我把id为1～10000的用户写在一个文件中，10001～20000的写在一个文件中。后面按这个文件单独消费就能保证消息的时序。</p></li><li><p>不同MQ的消息堆积能力</p><p>其实主要是看是采用内存堆积还是磁盘堆积了，一般像kafka磁盘堆积的，堆积能力都是很强的不会出现容量不足的写入异常，而像RabbitMQ这种内存堆积的，如果消费者跟不上，很容易就把内存堆满了。</p></li></ol><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>其实上面一对废话，最终总结下来就是，出现堆积后防止业务出现写入异常，需要把消息队列清出一份容量出来，也就是保证消息时序的情况下先将消息快速消费到一些速度更快的存储上，事后再写程序处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;MQ，消息队列经常会用来解耦系统，由于前期的量预估不足，可能在某些时候导致MQ的消息堆积，导致业务异常，对于生产环境的业务，我们应该尽可能做到用
      
    
    </summary>
    
      <category term="运维技巧" scheme="http://liaojiacan.me/categories/%E8%BF%90%E7%BB%B4%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="运维技巧" scheme="http://liaojiacan.me/tags/%E8%BF%90%E7%BB%B4%E6%8A%80%E5%B7%A7/"/>
    
      <category term="故障处理" scheme="http://liaojiacan.me/tags/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/"/>
    
      <category term="生产环境" scheme="http://liaojiacan.me/tags/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83/"/>
    
      <category term="MQ" scheme="http://liaojiacan.me/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>生产环境故障处理的一般办法总结</title>
    <link href="http://liaojiacan.me/2019/05/29/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%80%E8%88%AC%E5%8A%9E%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://liaojiacan.me/2019/05/29/生产环境故障处理的一般办法总结/</id>
    <published>2019-05-29T09:45:44.000Z</published>
    <updated>2019-05-30T03:17:51.452Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>任何一个系统上线运营后都或多或少会遇到生产环境故障问题，大部分情况下&quot;重启大法&quot;的确好用，但是能否有更符合我们这些&quot;有经验的&quot;工程师的做法呢？</p><hr><p>故障： 慢了，挂了，出异常。</p><p>处理：找线索、推测原因、再进一步找具体线索验证。</p><h3 id="总体的思路"><a class="markdownIt-Anchor" href="#总体的思路"></a> 总体的思路</h3><p>定位-&gt;保留现场-&gt; 故障快速恢复（重启/限流/降级/会滚）-&gt; 事后分析（日志/软硬件负载等）-&gt; 优化以及针对性加告警。</p><ul><li>线上告警/或者测试/客服反馈故障（模块/用户信息/时间等）</li><li>先看对应的模块工作是否正常（把接口往浏览器一敲，看看能不能访问，😄）</li><li>上机器看服务日志，看是否有异常日志（一般这种运行时异常，都要通过告警系统告警出来）</li><li>如果日志出现异常，回顾是否最近有更新服务，考虑是否需要会滚。</li><li>如果没有日志异常，纯粹是服务慢、超时，就要进一步分析了。</li><li>服务慢、超时，先看看目前的请求量多少，是否超出了当时的设计，一般这些都有做预警，如果没有预警出来，大概率不是这个原因，当然还是排除一下最好。</li><li>如果量不大，那一般就只有几种情况了，一是连接池或者线程池满了，二是GC 导致的停顿，三是数据库。</li><li>连接池和线程池满了都可能导致的新的请求无法处理，这个时候可以看下一些连接池的配置，线程池的配置，像数据库连接池如果用的是durid 可以有可视化的界面看，如果没有，可以通过jmap 把 heap都dump出来，查看链接池对象的属性，看类似idle等counter值，当然你也可以用一些在线的反射工具去看。像线程池的话如果是有界队列的可以通过 自定义拒绝策略类将异常告警出来。</li><li>GC 过程中的STW也可能导致请求超时，这个时候就要看是否堆空间不足，新老年代是否合理，可以考虑隔离一台机器出来把堆dump出来，看是否有内存泄漏。</li><li>数据库的话需要看下数据库服务的情况，慢查询等。</li><li>如果量大，那么是否考虑进行一个扩容，或者限流，或者考虑是否有DDOS攻击和CC攻击。</li><li>当然上一步只是一个分析过程，实际上也不可能让服务一直不回复等我们找到原因，一般都想先收集现场，能打快照的打快照，不能打快照的隔离出一台机器保留现场。</li></ul><h3 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h3><h4 id="1-先对现场数据进行定量归类"><a class="markdownIt-Anchor" href="#1-先对现场数据进行定量归类"></a> 1. 先对现场数据进行定量归类：</h4><ul><li>异常节点数量，少数节点故障还是多数节点故障。</li><li>时间点，出现异常的时间点或者范围，这个很重要，方便定位日志区间。</li><li>共同特征，比如是否都是依赖了某个下游服务，是同机房/ISP/程序版本/操作系统</li></ul><blockquote><p>这些最开始的归类有助于快速定位问题所在，记录故障路径，方便后面复盘。由于这些要求保留故障现场，但是我们也不能让服务一直不恢复，所以这些工作要在短时间内完成，如果公司的基础设施比较完善这些也应该能够在事后在各种监控系统进行复查。</p></blockquote><p>先解决问题再找原因，一般操作就是先保留现场，如果能保留快照（短时间内能完成），就保留快照后进行服务恢复，如果不能（比如JVM  dump heap 一般要很久），留一台线上机器，隔离流量（域名摘掉解析，nginx upstream 去掉，微服务得话将服务节点下线），其他机器重启恢复。</p><h4 id="2-对于无法从服务表象日志接口看出问题的情况就要深入服务运行环境进行分析排查"><a class="markdownIt-Anchor" href="#2-对于无法从服务表象日志接口看出问题的情况就要深入服务运行环境进行分析排查"></a> 2. 对于无法从服务表象（日志/接口）看出问题的情况，就要深入服务运行环境进行分析排查。</h4><ul><li><p>服务的表现：慢、挂、异常； 应用日志、上下游服务状态。</p><blockquote><p>Nginx 的 access log</p><p>一些trace 服务，如 spring cloud 的 Sleuth / Zipkin (dubbo 也可以)</p><p>Metric类的系统，直接定位到业务。</p></blockquote></li><li><p>硬件状态：CPU、内存、磁盘、网络是否有瓶颈。</p><blockquote><p>top 命令</p><p>free -h 看内存</p><p>df -h</p><p>iftop</p><p>nload</p><p>ping</p><p>lsof</p><p>netstat</p></blockquote></li><li><p>系统/容器/VM状态：系统日志，容器日志，VM GC日志等。</p><blockquote><p>jstat -gcutil  [pid] [period] 查看GC信息</p><p>jmap -heap [pid] 查看jvm堆的使用情况</p><p>唯品会开源的一些工具也挺好用的，<a href="https://github.com/vipshop/vjtools" target="_blank" rel="noopener">https://github.com/vipshop/vjtools</a></p></blockquote></li></ul><p>上面这些信息 可以通过一些监控系统，一般上规模的公司都有这些，可以快速获取到这些信息，没有的话，也可以自行上机器通过linux 命令查询到。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h3&gt;
&lt;p&gt;任何一个系统上线运营后都或多或少会遇到生产环境故障问题，大部分情况下&amp;quot;重启大法&amp;quot;的确好用，但是能否有更符合我们这些&amp;quot
      
    
    </summary>
    
      <category term="运维技巧" scheme="http://liaojiacan.me/categories/%E8%BF%90%E7%BB%B4%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="运维技巧" scheme="http://liaojiacan.me/tags/%E8%BF%90%E7%BB%B4%E6%8A%80%E5%B7%A7/"/>
    
      <category term="故障处理" scheme="http://liaojiacan.me/tags/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/"/>
    
      <category term="生产环境" scheme="http://liaojiacan.me/tags/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
  <entry>
    <title>【高可用架构】理解有状态服务和无状态服务</title>
    <link href="http://liaojiacan.me/2019/05/27/%E3%80%90%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E3%80%91%E7%90%86%E8%A7%A3%E6%9C%89%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1%E5%92%8C%E6%97%A0%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1/"/>
    <id>http://liaojiacan.me/2019/05/27/【高可用架构】理解有状态服务和无状态服务/</id>
    <published>2019-05-27T08:41:14.000Z</published>
    <updated>2019-06-02T09:51:41.390Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>“有状态&quot;和&quot;无状态” 这个两词经常会出现在一些架构设计的文章中，怎么去理解这两个的含义？这2种场景下该如何做高可用，数据一致性怎么解决？</p><h2 id="正文"><a class="markdownIt-Anchor" href="#正文"></a> 正文</h2><p>对于&quot;状态&quot;我个人的理解是， 对于同一时刻同一个请求产生的数据的状态数为一的则为无状态，大于一则认为有状态，至于是否允许多状态共存，取决于对一致性的要求。</p><h3 id="从数据层面看状态"><a class="markdownIt-Anchor" href="#从数据层面看状态"></a> 从数据层面看状态</h3><blockquote><p>数据的状态往往受2个纬度有关，一是与时间相关或者顺序相关的，不同的操作顺序可能导致同一个时间点上的数据状态&gt; 1个，二是与数据的副本状态相关的，数据落在多个副本上，可能出现多种数据状态的组合。</p></blockquote><p><strong>时间状态</strong>： 操作顺序有一定的限制，同一个状态的数据不能出现在2个时间点（重复请求）。</p><ul><li>如有个数据新增 ，更新，删除这3个顺序的请求，在下游业务也需要同样的顺序操作。</li><li>对于单状态的数据，如计数器，不能出现重复添加，也就是这个数据只有第一次出现的时间状态是对的，后来的数据在时间状态上是不允许的，对于这种场景，往往通过把这个&quot;点&quot;状的数据，换成&quot;线&quot;数据，比如换把计数器记录成操作历史，这个点的状态由这些历史数据聚合而成，&quot;线”数据容易做幂等操作。</li></ul><p><strong>位置状态</strong> :   数据落地点的状态。</p><ul><li>数据拆分后的应用，同一个数据就有了状态，他只能落在指定的节点上。</li><li>对于复制集架构，数据是存在多个副本的，也就是说数据落在的位置在集群上需要有一定的数量保证，以满足一定的共识基础，比如要写半数以上节点，也就是说这个数据是存在2个状态的，对于已经写成功的节点是成功状态，对于未写成功的节点是未成功/处理中的状态。如何协调这些状态，往往要引入一些共识协议（Paxos，Raft）。</li></ul><h3 id="从服务层面看状态"><a class="markdownIt-Anchor" href="#从服务层面看状态"></a> 从服务层面看状态</h3><blockquote><p>服务层面的状态取决于实例是单独维护数据还是共享数据，或者说是否存在多个数据闭环让数据的流向产生了多条路径。有状态的服务往往比较难进行水平拓展，在现在容器盛行的环境，把服务设计成无状态的更加高效，即便是有状态的服务，也要将状态内敛在系统的某个范围，比如分布式的存储，对于业务服务，我不需要关系数据在多个副本的状态，数据的状态由分布式存储这个服务本身解决。</p></blockquote><h4 id="有状态服务"><a class="markdownIt-Anchor" href="#有状态服务"></a> 有状态服务</h4><ul><li>服务本身依赖或者存在局部的状态数据，这些数据需要自身持久化或者可以通过其他节点恢复。</li><li>一个请求只能被某个节点（或者同等状态下的节点）处理。</li><li>存储状态数据，实例的拓展需要整个系统参与状态的迁移。</li><li>在一个封闭的系统中，存在多个数据闭环，需要考虑这些闭环的数据一致性问题。</li><li>通常存在于分布式架构中。</li></ul><h4 id="无状态服务"><a class="markdownIt-Anchor" href="#无状态服务"></a> 无状态服务</h4><ul><li>服务不依赖自身的状态，实例的状态数据可以维护在内存中。</li><li>任何一个请求都可以被任意一个实例处理。</li><li>不存储状态数据，实例可以水平拓展，通过负载均衡将请求分发到各个节点。</li><li>在一个封闭的系统中，只存在一个数据闭环。</li><li>通常存在于单体架构的集群中。</li></ul><h3 id="怎么做转换"><a class="markdownIt-Anchor" href="#怎么做转换"></a> 怎么做转换</h3><ol><li>采用复制或者集中式消除数据状态。</li></ol><p><img src="https://raw.githubusercontent.com/liaojiacan/assets/master/img/stateless%20vs%20stateful%20(1).png" alt></p><ul><li>对于Web服务，如果数据存在session中，那么这个服务就有了状态。</li><li>一种是对session进行复制，同步复制还是异步复制，取决于你对数据一致性的敏感程度。</li><li>也可以将session集中式管理，如用redis，出现性能或者容量的瓶颈，再换分布式的缓存，把状态交于缓存服务维护。</li><li>我们可以看出，有状态的服务，它的数据是存在多个闭环的，比如Web01-session-01-&gt; DB 和 Web02-session-&gt;DB 。通过复制，将session-01 和 02 等同于同一个。</li><li>或者我们可以将数据进行分区，让负载均衡器通过hash算法将请求落在固定的处理节点上。</li></ul><ol start="2"><li>采用控制节点来保证集中式存储的高可用和一致性。</li></ol><p><img src="https://raw.githubusercontent.com/liaojiacan/assets/master/img/stateless%20vs%20stateful%20-%20DB.png" alt></p><ul><li>在高可用的架构下，数据往往得存在多副本（鸡蛋别放一个篮子里面）</li><li>CAP理论，C和A不可能同时满足，多副本的存在让A可在有限时间内恢复，而C可用采用Quorum 机制来控制多个副本节点的数据一致性问题，保证半数以上的节点的写成功。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;“有状态&amp;quot;和&amp;quot;无状态” 这个两词经常会出现在一些架构设计的文章中，怎么去理解这两个的含义？这2种场景下该如何做高可
      
    
    </summary>
    
      <category term="高可用架构" scheme="http://liaojiacan.me/categories/%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="系统设计" scheme="http://liaojiacan.me/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="架构设计" scheme="http://liaojiacan.me/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="分布式" scheme="http://liaojiacan.me/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="高可用" scheme="http://liaojiacan.me/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>【系统与架构设计】你知道硬盘能有多快吗？</title>
    <link href="http://liaojiacan.me/2019/05/22/%E3%80%90%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E3%80%91%E4%BD%A0%E7%9F%A5%E9%81%93%E7%A1%AC%E7%9B%98%E8%83%BD%E6%9C%89%E5%A4%9A%E5%BF%AB%E5%90%97/"/>
    <id>http://liaojiacan.me/2019/05/22/【系统与架构设计】你知道硬盘能有多快吗/</id>
    <published>2019-05-22T08:40:14.000Z</published>
    <updated>2019-06-02T10:01:43.523Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>应用软件通常都是由各种类型的软硬件相互配合实现，无论你是单体架构还是分布式架构，任何一个模块或者环节都可能是系统的瓶颈，可能是CPU，可能是网络，也可能是硬盘等。了解一些基础的边界（“量”），有助于我们分析系统的瓶颈。</p></blockquote><h3 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h3><ul><li><p>大部分的应用系统都是IO密集型，同机房的服务一般性能的瓶颈在于磁盘IO，那么一般机械硬盘的性能上限是怎么样的，根据磁盘的最大性能能否判断我们的系统是否有优化的空间？</p></li><li><p>B+ tree 的索引 一般是3～4层，也就是平均情况下需要3到4次的I/O，我们的应用需要1000TPS，普通的机械磁盘的性能是否能达到要求？</p></li><li><p>假如innodb的事务处理能力只受redo log 的写入速度影响，一条操作日志1kb的话，TPS可以到达多少？</p></li><li><p>假如网络带宽限制不计的话，我们从一台机器同步一个1TB的数据，机械硬盘需要多久？</p></li></ul><blockquote><p>这些问题可能都不是正确的问题，我想表达的是假如现在来解答这些问题，能否根据自己的一些印象（磁盘的性能的量级。HDD硬盘100MB/s，SSD 500MB/s ，IOPS 100… 等）来估算一下。</p></blockquote><h3 id="存储设备的2个性能指标"><a class="markdownIt-Anchor" href="#存储设备的2个性能指标"></a> 存储设备的2个性能指标</h3><ul><li><p>IOPS ：(Input/Output Per Second)  每秒的输入输出量，代表存储系统的每秒的I/O请求数。“只关系数量”</p><ul><li>Random Read IOPS(随机读)</li><li>Random Write IOPS(随机写)</li><li>Sequential Read IOPS(顺序读)</li><li>Sequential Write IOPS(顺序写)</li><li>Total IOPS （混合读写）</li></ul></li><li><p>带宽/吞吐量：单位时间内传输的数据大小，比如10MB/秒 。“只关系比特数或者说容量”</p></li></ul><blockquote><p>对于OLTP应用/数据库，我们看重的更多的是随机I/O的性能，这个时候看IOPS更加合理，对于大文件或者顺序读写的应用（hadoop/kafka……），更加看重的是吞吐量。</p></blockquote><h3 id="机械硬盘-hdd"><a class="markdownIt-Anchor" href="#机械硬盘-hdd"></a> 机械硬盘 HDD</h3><ul><li>IOPS ：100左右</li></ul><table><thead><tr><th>设备</th><th>形式</th><th>IOPS</th><th>接口</th><th>注解</th></tr></thead><tbody><tr><td>7,200RPMSATA硬盘驱动器</td><td>硬盘驱动器</td><td>~75-100 IOPS</td><td>SATA 3Gbit/s</td><td></td></tr><tr><td>10,000 RPM SATA硬盘驱动器</td><td>硬盘驱动器</td><td>~125-150 IOPS</td><td>SATA 3 Gbit/s</td><td></td></tr><tr><td>10,000 rpmSAS硬盘驱动器</td><td>硬盘驱动器</td><td>~140 IOPS</td><td>SAS（串列SCSI）</td><td></td></tr><tr><td>15,000 rpmSAS硬盘驱动器</td><td>硬盘驱动器</td><td>~175-210 IOPS</td><td>SAS（串列SCSI）</td><td></td></tr></tbody></table><blockquote><p>数据来源于百度百科 <a href="https://baike.baidu.com/item/IOPS" target="_blank" rel="noopener">https://baike.baidu.com/item/IOPS</a></p></blockquote><ul><li>带宽/吞吐量 ：100MB/s 左右</li></ul><p><img src="https://raw.githubusercontent.com/liaojiacan/assets/master/img/WX20190522-165652.png" alt></p><blockquote><p>数据来源 <a href="https://hdd.userbenchmark.com/" target="_blank" rel="noopener">https://hdd.userbenchmark.com/</a></p></blockquote><p>可以看到 机械硬盘的的读写速度在 ～20.6MB/s - 200MB/S 之间</p><h3 id="固态硬盘-ssd"><a class="markdownIt-Anchor" href="#固态硬盘-ssd"></a> 固态硬盘 SSD</h3><ul><li>IOPS ：8000～80000</li></ul><table><thead><tr><th>设备</th><th>形式</th><th>IOPS</th><th>接口</th><th>注解</th></tr></thead><tbody><tr><td>英特尔Intel X25-M G2（MLC）</td><td>SSD</td><td>~8,600 IOPS</td><td>SATA 3 Gbit/s</td><td>英特尔的数据表声称在4KB数据的写入及读取时，分别有有6,600/8,600 IOPS (80GB/160GB版本)及35,000 IOPS的速度。</td></tr><tr><td>英特尔 Intel X25-E (SLC)</td><td>SSD</td><td>~5,000 IOPS</td><td>SATA 3 Gbit/s</td><td>英特尔数据表声称在写入和读取的速度为3,300 IOPS及35,000 IOPS。写入和读取混和时为5,000 IOPS。英特尔的X25-E G1比X25-M G2快了约三倍</td></tr><tr><td>G.SkillPhoenix Pro</td><td>SSD</td><td>~20,000 IOPS。</td><td>SATA 3 Gbit/s</td><td>SandForce-1200为基础的固态硬件，配合加强版的固件，最快可到50,000 IOPS，性能测试的结果是随机读取可到~25,000 IOPS，随机写入可到~15,000 IOPS。</td></tr><tr><td>OCZVertex 3</td><td>SSD</td><td>最高可到60,000 IOPS</td><td>SATA 6 Gbit/s</td><td>随机写入4KB (Aligned)</td></tr><tr><td>CorsairForce Series GT</td><td>SSD</td><td>最高可到85,000 IOPS</td><td>SATA 6 Gbit/s</td><td>240GB Drive，循序读取为555 MB/s，循序写入为525 MB/s。随机写入4KB (Aligned)</td></tr></tbody></table><blockquote><p>数据来源于百度百科 <a href="https://baike.baidu.com/item/IOPS" target="_blank" rel="noopener">https://baike.baidu.com/item/IOPS</a></p></blockquote><ul><li>带宽/吞吐量： 读548MB/S  | 写 370MB/s</li></ul><p><img src="https://raw.githubusercontent.com/liaojiacan/assets/master/img/WX20190522-181048.png" alt></p><blockquote><p>数据来源 <a href="https://ssd.userbenchmark.com/" target="_blank" rel="noopener">https://ssd.userbenchmark.com/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;应用软件通常都是由各种类型的软硬件相互配合实现，无论你是单体架构还是分布式架构，任何一个模块或者环节都可能是系统的瓶颈，可能是CPU，可能是网络，也可能是硬盘等。了解一些基础的边界（“量”），有助于我们分析系统的瓶颈。&lt;/p&gt;
&lt;/blockquo
      
    
    </summary>
    
      <category term="系统与架构设计" scheme="http://liaojiacan.me/categories/%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="系统设计" scheme="http://liaojiacan.me/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="架构设计" scheme="http://liaojiacan.me/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="存储" scheme="http://liaojiacan.me/tags/%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>一种适合后端团队代码的GIT分支管理办法</title>
    <link href="http://liaojiacan.me/2019/05/21/%E4%B8%80%E7%A7%8D%E9%80%82%E5%90%88%E5%90%8E%E7%AB%AF%E4%BB%A3%E7%A0%81%E7%9A%84GIT%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E5%8A%9E%E6%B3%95/"/>
    <id>http://liaojiacan.me/2019/05/21/一种适合后端代码的GIT分支管理办法/</id>
    <published>2019-05-21T08:45:44.000Z</published>
    <updated>2019-05-22T05:43:18.861Z</updated>
    
    <content type="html"><![CDATA[<p>  每个公司甚至公司中的不同团队对代码的分支管理都是有所差别，网上也有很多人分享了他们的分支管理规范，相信很多有一种感觉就是采用了他们的方法然后真正实践起来总是有些水土不服，我个人认为分支的管理需要结合团队规模、应用类型、发布流程等实际的情况来制定规范。下面我将介绍一种适用于后端开发团队且做toC产品业务后台的代码分支管理办法。</p><h3 id="不同业务代码的管理需求差异"><a class="markdownIt-Anchor" href="#不同业务代码的管理需求差异"></a> 不同业务代码的管理需求差异</h3><table><thead><tr><th></th><th>业务后台</th><th>基础工具SDK/中间件</th><th>独立部署企业软件</th></tr></thead><tbody><tr><td>多版本</td><td>不需要</td><td>需要</td><td>需要</td></tr><tr><td>迭代频率</td><td>1-2周</td><td>少更新</td><td>少更新</td></tr><tr><td>更新方式</td><td>灰度更新</td><td>更新SDK版本号</td><td>补丁包更新，不同版本不同的补丁包</td></tr><tr><td>维护版本</td><td>最近的2个版本，主要是发布失败会滚用</td><td>每个release版本都需要单独维护</td><td>每个客户的版本都要单独维护</td></tr></tbody></table><p>从上面的对比结果看，在做to C 产品的业务后台的，相对于开源软件，企业软件，中间件等对于版本控制的生命周期没有那么长，不需要对每个release版本进行长时间的维护跟踪，我们的服务更新永远只有一条线，因为我们的服务面向的研发只有自己的团队，就算出现版本兼容，在随后的几个版本也能快速升级上来。需要做好版本控制的仅仅在于最近上线的几个版本中。</p><h3 id="一种适合业务后台开发的git分支管理模型"><a class="markdownIt-Anchor" href="#一种适合业务后台开发的git分支管理模型"></a> 一种适合业务后台开发的GIT分支管理模型</h3><p><img src="https://raw.githubusercontent.com/liaojiacan/assets/master/imgGit%20%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B%20(6).png" alt></p><ol><li><code>develop</code>： 开发分支，平常开发的代码都提交到这里，为了简化，这里可以不用根据版本号进行细化分支。</li><li><code>feature/xxx</code>: 特性分支，这个目录下的分支，用于开发一些新特性，或者说是最近不需要上线的功能。</li><li><code>stage</code>： 测试分支，这个分支代表测试环境的代码，测试环境的镜像/程序必须通过该分支来构建，保证测试结果与代码的一致性。</li><li><code>master</code>：生产分支，这个分支代表生产环境的代码，生产环境的镜像/程序必须通过该分支来构建，部署后打tag确定release版本，对应我们的场景(业务后台)，我们只需要维护最近的2个release版本，一般情况下只能回滚最近的版本。</li><li><code>bugfix-xx</code>: 补丁分支，这个是一个临时分支，从待修复版本的起点开分支，每个分支对应一个补丁程序，在本地验证后，需要把补丁合并到stage进行测试验证，验证通过后再将补丁合并到master进行修复，同样也需要把补丁打到develop。</li></ol><h3 id="工作中常见的场景"><a class="markdownIt-Anchor" href="#工作中常见的场景"></a> 工作中常见的场景</h3><ol><li><strong>开发周期中，所有的功能在当前周期都能完成，需求评审确认通过且开发任务符合预期</strong>：</li></ol><p>  时间线：D1→D2→D3→D4→S3→M2 。因为经过评估在下一个发布时间前开发人员能够将D1到D4的4个功能完成开发，所以在次期间我们只需要保证这个分支的功能能正常演进即可，尽量不要引进太多的分支。</p><ol start="2"><li><strong>开发周期中，所有功能在当前周期完成，需求评审确认通过，少部分功能上线时间待定，任务进度符合预期</strong>：</li></ol><p>  这个时候可能存在2条线，大部分人参与当前版本的功能开发（develop分支的演进），少部分人进行未来版本上线的需求开发（F1，F2，F3）。F3→S2 这个合并尽量等到需求拍定上线版本后合并到stage给测试人员测试。</p><ol start="3"><li><strong>线上BUG的修复</strong>：</li></ol><p>  确认BUG后，如果是测试人员反馈回来的一般会是在JIRA 上提单，我们可以根据jira的issue Id，在master 上 创建一个bugfix-jira-xx，接下来在这个分支上完成补丁的开发（B1→B2），之后合并补丁到stage分支进行测试环境的部署（B2→S4），等待测试人员的验证，验证完成后将补丁合并到master和develop分支（B2→M3，B2→D5），并打一个小版本号的tag。</p><ol start="4"><li><strong>有个新功能，老板想立马上线，但是发版的时间还没到</strong>：</li></ol><p>  这种情况，把这个功能当成一个超前的feature处理，我们上面说的feature是一个未来版本的功能，可以走未来版本的测试上线流程，这里的feature 是一个超前的功能，我们需要走类似bugfix的流程，进行一个快速的开发上线。</p><blockquote><p>如果你们有遇到比较棘手的分支管理问题，欢迎留言交流。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  每个公司甚至公司中的不同团队对代码的分支管理都是有所差别，网上也有很多人分享了他们的分支管理规范，相信很多有一种感觉就是采用了他们的方法然后真正实践起来总是有些水土不服，我个人认为分支的管理需要结合团队规模、应用类型、发布流程等实际的情况来制定规范。下面我将介绍一种适用
      
    
    </summary>
    
      <category term="开发规范" scheme="http://liaojiacan.me/categories/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="开发规范" scheme="http://liaojiacan.me/tags/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    
      <category term="代码管理" scheme="http://liaojiacan.me/tags/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
      <category term="GIT" scheme="http://liaojiacan.me/tags/GIT/"/>
    
  </entry>
  
  <entry>
    <title>自定义ClassLoader实现一个支持热加载的应用启动器</title>
    <link href="http://liaojiacan.me/2019/03/17/%E8%87%AA%E5%AE%9A%E4%B9%89ClassLoader%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%94%AF%E6%8C%81%E7%83%AD%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E5%99%A8/"/>
    <id>http://liaojiacan.me/2019/03/17/自定义ClassLoader实现一个支持热加载的应用启动器/</id>
    <published>2019-03-17T08:46:00.000Z</published>
    <updated>2019-05-22T05:43:18.862Z</updated>
    
    <content type="html"><![CDATA[<p>JVM 默认是不支持Class的热加载的，也就是说我们的代码有变动，就要重启JVM来达到加载新的Class目的，但是很多容器如Tomcat、Jetty等都可以支持热加载，其底层的原理就是自定义ClassLoader。OSGI更是将类加载器玩到极至。我们来看看怎么实现一个简单的支持热加载的应用启动器。</p><h3 id="一-实现的目标"><a class="markdownIt-Anchor" href="#一-实现的目标"></a> 一、实现的目标</h3><ul><li>支持热加载</li><li>可配置的启动类</li></ul><h3 id="二-实现"><a class="markdownIt-Anchor" href="#二-实现"></a> 二、实现</h3><h4 id="1-支持热加载"><a class="markdownIt-Anchor" href="#1-支持热加载"></a> 1. 支持热加载</h4><p>关于类的加载，必然要说一下ClassLoader，JDK中存在这几个ClassLoader：</p><ul><li>BootstrapClassLoader 加载基础类</li><li>ExtClassLoader 加载拓展类，父加载器是BootstrapClassLoader</li><li>AppClassLoader 加载应用程序类 ，父加载器是ExtClassLoader</li></ul><p><strong>双亲委派：</strong><br>官方建议开发者，实现类加载器时遵循双亲委派规则，就是加载一个类时，先交给父加载器加载，如果父加载器无法加载，再由当前类加载器加载，从代码上来说，AppClassLoader已经写好了这个模版类，我们只需要覆盖findClass的逻辑即可。</p><blockquote><p>实现热加载需要违背双亲委派规则吗？</p></blockquote><p>由于ClassLoader中的defineClass方法会对已加载的类进行校验，所以我们无法对一个类进行重复加载，要实现热加载只能创建一个新的ClassLoader，假如我们采用双亲委派规则，那么我们需要加载的类会先被父加载器（AppClassLoader）给加载缓存起来，之后我们无论怎么创建一个新的加载器也无法达到热加载的目的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class HotSwapClassLoader extends ClassLoader &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 指定目录下的类可以热加载</span><br><span class="line"> */</span><br><span class="line">private String basePath;</span><br><span class="line"></span><br><span class="line">public HotSwapClassLoader(String basePath) &#123;</span><br><span class="line">this.basePath = basePath;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">// 加载指定目录下的class</span><br><span class="line">if (c == null) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">c = findClass(name);</span><br><span class="line">if (c != null) &#123;</span><br><span class="line">return c;</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">return super.loadClass(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return super.loadClass(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">String classResourcePath = this.basePath + &quot;/&quot; + name.replaceAll(&quot;\\.&quot;, &quot;/&quot;);</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">FileInputStream fileInputStream = new FileInputStream(new File(classResourcePath));</span><br><span class="line">ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();</span><br><span class="line">int len;</span><br><span class="line">byte[] buffer = new byte[1024];</span><br><span class="line">while ((len = fileInputStream.read(buffer)) &gt; 0) &#123;</span><br><span class="line">byteArrayOutputStream.write(buffer, 0, len);</span><br><span class="line">&#125;</span><br><span class="line">byte[] bytes = byteArrayOutputStream.toByteArray();</span><br><span class="line">return defineClass(name, bytes, 0, bytes.length);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">throw new ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-启动器"><a class="markdownIt-Anchor" href="#2-启动器"></a> 2. 启动器</h4><p>上面我们已经实现了一个可以随时替换的ClassLoader，我们还需要一个引导类去维护我们的ClassLoader 还有我们的应用启动入口，管理启动和关闭的时机，就好比Tomcat的Catalina一样，或者说我们的任何类的Main函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Bootstrap &#123;</span><br><span class="line"></span><br><span class="line">private String basePath;</span><br><span class="line">private Object application;</span><br><span class="line">private String applicationClassName;</span><br><span class="line">private volatile ClassLoader applicationClassLoader;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public Bootstrap(String basePath, String applicationClassName) &#123;</span><br><span class="line">this.basePath = basePath;</span><br><span class="line">this.applicationClassLoader = new HotSwapClassLoader(this.basePath);</span><br><span class="line">this.applicationClassName = applicationClassName;</span><br><span class="line">try &#123;</span><br><span class="line">this.application = getApplication();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了上面的那些成员，我们就可以利用Java的反射来实现自定义的Application类的启动（这个类可以方在任意位置，就好比我们的war包可以方在任意位置，只要在tomcat的server.xml中配置好baseApps的路径就好了）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void startApplication() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">this.application.getClass().getDeclaredMethod(&quot;start&quot;, null).invoke(this.application, new Object[0]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void stopApplication() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">this.application.getClass().getDeclaredMethod(&quot;stop&quot;, null).invoke(this.application, new Object[0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，剩下最后一个问题就是，我们怎么知道我们的类需要加载呢？有2种方式就是主动刷新，还有一种就是程序监听文件夹的文件变动。我们可以利用jdk7之后提供的WatchService来监控文件或者目录的变动情况，一发生变动，则先注销之前的Application 然后再创建一个新的HotSwapClassLoader来启动新的Application。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private void registerResourceWatcher() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">WatchService watchService = FileSystems.getDefault().newWatchService();</span><br><span class="line">Path p = Paths.get(basePath);</span><br><span class="line">p.register(watchService, new WatchEvent.Kind[]&#123;ENTRY_MODIFY, ENTRY_CREATE, ENTRY_DELETE&#125;);</span><br><span class="line">while (true) &#123;</span><br><span class="line">WatchKey k = watchService.take();</span><br><span class="line">for (WatchEvent&lt;?&gt; e : k.pollEvents()) &#123;</span><br><span class="line">reloadApplication();</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">k.reset();</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-测试"><a class="markdownIt-Anchor" href="#三-测试"></a> 三、测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">public Integer version = 46;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 应用的启动入口</span><br><span class="line"> */</span><br><span class="line">public void start() &#123;</span><br><span class="line">System.out.println(&quot;Start... version=&quot; + version);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 应用的停止入口</span><br><span class="line"> */</span><br><span class="line">public void stop() &#123;</span><br><span class="line">System.out.println(&quot;Stop... version=&quot; + version);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws IOException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">new Bootstrap(&quot;/Users/liaojiacan/Workspace/java/personal/code-snippets/java-language/target/classes&quot;</span><br><span class="line">,&quot;com.github.liaojiacan.classloader.app.Application&quot;).boot();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动后，我们修改Application的 version=47，然后rebuild project，这个时候这个文件就会发生改变,输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Start... version=46</span><br><span class="line">Stop... version=46</span><br><span class="line">Start... version=47</span><br></pre></td></tr></table></figure><p>完整代码见Github :<a href="https://github.com/liaojiacan/code-snippets/tree/master/java-language/src/main/java/com/github/liaojiacan/classloader" target="_blank" rel="noopener">https://github.com/liaojiacan/code-snippets/tree/master/java-language/src/main/java/com/github/liaojiacan/classloader</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JVM 默认是不支持Class的热加载的，也就是说我们的代码有变动，就要重启JVM来达到加载新的Class目的，但是很多容器如Tomcat、Jetty等都可以支持热加载，其底层的原理就是自定义ClassLoader。OSGI更是将类加载器玩到极至。我们来看看怎么实现一个简单
      
    
    </summary>
    
      <category term="JDK" scheme="http://liaojiacan.me/categories/JDK/"/>
    
    
      <category term="ClassLoader" scheme="http://liaojiacan.me/tags/ClassLoader/"/>
    
      <category term="热加载" scheme="http://liaojiacan.me/tags/%E7%83%AD%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Java中的多线程和锁实现原理</title>
    <link href="http://liaojiacan.me/2019/03/11/Java%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://liaojiacan.me/2019/03/11/Java中的多线程和锁实现原理/</id>
    <published>2019-03-11T09:19:00.000Z</published>
    <updated>2019-05-22T05:43:18.858Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程的实现"><a class="markdownIt-Anchor" href="#线程的实现"></a> 线程的实现</h2><p>Java 规范里面并没有规定JVM要如何实现线程模型，在HotSpot VM 中使用的是1:1的线程模型，即1个java线程对应一个OS的线程（内核线程），在Thread中又很多native方法，就是调用OS的函数进行用户线程和内核线程的绑定。</p><ul><li>每个线程都又一个内核线程与之绑定，用户线程推出，内核线程也会一起退出。</li><li>内核线程的数量是有限制的</li><li>内核线程调用，上下文切换开销很大。</li></ul><h3 id="线程调度"><a class="markdownIt-Anchor" href="#线程调度"></a> 线程调度</h3><h4 id="线程的状态-threadstate枚举"><a class="markdownIt-Anchor" href="#线程的状态-threadstate枚举"></a> 线程的状态 （Thread.State枚举）</h4><ul><li>NEW :</li><li>RUNNABLE : 对应的就绪和运行态</li><li>BLOCKED : 阻塞状态，处于阻塞状态的线程会不断地请求资源，请求成功后就会进入就绪状态。</li><li>WAITING : 等待状态，当线程调用wait,join,park等函数。等待状态下会释放资源，让出CPU和释放锁。需要其他线程唤醒。</li><li>TIMED_WAITING  有限的等待。</li><li>TERMINATED</li></ul><h3 id="线程相关的一些文章"><a class="markdownIt-Anchor" href="#线程相关的一些文章"></a> 线程相关的一些文章</h3><ul><li><a href="https://www.zhihu.com/question/27491155/answer/36847691" target="_blank" rel="noopener">Java的线程管理器能保证每个线程都有执行的机会么?</a></li><li><a href="http://www.hainiubl.com/topics/29" target="_blank" rel="noopener">wait/notify实现原理</a></li></ul><h2 id="锁"><a class="markdownIt-Anchor" href="#锁"></a> 锁</h2><p>因为多线程的共享数据存在线程安全问题，需要通过一些控制来保证共享数据的读写，JVM层面提供sychronized的锁，而java层面current包下面有许多基于AQS的Lock的实现,在jdk1.6后,synchronized 和 ReentrantLock性能上以及没有太大的差距，ReentrantLock的使用更佳灵活，性能稳定，支持超时机制等，而采用synchronized不需要程序自己控制锁的加锁和释放，不容易出现死锁等问题。</p><h3 id="synchronized-的实现原理"><a class="markdownIt-Anchor" href="#synchronized-的实现原理"></a> synchronized 的实现原理</h3><p>JVM规范规定基于进入和退出monitor对象来控制方法和代码块的同步，也是就是monitorenter和monitorexit两个指令，当程序执行到monitorenter指令时会尝试获取对象的monitor所有权，也就是获取对象的锁。在最开始的JVM实现中是采用重量级锁的实现，线程的切换都涉及到用户态到内核态的切换，比较消化资源，所以在jdk1.6对锁进行优化。</p><h4 id="同步原理"><a class="markdownIt-Anchor" href="#同步原理"></a> 同步原理</h4><blockquote><ul><li>JVM是怎么控制多线程程序的交替访问的？</li></ul></blockquote><p>Java中每个对象都有一个内置锁与之对应，所有需要对该对象进行排他性或者一致性访问时需要获取对象的内置锁（synchronized 中的代码，monitorenter指令）。这个内置锁的信息存在对象的对象头中（一些基本信息，其他的condition，队列等是在native heap中的）。一个对象的Monitor只能被一个线程获取到，其他线程得等待持有的Monitor的线程释放。</p><blockquote><p>在一些官方的注释中说的是ObjectMonitor是一个内联锁对象的封装，就好比JVM层面实现的一个类似JUC框架下的Lock（不是说ObjectMonitor是JUC的Lock实现，说的是他们可能实现思路是一样的）。</p></blockquote><p>做好线程的同步协调，我认为需要这3样东西（ObjectMonitor 和J.U.C的AQS 都是这样的）：</p><ol><li>维护一个竞争的互斥量</li><li>一个队列</li><li>线程的挂起和唤醒</li></ol><blockquote><p>实现同步也可以只用一个互斥量，自旋锁就是这么实现的，但是锁竞争太激烈会导致CPU做无用功。</p></blockquote><p>想继续了解ObjectMonitor的实现可以看这几篇文章：</p><ul><li><a href="http://moonfacex.github.io/blog/java/2016/03/31/synchronized_and_monitor.html" target="_blank" rel="noopener">synchronized 与 object’s Monitor</a></li><li><a href="https://www.hollischuang.com/archives/2030" target="_blank" rel="noopener">Moniter实现原理</a></li></ul><h4 id="对象头"><a class="markdownIt-Anchor" href="#对象头"></a> 对象头</h4><blockquote><ul><li>Object的锁信息是存在在哪里的？</li><li>在获取对象的锁的过程中都用到了对象头的哪些数据？</li></ul></blockquote><p>锁的信息存在java对象头里面。如果对象是数组，这虚拟机会用3个Word(32位虚拟机，32bit)来存对象头，如果对象是非数组类型，则用2个Word来存对象头，其中 有一个word用来存储对象的hashcode和锁信息，32bit，叫Mark word。</p><ul><li>Mark Word 不是一个固定的数据结构，具体的信息分布需要先判断2bit的锁标志位，不同的锁标志位，剩余的30bit可能表示不同的意思。</li><li>32bit的信息是不够存Monitor线程同步（调度）所需要的信息的，所以重量级锁是有另外的native heap存储的，之后再把指针存在Mark word 中。</li></ul><table width="500" border="1" cellspacing="0" cellpadding="0"><tbody><tr><td rowspan="2" valign="top" width="76"><strong>锁状态</strong></td><td colspan="3" valign="top" width="106"><p align="center">25 bit</p></td><td rowspan="2" valign="top" width="85"><p align="center">4bit</p></td><td valign="top" width="85">1bit</td><td valign="top" width="78">2bit</td></tr><tr><td colspan="2" valign="top" width="70">23bit</td><td valign="top" width="56">2bit</td><td valign="top" width="120">是否是偏向锁</td><td valign="top" width="100">锁标志位</td></tr><tr><td valign="top" width="90">轻量级锁</td><td colspan="5" valign="top" width="276">指向栈中锁记录的指针</td><td valign="top" width="78">00</td></tr><tr><td valign="top" width="76">重量级锁</td><td colspan="5" valign="top" width="276">指向互斥量（重量级锁）的指针</td><td valign="top" width="78">10</td></tr><tr><td valign="top" width="76">GC标记</td><td colspan="5" valign="top" width="276">空</td><td valign="top" width="78">11</td></tr><tr><td valign="top" width="76">偏向锁</td><td valign="top" width="80">线程ID</td><td colspan="2" valign="top" width="80">Epoch</td><td valign="top" width="120">对象分代年龄</td><td valign="top" width="85">1</td><td valign="top" width="78">01</td></tr></tbody></table><h4 id="锁的优化"><a class="markdownIt-Anchor" href="#锁的优化"></a> 锁的优化</h4><p>在jdk1.6之前synchronized是单纯的重量级锁实现，由于重量级锁，线程获取不到锁就需要挂起等待唤醒，这种切换涉及到了用户态到内核态的转换，开销还是比较大的。在jdk1.6加入了偏向锁、轻量级锁。只有一个线程请求对象锁的时候，启用的是偏向锁，当有第二个线程竞争的时候（应该说是偏向状态出现锁竞争），这个时候会升级为轻量级锁（cas 自旋锁），处于轻量级锁状态下，如果自旋10次（可以配置）还是获取锁失败，则锁升级为重量级锁。</p><ul><li><p>偏向锁 ：在大部分情况下一个同步方法或者一个同步代码块不存在多线程的竞争，这样只需要在对象头和当前线程的栈帧中存一个线程ID，每次获取锁的时候只需要判断一些线程ID释放一致就行了，不用进行CAS的加锁和解锁。如果有第二个线程需要竞争锁，这个时候会通过CAS设置Mark Word中的锁状态位，成功则修改为偏向当前线程，失败的话就进行锁的升级，锁升级涉及到偏向锁的撤销，会将偏向锁线程挂起。</p><blockquote><p><a href="https://stackoverflow.com/questions/14717736/where-is-objects-hash-code-stored-if-biased-locking-is-enabled-in-hotspot-jvm" target="_blank" rel="noopener">偏向锁会将Mark Word设置为当前threadId，那么hashCode存哪里了?</a><br>如果处于偏向的的对象调用的hashCode方法就会触发撤销偏向锁</p></blockquote></li><li><p>轻量级锁：线程在获取锁之前，当前线程会在栈帧中创建一个Mark Word的拷贝作为锁记录，官方称为Displaced Mark Word。然后将对象头中替换成锁记录的指针（CAS），如果失败则会自旋10次（在1.6之后是采用自适应锁，这个时间已经不能自己配置了），之后升级为重量级锁。</p><blockquote><p>为什么一定要拷贝到Displaced Mark Word，而不直接就采用一个threadId？一个原因是需要恢复hash和GC分代的信息，一个就是解决重入锁的问题。</p></blockquote></li><li><p>重量级锁：ObjectMonitor有更多的空间来实现线程同步，可以更好像的实现线程同步（挂起和唤醒）。<a href="https://www.zhihu.com/question/41930877/answer/136699311" target="_blank" rel="noopener">轻量级锁为什么要膨胀？</a></p></li></ul><h4 id="优缺点"><a class="markdownIt-Anchor" href="#优缺点"></a> 优缺点</h4><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>使用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>只需比较threadId释放是否是当前线程<br>没有CAS的消耗</td><td>当出现锁竞争的时候会有锁撤销的消耗</td><td>单个线程</td></tr><tr><td>轻量级锁</td><td>线程一直在用户态，不用挂起。没有线程切换的消耗</td><td>自旋会导致CPU做无用功</td><td>同步代码块执行较快。</td></tr><tr><td>重量级锁</td><td>线程挂起，不用进行自旋</td><td>用户态到内核态转化，开销大</td><td>同步代码块执行时间较长，锁竞争激烈</td></tr></tbody></table><h3 id="juc中的锁"><a class="markdownIt-Anchor" href="#juc中的锁"></a> J.U.C中的锁</h3><p>上面锁的synchronzied是JVM的内置锁，在1.6之前性能比较差，Doug Lea就写个并发框架(java.util.current)，在1.6之后synchronized的性能已经跟Lock查不不多了，但是还少了锁的获取和释放的操作性，不支持超时，只有一个condition等。</p><h4 id="aqs"><a class="markdownIt-Anchor" href="#aqs"></a> AQS</h4><p>AbstractQueueSynchronizer是J.U.C中其他锁或者同步器的基础框架（ReentrantLock,ReentrantReadWriteLock,CountdDownLatch,CyclicBarrier等），这些框架在AQS的基础上进行了扩展，通常是继承AQS然后实现了AQS的几个抽象方法。</p><blockquote><p>我在上面说ObjectMonitor有说到，同步器为了完成同步工作，需要3个东西：</p></blockquote><ol><li>用于同步的状态量</li><li>一个队列或者一个保存等待线程的容器</li><li>线程的挂起和唤醒</li></ol><p>我们看下AQS是怎么围绕这3个部分进行实现的。</p><h5 id="1-同步的状态量互斥量"><a class="markdownIt-Anchor" href="#1-同步的状态量互斥量"></a> 1. 同步的状态量(互斥量)</h5><p>AQS中维护一个volatile 的int 变量state，线程通过cas来获取这个互斥量。AQS提供一下几个方法来对state变量进行操作。</p><ul><li>getState()</li><li>compareAndSetState(int expect, int update)</li><li>setState(int state)</li></ul><p>有了上面的3个方法，同步器就可以实现自旋锁，但是如果想实现公平锁，上面的三个方法或者说单用一个state变量是无法做到了。这个时候就需要一个FIFO的队列来维护这些线程。此外为了实现重入锁，我们还得需要一个变量来存当前持有的锁是什么线程。</p><h5 id="2等待线程队列"><a class="markdownIt-Anchor" href="#2等待线程队列"></a> 2.等待线程队列</h5><p>AQS 用了一个CLH的双向队列，Node的数据结构大概如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">statci final class Node&#123;</span><br><span class="line">    </span><br><span class="line">    volatile int waitStatus;</span><br><span class="line">    volatile Node prev;</span><br><span class="line">    volatile Node next;</span><br><span class="line">    Node nextWaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS维护一个头节点和一个尾节点，入队的时候通过CAS加入到未尾节点中。入队后开始开始自旋。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            // 前趋节点是头节点，并且获取到互斥量，说明获取锁成功。</span><br><span class="line">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = null; // help GC</span><br><span class="line">                failed = false;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            // 判断是否需要挂起</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码片段可以看出，加入队列的线程节点并不是完全的自旋，shouldParkAfterFailedAcquire方法判断当前线程是否需要挂起。</p><blockquote><p>下面的这个方法表明shouldParkAfterFailedAcquire 会在调用1到2次后会返回true（如果期间节点没有发生改变的话）。也就是自旋锁只自旋了2次就会被挂起。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">        int ws = pred.waitStatus;</span><br><span class="line">        if (ws == Node.SIGNAL)</span><br><span class="line">            /*</span><br><span class="line">             * This node has already set status asking a release</span><br><span class="line">             * to signal it, so it can safely park.</span><br><span class="line">             */</span><br><span class="line">            return true;</span><br><span class="line">        if (ws &gt; 0) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * Predecessor was cancelled. Skip over predecessors and</span><br><span class="line">             * indicate retry.</span><br><span class="line">             */</span><br><span class="line">            do &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /* </span><br><span class="line">             * 进行到这里说明前驱节点的waitStatus 是0 或者PROPAGATE ，利用CAS的设置为SIGNAL，这样下次自旋就会阻塞了，这里不返回true的目的是让当前线程再自旋一次，确保挂起前是无法获取到锁（避免发生刚挂起就被唤醒的情况）。</span><br><span class="line">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="line">             * need a signal, but don&apos;t park yet.  Caller will need to</span><br><span class="line">             * retry to make sure it cannot acquire before parking.</span><br><span class="line">             */</span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="3线程的挂起和唤醒"><a class="markdownIt-Anchor" href="#3线程的挂起和唤醒"></a> 3.线程的挂起和唤醒</h5><p>AQS中实现线程的挂起和唤醒是通过LockSupport这个工具，LockSupport的底层实现是调用Unsafe的native方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void unpark(Thread thread) &#123;</span><br><span class="line">    if (thread != null)</span><br><span class="line">        UNSAFE.unpark(thread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void park(Object blocker) &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    setBlocker(t, blocker);</span><br><span class="line">    UNSAFE.park(false, 0L);</span><br><span class="line">    setBlocker(t, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="conditionobject"><a class="markdownIt-Anchor" href="#conditionobject"></a> ConditionObject</h5><p>ConditionObject 是AQS实现类似object类的wait/notify/notifyAll方法的，ConditionObject提供的是aw<br>ait/awaitNanos(long nanos)/awaitUtil(Date date)/awaitUniterrutibly()/signal()/signalAll()。底层的实现也是各自维护一个队列，Node.nextWaiter。</p><ul><li>对于超时机制也是用LockSupport中的实现，但并不是所有情况下都使用系统的休眠，有个休眠的自旋时间阀值<code>spinForTimeoutThreshold = 1000L</code> ，默认是1000 纳秒，少于这个阀值的都不用休眠，而是直接自旋。</li></ul><h3 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h3><ul><li><a href="http://moonfacex.github.io/blog/java/2016/03/31/synchronized_and_monitor.html" target="_blank" rel="noopener">synchronized 与 object’s Monitor</a></li><li><a href="http://ifeve.com/introduce-abstractqueuedsynchronizer/" target="_blank" rel="noopener">AbstractQueuedSynchronizer的介绍和原理分析</a></li><li><a href="https://blog.csdn.net/chenssy/article/details/65449785" target="_blank" rel="noopener">J.U.C之AQS：阻塞和唤醒线程</a></li><li><a href="https://blog.csdn.net/m_xiaoer/article/details/73274642" target="_blank" rel="noopener">关于synchronized的Monitor Object机制的研究</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html" target="_blank" rel="noopener">Intrinsic Locks and Synchronization</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;线程的实现&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#线程的实现&quot;&gt;&lt;/a&gt; 线程的实现&lt;/h2&gt;
&lt;p&gt;Java 规范里面并没有规定JVM要如何实现线程模型，在HotSpot VM 中使用的是1:1的线程模型，即1个java线程对
      
    
    </summary>
    
      <category term="jdk" scheme="http://liaojiacan.me/categories/jdk/"/>
    
    
      <category term="多线程" scheme="http://liaojiacan.me/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="synchronized" scheme="http://liaojiacan.me/tags/synchronized/"/>
    
      <category term="AQS" scheme="http://liaojiacan.me/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>Innodb中的锁总结</title>
    <link href="http://liaojiacan.me/2019/02/28/Innodb%E4%B8%AD%E7%9A%84%E9%94%81%E6%80%BB%E7%BB%93/"/>
    <id>http://liaojiacan.me/2019/02/28/Innodb中的锁总结/</id>
    <published>2019-02-28T11:22:00.000Z</published>
    <updated>2019-05-22T05:43:18.857Z</updated>
    
    <content type="html"><![CDATA[<h3 id="锁的种类"><a class="markdownIt-Anchor" href="#锁的种类"></a> 锁的种类</h3><h4 id="表锁"><a class="markdownIt-Anchor" href="#表锁"></a> 表锁</h4><ul><li>LOCK TABLE <em>table_name</em> READ : 用读锁锁表，阻塞其他事务修改</li><li>LOCK TABLE <em>table_name</em> WRITE: 用写锁锁表，阻塞其他事务读和写</li></ul><h4 id="行锁"><a class="markdownIt-Anchor" href="#行锁"></a> 行锁</h4><ul><li>X锁：排他锁，允许对数据进行删除和更新/插入</li><li>S锁：共享锁，允许对数据进行读取，可理解为读锁</li></ul><blockquote><p>锁的兼容性：如果两个事务能对一行数据同时加锁，就认为这个锁是兼容的，如果是要等待其他事务释放，则认为这2个锁是不兼容的。</p></blockquote><table><thead><tr><th>*</th><th>X</th><th>S</th></tr></thead><tbody><tr><td>X</td><td>不兼容</td><td>不兼容</td></tr><tr><td>S</td><td>不兼容</td><td>兼容</td></tr></tbody></table><h4 id="意向锁"><a class="markdownIt-Anchor" href="#意向锁"></a> 意向锁</h4><p>MySQL innodb 是支持多粒度锁的，比如可以同时存在表锁和行锁，为了更好的实现多粒度锁，innodb引入了意向锁，在innodb中的意向锁是表级的锁，意向锁与意向锁之间是兼容了，假如不存在表锁，不会有事务在加意向锁的时候阻塞。</p><ul><li>IS锁：意向共享锁，表明表中存在一行或者多行的S锁，即在给一行数据加S锁之前必在这个表加IS锁。</li><li>IX锁：意向排他锁，表明表中存在一行或者多行的X锁，即在给一行数据加S锁之前必在这个表加IX锁。</li></ul><blockquote><p>思考：为什么需要这个意向锁？</p></blockquote><p>我们比如思考一下这个场景，事务1给某个表中的N行加了行锁，这个时候事务2想给这个表加个表锁，那么事务2需要确认的事情有：</p><ol><li>这个表是否存在不兼容的表锁，比如我想加个X锁，但是已经有其他事务加了S锁。</li><li>这个表中是否已经存在不兼容的行锁。</li></ol><p>显然在确认第二个条件时，如果采用全表扫描的话，效率太低，所以意向锁的目的就是在粗粒度的锁（表锁）可以快速判断是否与低粒度的锁存在冲突。</p><table><thead><tr><th>*</th><th>IX</th><th>S</th><th>IS</th></tr></thead><tbody><tr><td>X</td><td>不兼容</td><td>不兼容</td><td>不兼容</td></tr><tr><td>IX</td><td>不兼容</td><td>兼容</td><td>不兼容</td></tr><tr><td>S</td><td>不兼容</td><td>不兼容</td><td>兼容</td></tr><tr><td>IS</td><td>不兼容</td><td>兼容</td><td>兼容</td></tr></tbody></table><h3 id="innodb行锁的形式或者算法"><a class="markdownIt-Anchor" href="#innodb行锁的形式或者算法"></a> innodb行锁的形式或者算法</h3><blockquote><p>Innodb中行锁都是加在索引上的，针对不同的场景都有不同的加锁策略。</p></blockquote><h4 id="record-lock"><a class="markdownIt-Anchor" href="#record-lock"></a> Record Lock</h4><p>记录锁，顾名思义就是锁住记录本身，锁主主键和唯一索引，如果表中没有加任何索引，锁会加在隐式生成的主键上。</p><h4 id="gap-lock"><a class="markdownIt-Anchor" href="#gap-lock"></a> Gap Lock</h4><p>间隙锁，当存在范围扫描的时候，给扫描范围加间隙锁，[起始地址，终止)</p><ol><li>不同事务对同一个区间加间隙锁是不冲突的，所以S Gap Lock 和 X Gap Lock不存在区别。</li><li>READ_COMMITED 隔离级别下不会启用间隙锁。</li></ol><h4 id="next-key-lock"><a class="markdownIt-Anchor" href="#next-key-lock"></a> Next Key Lock</h4><p>临键锁，Record Lock + Gap Lock ,锁主当前值区间+下一个区间(不一定)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10, 11, 13, 20</span><br><span class="line">(negative infinity, 10]</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, positive infinity)</span><br></pre></td></tr></table></figure><ol><li>解决的是当前读下的幻读问题。</li></ol><h4 id="insert-intention-lock"><a class="markdownIt-Anchor" href="#insert-intention-lock"></a> Insert Intention Lock</h4><p>插入意向锁，是一种特殊的间隙锁；insert之前会向插入区间加上Insert Intention Lock。</p><ol><li>Gap Lock / Next key Lock 与 Insert Intention Lock不兼容。</li><li>Gap lock 和Next key lock 的目的就是防止有数据插入间隙</li></ol><h3 id="不同sql产生的锁"><a class="markdownIt-Anchor" href="#不同sql产生的锁"></a> 不同SQL产生的锁</h3><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locks-set.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-locks-set.html</a></p><ol><li>SELECT…FROM</li></ol><blockquote><p>一致性非锁定读，除了在 SERIALIZABLE隔离级别下会存在S锁，其他隔离级别下都不会有锁。</p></blockquote><ol start="2"><li>SELECT…FOR UPDATE/SELECT…LOCK IN SHARE MODE</li></ol><blockquote><ul><li>也叫做当前读，会在给扫描过程中的索引加X或S锁，跟Where条件实际上没有强关系，只跟扫描的过程有关，所以where条件是否能够命中索引比较重要。</li><li>在检索的过程中会给用到的索引加Next Key Lock。不过如果检索条件是唯一索引能定位到一行数据，则只加Record Lock</li></ul></blockquote><ol start="3"><li>UPDATE…WHERE…</li></ol><blockquote><p>同样给检索到的记录加next key lock, 如果WHERE条件中是使用主键或者唯一索引进行限定的话，只在索引加了Record Lock。<br>如果UPDATE的是聚簇索引记录，会对受影响的辅助索引加隐式锁，当有新的辅助索引插入前的重复检测，以及在执行插入新的辅助索引记录时，对受影响的索引记录加S锁。</p></blockquote><ol start="4"><li>DELETE FROM … WHERE …</li></ol><blockquote><p>与UPDATE基本一致</p></blockquote><ol start="5"><li>INSERT</li></ol><blockquote><ul><li>给插入索引的记录加一个X锁</li><li>插入前前会加个Insert Intention Lock。</li><li>如果发生唯一键异常（duplicate-key error ），会在原记录上加S锁，这个如果和delete和update一起使用可能会导致死锁。</li></ul></blockquote><ol start="6"><li>INSERT … ON DUPLICATE KEY UPDATE</li></ol><blockquote><ul><li>跟INSERT语句有点不同的就是，当发生重复键异常是，这里加的是排他锁，而不是共享锁。</li><li>如果是唯一键异常，则加的是Next key lock。</li></ul></blockquote><ol start="7"><li>REPLACE</li></ol><blockquote><ul><li>如果没有发生冲突，则行为跟INSERT是一致的。</li><li>如果发生冲突，则对唯一键加的是Next key lock。</li></ul></blockquote><ol start="8"><li>INSERT INTO T SELECT … FROM S WHERE …</li></ol><blockquote><ul><li>给子查询语句加的X锁。</li><li>如果是READ COMMITED 隔离基本，则采用的是快照读</li></ul></blockquote><ol start="9"><li>外键约束</li></ol><blockquote><p>在进行外键约束检测时，会给记录加行级共享锁。</p></blockquote><h3 id="死锁"><a class="markdownIt-Anchor" href="#死锁"></a> 死锁</h3><blockquote><p>死锁是只当2个或者2个以上的事务抢占各自的资源，导致的相互等待的现象。</p></blockquote><h4 id="案例"><a class="markdownIt-Anchor" href="#案例"></a> 案例</h4><ol><li><a href="http://liaojiacan.me/2019/02/27/Insert-ignore-%E5%92%8Cupdate-%E5%AF%BC%E8%87%B4%E7%9A%84%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/">Insert-ignore-和update-导致的死锁问题分析</a></li></ol><h4 id="解决死锁和进行死锁检测"><a class="markdownIt-Anchor" href="#解决死锁和进行死锁检测"></a> 解决死锁和进行死锁检测</h4><ol><li>设置超时时间,事务有限时间超时,回滚其中一个事务。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;%innodb_lock_wait_timeout%&quot;;</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">| Variable_name            | Value |</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">| innodb_lock_wait_timeout | 50    |</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">1 row in set (0.07 sec)</span><br></pre></td></tr></table></figure><ol start="2"><li>wait-graph 等待图死锁检测</li></ol><ul><li>锁的信息链</li><li>事务等待链</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;锁的种类&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#锁的种类&quot;&gt;&lt;/a&gt; 锁的种类&lt;/h3&gt;
&lt;h4 id=&quot;表锁&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#表锁&quot;&gt;&lt;/a&gt; 表锁&lt;/h4&gt;
&lt;ul&gt;
      
    
    </summary>
    
      <category term="数据库" scheme="http://liaojiacan.me/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Innodb" scheme="http://liaojiacan.me/tags/Innodb/"/>
    
  </entry>
  
  <entry>
    <title>Insert ignore 和update 导致的死锁问题分析</title>
    <link href="http://liaojiacan.me/2019/02/27/Insert-ignore-%E5%92%8Cupdate-%E5%AF%BC%E8%87%B4%E7%9A%84%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <id>http://liaojiacan.me/2019/02/27/Insert-ignore-和update-导致的死锁问题分析/</id>
    <published>2019-02-27T12:13:00.000Z</published>
    <updated>2019-05-22T05:43:18.857Z</updated>
    
    <content type="html"><![CDATA[<h3 id="业务逻辑以及死锁现象"><a class="markdownIt-Anchor" href="#业务逻辑以及死锁现象"></a> 业务逻辑以及死锁现象</h3><p>业务逻辑大概如下：</p><ol><li>在粉丝表新增一条关系记录。</li><li>假如关注者也是当前用户的粉丝，则更新2者的标记为相互关注。</li></ol><p>业务代码如下, 最初是考虑用insert ignore 来解决幂等的问题，所以<strong>允许重复调用</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//是否 关注的用户是操作者的粉丝（互粉）</span><br><span class="line">boolean isHisFans = fansDao.isFans(fansUserId,followingUserId);</span><br><span class="line"></span><br><span class="line">//insert ignore into </span><br><span class="line">//  fans(fans_user_id,following_user_id,following_each_other)</span><br><span class="line">//values(#&#123;fansUserId&#125;, #&#123;followingUserId&#125;,#&#123;followingEachOther&#125;)</span><br><span class="line">int updateNum = fansDao.addFans(fansUserId, followingUserId,isHisFans);</span><br><span class="line"></span><br><span class="line">boolean addAndCheck = false;</span><br><span class="line"></span><br><span class="line">if(isHisFans)&#123;</span><br><span class="line">    // update fans</span><br><span class="line">// set following_each_other = #&#123;followingEachOther&#125;</span><br><span class="line">// where (fans_user_id = #&#123;fansUserId&#125; and following_user_id =  #&#123;followingUserId&#125; ) or (fans_user_id = #&#123;followingUserId&#125; and following_user_id = #&#123;fansUserId&#125; )</span><br><span class="line">int num = fansDao.setFollowingEachOther(followingUserId,fansUserId,true);</span><br><span class="line">if( num &gt;0 )&#123;</span><br><span class="line">//重新调整数据</span><br><span class="line">addAndCheck = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线上产生的死锁的信息(show engine innodb status)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">LATEST DETECTED DEADLOCK</span><br><span class="line">------------------------</span><br><span class="line">2019-02-12 23:24:45 7fa406a4f700</span><br><span class="line">*** (1) TRANSACTION:</span><br><span class="line">TRANSACTION 515545684, ACTIVE 0 sec starting index read</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">LOCK WAIT 3 lock struct(s), heap size 1184, 2 row lock(s)</span><br><span class="line">MySQL thread id 2121, OS thread handle 0x7fa406b12700, query id 1702086 10.10.17.63 jb-glive Searching rows for update</span><br><span class="line">update fans</span><br><span class="line">set following_each_other = 1</span><br><span class="line">where (fans_user_id = &apos;1776093&apos; and following_user_id = &apos;1331089&apos; ) or (fans_user_id = &apos;1331089&apos; and following_user_id = &apos;1776093&apos; )</span><br><span class="line">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 1023 page no 37913 n bits 400 index `UK_USER_ID` of table `glive`.`fans` trx id 515545684 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 334 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 7; hex 31333331303839; asc 1331089;;</span><br><span class="line"> 1: len 7; hex 31373736303933; asc 1776093;;</span><br><span class="line"> 2: len 8; hex 8000000001282c31; asc      (,1;;</span><br><span class="line"></span><br><span class="line">*** (2) TRANSACTION:</span><br><span class="line">TRANSACTION 515545683, ACTIVE 0 sec starting index read</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">5 lock struct(s), heap size 1184, 4 row lock(s)</span><br><span class="line">MySQL thread id 3485, OS thread handle 0x7fa406a4f700, query id 1702085 10.10.17.61 jb-glive Searching rows for update</span><br><span class="line">update fans</span><br><span class="line">set following_each_other = 1</span><br><span class="line">where (fans_user_id = &apos;1776093&apos; and following_user_id = &apos;1331089&apos; ) or (fans_user_id = &apos;1331089&apos; and following_user_id = &apos;1776093&apos; )</span><br><span class="line">*** (2) HOLDS THE LOCK(S):</span><br><span class="line">RECORD LOCKS space id 1023 page no 37913 n bits 400 index `UK_USER_ID` of table `glive`.`fans` trx id 515545683 lock_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 334 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 7; hex 31333331303839; asc 1331089;;</span><br><span class="line"> 1: len 7; hex 31373736303933; asc 1776093;;</span><br><span class="line"> 2: len 8; hex 8000000001282c31; asc      (,1;;</span><br><span class="line"></span><br><span class="line">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 1023 page no 38446 n bits 360 index `UK_USER_ID` of table `glive`.`fans` trx id 515545683 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 294 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 7; hex 31373736303933; asc 1776093;;</span><br><span class="line"> 1: len 7; hex 31333331303839; asc 1331089;;</span><br><span class="line"> 2: len 8; hex 8000000001282c59; asc      (,Y;;</span><br><span class="line"></span><br><span class="line">*** WE ROLL BACK TRANSACTION (1)</span><br></pre></td></tr></table></figure><p>锁分析：</p><ol><li>事务T2持有 (fans_user_id=1331089,following_user_id=1776093,主键=hex8000000001282c31) X 锁；</li><li>事务T2等待行锁<br>(fans_user_id=1776093,following_user_id=1331089,主键=hex8000000001282c59) X 锁；</li><li>事务T1等待T2持有的锁。</li><li>事务T1此时应该还持有T2等待的锁，只是没显示出来。</li></ol><blockquote><p>看起来就是典型的AB-BA问题</p></blockquote><h2 id="重现"><a class="markdownIt-Anchor" href="#重现"></a> 重现</h2><p>我们先简化上面的业务代码逻辑，假设fans_user_id=11000,following_user_id=10086，其实就是执行2个SQL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. insert ignore into fans(fans_user_id,following_user_id) values(11000,10086);</span><br><span class="line">2. update fans set following_each_other = 1</span><br><span class="line">where (fans_user_id = &apos;11000&apos; and following_user_id = &apos;10086&apos; ) </span><br><span class="line">or (fans_user_id = &apos;10086&apos; and following_user_id = &apos;11000&apos; );</span><br></pre></td></tr></table></figure><p>场景一：不存在fans_user_id=11000,following_user_id=10086的这条数据。</p><table><thead><tr><th>T1</th><th>T2</th></tr></thead><tbody><tr><td>&gt;begin;</td><td>&gt;begin;</td></tr><tr><td>insert ignore into fans(fans_user_id,following_user_id)<br> values(11000,10086);</td><td>*</td></tr><tr><td>*</td><td>insert ignore into fans(fans_user_id,following_user_id)<br> values(11000,10086); //阻塞</td></tr><tr><td>update fans<br> set following_each_other = 1 <br> where (fans_user_id = ‘11000’ and following_user_id = ‘10086’ ) <br> or (fans_user_id = ‘10086’ and following_user_id = ‘11000’ )</td><td>*</td></tr><tr><td>commit;</td><td>insert 语句开始执行</td></tr><tr><td>*</td><td>update fans<br> set following_each_other = 1 <br> where (fans_user_id = ‘11000’ and following_user_id = ‘10086’ ) <br> or (fans_user_id = ‘10086’ and following_user_id = ‘11000’ )</td></tr><tr><td>*</td><td>commit;</td></tr></tbody></table><blockquote><p>分析：</p><ol><li>由于数据库并没有这条记录，所以<strong>事务T1</strong>在执行insert ignore into 时可以执行成功，并给这行数据加了X锁。</li><li><strong>事务T2</strong>在执行insert ignore into 时由于获取不到行锁，直接阻塞。</li><li>后面都是顺序执行，所以并不会出现死锁的问题。</li></ol></blockquote><p>场景二：数据库已经存在fans_user_id=11000,following_user_id=10086的这条数据。</p><table><thead><tr><th>T1</th><th>T2</th></tr></thead><tbody><tr><td>&gt;begin;</td><td>&gt;begin;</td></tr><tr><td>insert ignore into fans(fans_user_id,following_user_id)<br> values(11000,10086);</td><td>*</td></tr><tr><td>*</td><td>insert ignore into fans(fans_user_id,following_user_id)<br> values(11000,10086); //执行成功</td></tr><tr><td>update fans<br> set following_each_other = 1 <br> where (fans_user_id = ‘11000’ and following_user_id = ‘10086’ ) <br> or (fans_user_id = ‘10086’ and following_user_id = ‘11000’ )</td><td>*</td></tr><tr><td>阻塞等待</td><td>*</td></tr><tr><td>*</td><td>update fans<br> set following_each_other = 1 <br> where (fans_user_id = ‘11000’ and following_user_id = ‘10086’ ) <br> or (fans_user_id = ‘10086’ and following_user_id = ‘11000’ )</td></tr><tr><td>*</td><td>Deadlock found when trying to get lock; <br>try restarting transaction</td></tr></tbody></table><blockquote><p>分析：</p><ol><li>由于数据库已经存在该记录，所以事务T1执行insert ignore into 会插入失败，并给该记录加了个S锁。</li><li>由于S锁是相互兼容的，所以事务T2也给该记录加了S锁。</li><li>T1继续执行update语句，尝试给2行数据加X锁，但是其中有一行数据已经被T2加了S锁，此时T1回到等待队列中继续等待。</li><li>T2继续执行update语句，尝试给2行数据加X锁，但是发现T1已经对这2行数据请求了X锁，且在等待T2释放S锁，而T1又因为T2不释放S锁而无法升级为X锁。</li></ol><p>可以参考mysql官方的例子，原理是一样的。<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-deadlock-example.html" target="_blank" rel="noopener">innodb-死锁例子</a></p></blockquote><p>下面是场景二的DEADLOCK信息（show engine innodb status），你会发现其实跟生产环境的锁是又区别的，线上的死锁信息中T2 持有的是一个X锁（这个不知道怎么解释，无法重现）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">LATEST DETECTED DEADLOCK</span><br><span class="line">------------------------</span><br><span class="line">2019-02-27 14:15:00 0x7000034b5000</span><br><span class="line">*** (1) TRANSACTION:</span><br><span class="line">TRANSACTION 620686, ACTIVE 19 sec starting index read</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">LOCK WAIT 5 lock struct(s), heap size 1136, 4 row lock(s)</span><br><span class="line">MySQL thread id 63, OS thread handle 123145355350016, query id 1172740 localhost 127.0.0.1 root updating</span><br><span class="line">update fans</span><br><span class="line">set following_each_other = 1</span><br><span class="line">where (fans_user_id = &apos;11000&apos; and following_user_id = &apos;10086&apos; ) or (fans_user_id = &apos;10086&apos; and following_user_id = &apos;11000&apos; )</span><br><span class="line">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 107 page no 7 n bits 624 index UK_USER_ID of table `test`.`fans` trx id 620686 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 280 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 5; hex 3131303030; asc 11000;;</span><br><span class="line"> 1: len 5; hex 3130303836; asc 10086;;</span><br><span class="line"> 2: len 8; hex 800000000143abeb; asc      C  ;;</span><br><span class="line"></span><br><span class="line">*** (2) TRANSACTION:</span><br><span class="line">TRANSACTION 620687, ACTIVE 16 sec starting index read</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">3 lock struct(s), heap size 1136, 2 row lock(s)</span><br><span class="line">MySQL thread id 61, OS thread handle 123145357578240, query id 1172741 localhost 127.0.0.1 root updating</span><br><span class="line">update fans</span><br><span class="line">set following_each_other = 1</span><br><span class="line">where (fans_user_id = &apos;11000&apos; and following_user_id = &apos;10086&apos; ) or (fans_user_id = &apos;10086&apos; and following_user_id = &apos;11000&apos; )</span><br><span class="line">*** (2) HOLDS THE LOCK(S):</span><br><span class="line">RECORD LOCKS space id 107 page no 7 n bits 624 index UK_USER_ID of table `test`.`fans` trx id 620687 lock mode S</span><br><span class="line">Record lock, heap no 280 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 5; hex 3131303030; asc 11000;;</span><br><span class="line"> 1: len 5; hex 3130303836; asc 10086;;</span><br><span class="line"> 2: len 8; hex 800000000143abeb; asc      C  ;;</span><br><span class="line"></span><br><span class="line">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 107 page no 7 n bits 624 index UK_USER_ID of table `test`.`fans` trx id 620687 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 279 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 5; hex 3130303836; asc 10086;;</span><br><span class="line"> 1: len 5; hex 3131303030; asc 11000;;</span><br><span class="line"> 2: len 8; hex 800000000143abdb; asc      C  ;;</span><br><span class="line"></span><br><span class="line">*** WE ROLL BACK TRANSACTION (2)</span><br></pre></td></tr></table></figure><h2 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h2><p>在这个案例中，发生死锁的原因主要是insert ignore 在数据已经存在时只是加了S锁。所以解决的办法其实又几个。</p><ol><li>使用其他的幂等处理办法，不要依赖insert ignore。在这个案例中，其实应该直接使用insert，不允许重复执行，可以捕获唯一key异常来获取updateNum进行下个业务处理。</li><li>直接在业务开头使用select for … update 来加排他锁保证业务是串形执行（只是从死锁这个问题考虑，如果考虑性能需要找其他方案）。</li><li>假如就非得使用insert ignore 和 update，那么我们可以考虑在这个业务加个重试，数据库的死锁并不是致命的，设置好数据库的事物超时时间，然后遇到死锁问题，我们可以在业务进行重试解决。</li></ol><h2 id="未分析清楚的点"><a class="markdownIt-Anchor" href="#未分析清楚的点"></a> 未分析清楚的点</h2><ol><li>为什么线上的锁他是一个X锁，并不是一个S锁？是否有场景三？MySQL官方文档有一段话，感觉有点关联，但是无法对应上现象,说的是insert 和 delete 语句其实并不是真正原子的行锁。</li></ol><blockquote><p>InnoDB uses automatic row-level locking. You can get deadlocks even in the case of transactions that just insert or delete a single row. That is because these operations are not really “atomic”; they automatically set locks on the (possibly several) index records of the row inserted or deleted.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;业务逻辑以及死锁现象&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#业务逻辑以及死锁现象&quot;&gt;&lt;/a&gt; 业务逻辑以及死锁现象&lt;/h3&gt;
&lt;p&gt;业务逻辑大概如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在粉丝表新增一条关系记录。&lt;/li&gt;
&lt;li&gt;假如
      
    
    </summary>
    
      <category term="死锁" scheme="http://liaojiacan.me/categories/%E6%AD%BB%E9%94%81/"/>
    
    
      <category term="MySQL" scheme="http://liaojiacan.me/tags/MySQL/"/>
    
      <category term="innodb" scheme="http://liaojiacan.me/tags/innodb/"/>
    
  </entry>
  
  <entry>
    <title>JDK1.7 ConcurrentHashMap的源码解读</title>
    <link href="http://liaojiacan.me/2019/02/26/JDK1-7-ConcurrentHashMap%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>http://liaojiacan.me/2019/02/26/JDK1-7-ConcurrentHashMap的源码解读/</id>
    <published>2019-02-26T03:18:00.000Z</published>
    <updated>2019-05-22T05:43:18.858Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-concurrenthashmap的数据结构jdk7"><a class="markdownIt-Anchor" href="#一-concurrenthashmap的数据结构jdk7"></a> 一、 ConcurrentHashMap的数据结构(JDK7)。</h3><ol><li>segments[] : Segment&lt;K,V&gt; extends ReentrantLock</li></ol><blockquote><p><strong>分段锁</strong>，HashMap 用一个Entry[] table 去存数据，ConcurrentHashMap 则是将 这个table 拆分出 n 个段（一个最接近concurrencyLevel的2的幂）分别存储，Segment 中的 用一个HashEntry table[] 来存数据，table中hash冲突的解决算法基本与HashMap一致。同一个段的put和get操作是需要加锁的，Segment继承了ReentrantLock 故有了锁的功能。</p></blockquote><ol start="2"><li>concurrencyLevel : int</li></ol><blockquote><p><strong>并发等级</strong>，默认是16，可以在构造函数指定该值，这个值直接影响segment数组的大小。如果这个值不是2的幂，则会计算出一个最接近（向上取）的2的幂来初始化segments数组。</p></blockquote><ol start="3"><li>segmentMask : int</li></ol><blockquote><p><strong>掩码</strong>，是一个bit位都是1的数，跟segments的长度有关，比如默认segments的长度是16=2的4次方（二进制为10000）。假如我们需要获取到一个数落在[0,16) 这个区间，则只需要用这个数跟1111做与运算, 得到的结果肯定是落在0到16之间，这个比取模运算更加高效。</p></blockquote><ol start="4"><li>segmentShift : int</li></ol><blockquote><p><strong>位移数</strong>，获取高ssize(segments size)位需要的左移的位数（32-ssize），hash函数算出来的是一个32 位int的整型，ConcurrentHashMap对segments的hash算法采用的是一个取高位进行hash的做法。比如一个key算出来的值为1024，如果我想取高ssize位 ，假如ssize为4，那么就要将1024&gt;&gt;&gt;(32-4)，取得高4位。获取到高4位后会与segmentMask进行与运算获取到一个[0,ssize)的数。这就是ConcurrentHashMap中对segment采用的hash算法。</p></blockquote><ul><li>为什么要采用高位运算？</li></ul><blockquote><p>源码中似乎没有说明，我猜是为了跟segment中的HashEntry[] table 的hash算法区分开来，降低冲突的概率。假如采用同样的hash算法，有2个key Hash到同一个segment中那么再进行 段中的二次hash的时候可能还是命中到同一个节点导致链越来越长。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// segment[] 的hash算法 （hash的高位参与运算）</span><br><span class="line"> int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">// table[] 的hash算法 （hash的低位参与运算）</span><br><span class="line"> int index = (tab.length - 1) &amp; hash;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/liaojiacan/assets/blob/master/issue/ConcurrentHashMap_jdk1.7.png?raw=true" alt="image"></p><h3 id="二-segment中独占锁的加锁逻辑"><a class="markdownIt-Anchor" href="#二-segment中独占锁的加锁逻辑"></a> 二、segment中独占锁的加锁逻辑</h3><blockquote><p>分段锁的目的就是将锁冲突分离开，只有hash到同一个segment中的操作才会存在锁竞争，CurrentHashMap 中put和remove以及size是有加锁操作的。</p></blockquote><p>put操作加锁</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashEntry&lt;K,V&gt; node = tryLock() ? null :scanAndLockForPut(key, hash, value);</span><br></pre></td></tr></table></figure><p>reomve操作加锁</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (!tryLock())</span><br><span class="line">   scanAndLock(key, hash);</span><br></pre></td></tr></table></figure><p>如果 tryLock() 不能能加锁成功则进行自旋，scanAndLockForPut和scanAndLock有点区别但是逻辑差不多。</p><p>1.有限重试次数，多核心CPU的话是64次，单核1次，超过次数则阻塞等待获取锁。</p><p>2.获取锁之前和获取到锁期间头节点不能发生改变，否则需要从头开始重试。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void scanAndLock(Object key, int hash) &#123;</span><br><span class="line">    // similar to but simpler than scanAndLockForPut</span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(this, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    int retries = -1;</span><br><span class="line">    while (!tryLock()) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; f;</span><br><span class="line">        if (retries &lt; 0) &#123;</span><br><span class="line">            if (e == null || key.equals(e.key))</span><br><span class="line">                retries = 0;</span><br><span class="line">            else</span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果头节点发生改变，从头开始扫描</span><br><span class="line">        else if ((retries &amp; 1) == 0 &amp;&amp;</span><br><span class="line">                 (f = entryForHash(this, hash)) != first) &#123;</span><br><span class="line">            e = first = f;</span><br><span class="line">            retries = -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>get没有加排他锁，是否有线程安全问题？</li></ul><p>先说下结论，ConcurrentHashMap get方法不存在线程安全问题，他的线程安全是由CAS 和 &quot;volatile&quot;保证的:</p><pre><code>1. UNSAFE.putOrderedObject/UNSAFE.getObjectVolatile2. volatile HashEntry&lt;K,V&gt; next;3. volatile V value;</code></pre><p>我们整理下，要保证get不发生线程安全问题需要保证什么？</p><pre><code>1. get操作和put或remove操作并行的时候，get能操作能够获取到正确的segment和头节点table[i]。2. 在entries的遍历中能顺利走到未节点。3. 在1和2的前提下get操作时能够保证value值的可见性。</code></pre><p>我们先看第1点时怎么保证的，我们都知道java中有个volatile用了保证变量在多线程下的可见性，volatile可以保证可见性，但是不能保证线程安全，如果当前赋值语句依赖当前值时是线程不安全的，比如a +=1 这种操作就是不安全的，显然在ConcurrentHashMap的并不需要这种操作，只存在简单的引用赋值操作。</p><p>但是需要注意的是一点，volatile修饰引用型变量时，只能保证当前引用的可见性，对于引用对象的内部变量仍然是无法保证可见性的，这就是为什么在对segments[] 数组和table[] 数组的的操作需要借助Unsafe类，而不是直接segments[i] = new Segment(…);</p><p>由前面的分析看，volatile/Unsafe.getObjectVolatile/Unsafe.putOrderedOject保证链当get操作晚与put操作时是可以获取到刚插入的节点(作为一个新头节点连接到旧节点并更新table)，对与一个早于put操作的get操作一个情况就是新插入的元素表头，但是get操作已经获取到了旧表头，所以并不影响get操作进行链表的遍历查找。</p><p>我们在看进行remove时是否会影响entries的遍历，从源码中看，HashEntry中的next成员是被volatile修饰的，这就保证了get可以安全得遍历到未节点。</p><h3 id="三-size的实现逻辑"><a class="markdownIt-Anchor" href="#三-size的实现逻辑"></a> 三、size的实现逻辑</h3><p>  假如ConcurrentHashMap采用HashMap维护一个全局的size来变量统计大小，那么为了线程安全，也必定得改用原子类AtomicLong或者全局加锁。这显然与分段锁的设计背离。那么有没有一种比较折衷的办法呢？</p><p>  ConcurrentHashMap中将size的统计拆分到各个segment取去护，每次执行size的时候将每个segment的count加起来，最终得到的结果就是map的大小。这个看似乎很合理，但是如果在进行统计的过程中有一个segment发生put或者remove操作呢，这样得到的结果就是错误的，显然我们可以在统计前先将每个segment给锁起来，再sum，得到的结果肯定是正确的。</p><p>  <strong>存在一种情况就是你的程序中并发很少，出现并发更新的情况很少，这个时候你执行size的时候将所有的segment加锁和不加锁的情况可能得到的结果是一样的，因为这个时候没有其他线程进行修改。似乎我们可以乐观地考虑一下大部分情况下是不需要进行锁操作的。</strong></p><p>  Doug Lea采用类一种跟JDK集合类中大多数存在的fail-safe错误检查机制，对在每个segment中于更新操作维护一个modCount来记录更新的次数，统计前和统计后的modCount是一样的说明没有发生变化，当前的统计结果有效。ConcurrentHashMap的size方法的实现逻辑如下：</p><ul><li>先采用无锁的方式统计2次，如果前后的modCount总和是一样的，此次统计结果有效，返回结果。</li><li>假如前后的modCount总和不一样，第三次进行有锁的统计。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public int size() &#123;</span><br><span class="line">        // Try a few times to get accurate count. On failure due to</span><br><span class="line">        // continuous async changes in table, resort to locking.</span><br><span class="line">        final Segment&lt;K,V&gt;[] segments = this.segments;</span><br><span class="line">        int size;</span><br><span class="line">        boolean overflow; // true if size overflows 32 bits</span><br><span class="line">        long sum;         // sum of modCounts</span><br><span class="line">        long last = 0L;   // previous sum</span><br><span class="line">        int retries = -1; // first iteration isn&apos;t retry</span><br><span class="line">        try &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                //第三次进行上锁</span><br><span class="line">                if (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                    for (int j = 0; j &lt; segments.length; ++j)</span><br><span class="line">                        ensureSegment(j).lock(); // force creation</span><br><span class="line">                &#125;</span><br><span class="line">                sum = 0L;</span><br><span class="line">                size = 0;</span><br><span class="line">                overflow = false;</span><br><span class="line">                for (int j = 0; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                    Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                    if (seg != null) &#123;</span><br><span class="line">                        sum += seg.modCount;</span><br><span class="line">                        int c = seg.count;</span><br><span class="line">                        if (c &lt; 0 || (size += c) &lt; 0)</span><br><span class="line">                            overflow = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // 前后2次的统计结果一致，可以返回</span><br><span class="line">                if (sum == last)</span><br><span class="line">                    break;</span><br><span class="line">                last = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                for (int j = 0; j &lt; segments.length; ++j)</span><br><span class="line">                    segmentAt(segments, j).unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="四-unsafegetobjectvolatileunsafeputorderedoject对偏移量的计算问题"><a class="markdownIt-Anchor" href="#四-unsafegetobjectvolatileunsafeputorderedoject对偏移量的计算问题"></a> 四、Unsafe.getObjectVolatile/Unsafe.putOrderedOject对偏移量的计算问题</h3><p>  ConcurrentHashMap中使用量Unsafe类来对segment数组和table数组进行数组填充和取值操作，其中对位置i的内存偏移计算用了位运算来代替乘法运算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// segment[0] 的偏移地址</span><br><span class="line">int baseOffset = UNSAFE.arrayBaseOffset(Segment[].class);</span><br><span class="line">// 每个位置的大小</span><br><span class="line">int indexScale = UNSAFE.arrayIndexScale(Segment[].class);</span><br><span class="line">//那么第i个元素的内存偏移就是</span><br><span class="line">long offset = baseOffset+i*indexScale ;</span><br></pre></td></tr></table></figure><p>上面的计算方法是利用乘法来计算的，但是乘法的计算还是比较慢的，如果能用位运算更佳。由于jvm给对象分配内存的时候会进行内存对对齐，也就是说indexScale其实会是一个2的n次方的数。一个整数i乘以一个2的n次方可以转化成 i&lt;&lt;n;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">3 * 2 = 3 &lt;&lt; 1</span><br><span class="line">3 * 4 = 3 &lt;&lt; 2</span><br><span class="line">3 * 8 = 3 &lt;&lt; 3</span><br><span class="line">3 * 16 = 3 &lt;&lt; 4</span><br><span class="line">3 * 32 = 3 &lt;&lt; 5</span><br><span class="line">3 * 64 = 3 &lt;&lt; 6</span><br><span class="line">3 * 128 = 3 &lt;&lt; 7</span><br><span class="line">3 * 256 = 3 &lt;&lt; 8</span><br></pre></td></tr></table></figure><p>所以你会看到ConcurrentHashMap中有这样的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 31 - Integer.numberOfLeadingZeros(ssize) 这个是求一个数x的2对数 </span><br><span class="line"> SSHIFT = 31 - Integer.numberOfLeadingZeros(ssize);</span><br><span class="line"> ...</span><br><span class="line"> // 所以元素i在内存中的偏移就是</span><br><span class="line"> long offset = SBASE +(i&lt;&lt;SSHIFT)</span><br></pre></td></tr></table></figure><p><a href="https://github.com/liaojiacan/code-snippets/blob/master/java-language/src/main/java/com/github/liaojiacan/unsafe/UnsafeArrayOperationTests.java" target="_blank" rel="noopener">测试用例-ConcurrentHashMap中利用Unsafe进行数组操作的测试用例</a>;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-concurrenthashmap的数据结构jdk7&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-concurrenthashmap的数据结构jdk7&quot;&gt;&lt;/a&gt; 一、 ConcurrentHashMap的数据结构(JDK7)
      
    
    </summary>
    
      <category term="源码解读" scheme="http://liaojiacan.me/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="JDK" scheme="http://liaojiacan.me/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/JDK/"/>
    
    
      <category term="J.U.C" scheme="http://liaojiacan.me/tags/J-U-C/"/>
    
      <category term="ConcurrentHashMap" scheme="http://liaojiacan.me/tags/ConcurrentHashMap/"/>
    
  </entry>
  
  <entry>
    <title>谈谈多语言设计（三）Spring-i18n 拓展之自定义MessageSource</title>
    <link href="http://liaojiacan.me/2018/04/13/%E8%B0%88%E8%B0%88%E5%A4%9A%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%89%EF%BC%89Spring-i18n-%E6%8B%93%E5%B1%95%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89MessageSource/"/>
    <id>http://liaojiacan.me/2018/04/13/谈谈多语言设计（三）Spring-i18n-拓展之自定义MessageSource/</id>
    <published>2018-04-13T08:08:00.000Z</published>
    <updated>2019-05-22T05:43:18.862Z</updated>
    
    <content type="html"><![CDATA[<p>  Spring框架中有两个MessageSource的实现，分别是ResourceBundleMessageSource和ReloadableResourceBundleMessageSource，前者第一次初始化就固定下来，后者可以根据配置文件是否发生变进行更新。</p><p>  对于Web网页（UI上的文案），这种配置在配置文件的方式是可以接受的，因为一般这些文案都是固定的。但是对于一些需要动态新增配置的场景显然就是不适合了，比如商品信息，抽奖的奖品，直播间的道具，礼物等，这些都是根据运营人员需要动态调整的，显然需要把配置存储在数据库中。</p><p>  在写这部分的实现的时候，参考了一个开源项目，<a href="https://github.com/synyx/messagesource" target="_blank" rel="noopener">https://github.com/synyx/messagesource</a>。<br>感兴趣的同学，可以在我的Github查看完整的代码。<a href="https://github.com/liaojiacan/spring-i18n-support" target="_blank" rel="noopener">https://github.com/liaojiacan/spring-i18n-support</a></p><h2 id="uml"><a class="markdownIt-Anchor" href="#uml"></a> UML</h2><p><img src="/images/pasted-3.png" alt="upload successful"></p><h2 id="关于messagesourceprovider"><a class="markdownIt-Anchor" href="#关于messagesourceprovider"></a> 关于MessageSourceProvider</h2><p>   在MessageSource的实现中 ，抽出一个Provider层将存储介质解耦，可以在最后的应用中，选择使用JDBC还是Redis还是远程的配置服务中心的实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface MessageSourceProvider &#123;</span><br><span class="line"></span><br><span class="line">List&lt;MessageEntry&gt; load();</span><br><span class="line"></span><br><span class="line">int addMessage(Locale locale,String code,String type,String message);</span><br><span class="line"></span><br><span class="line">int updateMessage(Locale locale,String code,String type,String message);</span><br><span class="line"></span><br><span class="line">int deleteMessage(Locale locale,String code);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="jdbcmessagesoucreprovider"><a class="markdownIt-Anchor" href="#jdbcmessagesoucreprovider"></a> JdbcMessageSoucreProvider</h2><p>   因为只是简单的对数据进行CURD，所以采用JdbcTemple的方式减少相关的依赖，采用java原生的jdbc也是可以的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- ----------------------------</span><br><span class="line">-- Table structure for i18n_message</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP TABLE IF EXISTS `i18n_message`;</span><br><span class="line">CREATE TABLE `i18n_message` (</span><br><span class="line">  `code` varchar(250) NOT NULL COMMENT &apos;mapping code&apos;,</span><br><span class="line">  `locale` varchar(100) NOT NULL COMMENT &apos;language tag&apos;,</span><br><span class="line">  `type` varchar(100) DEFAULT NULL COMMENT &apos;type for group&apos;,</span><br><span class="line">  `message` text NOT NULL COMMENT &apos;message content&apos;,</span><br><span class="line">  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT &apos;create time&apos;,</span><br><span class="line">  `update_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &apos;last modify time&apos;,</span><br><span class="line">  PRIMARY KEY (`code`,`locale`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;i18n message data&apos;;</span><br><span class="line"></span><br><span class="line">SET FOREIGN_KEY_CHECKS = 1;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">public class JdbcMessageSoucreProvider implements MessageSourceProvider &#123;</span><br><span class="line"></span><br><span class="line">private JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">protected static final String QUERY_TPL_INSERT_MESSAGE_ENTRY =</span><br><span class="line">&quot;INSERT INTO %s (%s, %s, %s, %s) VALUES (?, ?, ?, ?)&quot;;</span><br><span class="line">protected static final String QUERY_TPL_DELETE_MESSAGE_ENTRY = &quot;DELETE FROM %s WHERE %s = ? and %s= ?&quot;;</span><br><span class="line">protected static final String QUERY_TPL_SELECT_MESSAGE_ENTRIES = &quot;SELECT %s,%s,%s,%s FROM %s&quot;;</span><br><span class="line">protected static final String QUERY_TPL_UPDATE_MESSAGE_ENTRY = &quot;UPDATE %s set %s=?,%s=?,%s=? WHERE %s=? and %s=?&quot;;</span><br><span class="line"></span><br><span class="line">private String localeColumn = &quot;locale&quot;;</span><br><span class="line">private String typeColumn = &quot;type&quot;;</span><br><span class="line">private String codeColumn = &quot;code&quot;;</span><br><span class="line">private String messageColumn = &quot;message&quot;;</span><br><span class="line">private String tableName = &quot;i18n_message&quot;;</span><br><span class="line">private String delimiter = &quot;`&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public List&lt;MessageEntry&gt; load() &#123;</span><br><span class="line">// @formatter:off</span><br><span class="line">String sql = String.format(getQueryTplSelectMessageEntries(),</span><br><span class="line">addDelimiter(getCodeColumn()),</span><br><span class="line">addDelimiter(getLocaleColumn()),</span><br><span class="line">addDelimiter(getTypeColumn()),</span><br><span class="line">addDelimiter(getMessageColumn()),</span><br><span class="line">addDelimiter(getTableName()));</span><br><span class="line">return jdbcTemplate.query(sql,new BeanPropertyRowMapper(MessageEntry.class));</span><br><span class="line">// @formatter:on</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int addMessage(Locale locale, String code, String type, String message) &#123;</span><br><span class="line">// @formatter:off</span><br><span class="line">String sql = String.format(getQueryTplInsertMessageEntry(),</span><br><span class="line">addDelimiter(getTableName()),</span><br><span class="line">addDelimiter(getLocaleColumn()),</span><br><span class="line">addDelimiter(getCodeColumn()),</span><br><span class="line">addDelimiter(getTypeColumn()),</span><br><span class="line">addDelimiter(getMessageColumn()));</span><br><span class="line">// @formatter:on</span><br><span class="line">return jdbcTemplate.update(sql,locale.toLanguageTag(),code,type,message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int updateMessage(Locale locale, String code, String type, String message) &#123;</span><br><span class="line">// @formatter:off</span><br><span class="line">String sql = String.format(getQueryTplUpdateMessageEntry(),</span><br><span class="line">addDelimiter(getTableName()),</span><br><span class="line">addDelimiter(getLocaleColumn()),</span><br><span class="line">addDelimiter(getTypeColumn()),</span><br><span class="line">addDelimiter(getMessageColumn()),</span><br><span class="line">addDelimiter(getCodeColumn()),addDelimiter(getLocaleColumn()));</span><br><span class="line">// @formatter:on</span><br><span class="line">return jdbcTemplate.update(sql,locale.toLanguageTag(),type,message,code,locale.toLanguageTag());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int deleteMessage(Locale locale, String code) &#123;</span><br><span class="line">String sql = String.format(getQueryTplDeleteMessageEntry(),addDelimiter(getTableName()),addDelimiter(getCodeColumn()),addDelimiter(getLocaleColumn()));</span><br><span class="line">return jdbcTemplate.update(sql,code,locale.toLanguageTag());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Method that &quot;wraps&quot; a field-name (or table-name) into the delimiter.</span><br><span class="line"> * @param name the name of the field/table</span><br><span class="line"> * @return the wrapped field/table</span><br><span class="line"> */</span><br><span class="line">protected String addDelimiter(String name) &#123;</span><br><span class="line">return String.format(&quot;%s%s%s&quot;, delimiter, name, delimiter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public JdbcTemplate getJdbcTemplate() &#123;</span><br><span class="line">return jdbcTemplate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;</span><br><span class="line">this.jdbcTemplate = jdbcTemplate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static String getQueryTplInsertMessageEntry() &#123;</span><br><span class="line">return QUERY_TPL_INSERT_MESSAGE_ENTRY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static String getQueryTplDeleteMessageEntry() &#123;</span><br><span class="line">return QUERY_TPL_DELETE_MESSAGE_ENTRY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static String getQueryTplSelectMessageEntries() &#123;</span><br><span class="line">return QUERY_TPL_SELECT_MESSAGE_ENTRIES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static String getQueryTplUpdateMessageEntry() &#123;</span><br><span class="line">return QUERY_TPL_UPDATE_MESSAGE_ENTRY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getLocaleColumn() &#123;</span><br><span class="line">return localeColumn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setLocaleColumn(String localeColumn) &#123;</span><br><span class="line">this.localeColumn = localeColumn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getTypeColumn() &#123;</span><br><span class="line">return typeColumn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setTypeColumn(String typeColumn) &#123;</span><br><span class="line">this.typeColumn = typeColumn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getCodeColumn() &#123;</span><br><span class="line">return codeColumn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setCodeColumn(String codeColumn) &#123;</span><br><span class="line">this.codeColumn = codeColumn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getMessageColumn() &#123;</span><br><span class="line">return messageColumn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setMessageColumn(String messageColumn) &#123;</span><br><span class="line">this.messageColumn = messageColumn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getTableName() &#123;</span><br><span class="line">return tableName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setTableName(String tableName) &#123;</span><br><span class="line">this.tableName = tableName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getDelimiter() &#123;</span><br><span class="line">return delimiter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setDelimiter(String delimiter) &#123;</span><br><span class="line">this.delimiter = delimiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="refreshablemessagesource"><a class="markdownIt-Anchor" href="#refreshablemessagesource"></a> RefreshableMessageSource</h2><p>  RefreshableMessageSource的实现相对简单，在初始化的时候将MessageSourceProvider的数据解析成MessageFormat存在Map中，解析的时候根据code和locale索引到对应的MessageFormat。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author liaojiacan https://github.com/liaojiacan</span><br><span class="line"> */</span><br><span class="line">public class RefreshableMessageSource extends AbstractMessageSource implements Refreshable,InitializingBean&#123;</span><br><span class="line"></span><br><span class="line">private MessageSourceProvider provider;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Setting : return origin code when the message not found.</span><br><span class="line"> */</span><br><span class="line">protected Boolean returnUnresolvedCode = false;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The MessageFormat cache</span><br><span class="line"> */</span><br><span class="line">private Map&lt;String,Map&lt;Locale,MessageFormat&gt;&gt; messageEntryMap = Collections.emptyMap();</span><br><span class="line"></span><br><span class="line">public RefreshableMessageSource(MessageSourceProvider provider) &#123;</span><br><span class="line">this.provider = provider;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void refresh()&#123;</span><br><span class="line">List&lt;MessageEntry&gt; messageEntries = provider.load();</span><br><span class="line">if(!CollectionUtils.isEmpty(messageEntries))&#123;</span><br><span class="line">final Map&lt;String,Map&lt;Locale,MessageFormat&gt;&gt; finalMap = new HashMap&lt;&gt;();</span><br><span class="line">messageEntries.forEach(messageEntry -&gt; &#123;</span><br><span class="line">String code  = messageEntry.getCode();</span><br><span class="line">Locale locale = Locale.forLanguageTag(messageEntry.getLocale());</span><br><span class="line">Map&lt;Locale, MessageFormat&gt; localeMapping = finalMap.get(code);</span><br><span class="line">if(localeMapping == null)&#123;</span><br><span class="line">localeMapping = new HashMap&lt;&gt;();</span><br><span class="line">finalMap.put(code,localeMapping);</span><br><span class="line">&#125;</span><br><span class="line">localeMapping.put(locale,createMessageFormat(messageEntry.getMessage(),locale));</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">messageEntryMap = finalMap;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected MessageFormat resolveCode(String code, Locale locale) &#123;</span><br><span class="line">Map&lt;Locale, MessageFormat&gt; localeMessageMap = messageEntryMap.get(code);</span><br><span class="line">if(localeMessageMap != null )&#123;</span><br><span class="line">MessageFormat mf = localeMessageMap.get(locale);</span><br><span class="line">if(mf!=null)&#123;</span><br><span class="line">return  mf;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(returnUnresolvedCode)&#123;</span><br><span class="line">return createMessageFormat(code,locale);</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">this.refresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public MessageSourceProvider getProvider() &#123;</span><br><span class="line">return provider;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setProvider(MessageSourceProvider provider) &#123;</span><br><span class="line">this.provider = provider;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Boolean getReturnUnresolvedCode() &#123;</span><br><span class="line">return returnUnresolvedCode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setReturnUnresolvedCode(Boolean returnUnresolvedCode) &#123;</span><br><span class="line">this.returnUnresolvedCode = returnUnresolvedCode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  Spring框架中有两个MessageSource的实现，分别是ResourceBundleMessageSource和ReloadableResourceBundleMessageSource，前者第一次初始化就固定下来，后者可以根据配置文件是否发生变进行更新。&lt;/p
      
    
    </summary>
    
      <category term="架构总结" scheme="http://liaojiacan.me/categories/%E6%9E%B6%E6%9E%84%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="多语言" scheme="http://liaojiacan.me/tags/%E5%A4%9A%E8%AF%AD%E8%A8%80/"/>
    
      <category term="i18n" scheme="http://liaojiacan.me/tags/i18n/"/>
    
  </entry>
  
  <entry>
    <title>Idea使用骨架生成项目卡住的解决办法</title>
    <link href="http://liaojiacan.me/2018/03/09/Idea%E4%BD%BF%E7%94%A8%E9%AA%A8%E6%9E%B6%E7%94%9F%E6%88%90%E9%A1%B9%E7%9B%AE%E5%8D%A1%E4%BD%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://liaojiacan.me/2018/03/09/Idea使用骨架生成项目卡住的解决办法/</id>
    <published>2018-03-09T11:01:00.000Z</published>
    <updated>2019-05-22T05:43:18.856Z</updated>
    
    <content type="html"><![CDATA[<p>  Idea在使用骨架生成项目时（Create from archetype）有时候会发现卡住了，控制台停留在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Generating project in Batch mode</span><br></pre></td></tr></table></figure><p>通过debug日志发现是搜索archetype-catalog.xml卡住了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Generating project in Batch mode</span><br><span class="line">[DEBUG] Searching for remote catalog: http://repo.maven.apache.org/maven2/archetype-catalog.xml</span><br></pre></td></tr></table></figure><p>解决方法：</p><p>   修改archetypeCatalog参数，archetypeCatalog=internal。Idea可以在maven的runner配置中指定。如图：</p><p><img src="/images/pasted-2.png" alt="upload successful"></p><p>archetypeCatalog参数取值可以从maven的文档查到.<a href="http://maven.apache.org/archetype/maven-archetype-plugin/examples/generate-alternative-catalog.html" target="_blank" rel="noopener">Generate project using an alternative catalog<br></a></p><p>archetypeCatalog 可配置的值有</p><ul><li>internal to use the internal catalog only.</li><li>local to use the local catalog only.</li><li>remote to use the maven’s remote catalog.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">No catalog is currently provided.</span><br><span class="line">The default value is remote,local. Thus the local catalog is shown just after the remote one.</span><br></pre></td></tr></table></figure><p>默认是remote,local. 这里解决方法其实有两个，<br>一个就是上面所说修改archetypeCatalog=internal,直接使用网络。另外一个就是修改远程仓库，如使用阿里的镜像。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  Idea在使用骨架生成项目时（Create from archetype）有时候会发现卡住了，控制台停留在&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span clas
      
    
    </summary>
    
      <category term="工具使用" scheme="http://liaojiacan.me/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="Idea" scheme="http://liaojiacan.me/tags/Idea/"/>
    
      <category term="archetypeCatalog" scheme="http://liaojiacan.me/tags/archetypeCatalog/"/>
    
  </entry>
  
  <entry>
    <title>谈谈多语言设计（二）之Spring多语言</title>
    <link href="http://liaojiacan.me/2018/03/08/%E8%B0%88%E8%B0%88%E5%A4%9A%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B9%8BSpring%E5%A4%9A%E8%AF%AD%E8%A8%80/"/>
    <id>http://liaojiacan.me/2018/03/08/谈谈多语言设计（二）之Spring多语言/</id>
    <published>2018-03-08T11:07:00.000Z</published>
    <updated>2019-05-22T05:43:18.863Z</updated>
    
    <content type="html"><![CDATA[<p>  现在大部分成熟的web框架默认就支持多语言，如果业务比较简单，使用框架自身的多语言支持就可以了。本文将以SpringMvc为例介绍一下JavaWeb的多语言中的一些关键类。</p><h2 id="关键字"><a class="markdownIt-Anchor" href="#关键字"></a> 关键字</h2><ul><li>i18n</li><li>Locale</li><li>LocaleContext</li><li>MessageSource</li></ul><h2 id="i18n"><a class="markdownIt-Anchor" href="#i18n"></a> I18N</h2><p>   i18n(其来源是英文单词 internationalization的首末字符i和n，18为中间的字符数),除了i18n还有L10n、g11n、m17n。</p><h2 id="locale"><a class="markdownIt-Anchor" href="#locale"></a> Locale</h2><p>  Locale是区域信息，通常locale信息包含应该语言信息和区域标识符，如zh_CN:zh为中文,CN为中国的国家代码。常见的Locale代码可以上网获取。<a href="https://www.science.co.il/language/Locale-codes.php" target="_blank" rel="noopener"> Locale Codes</a>。java中的Locale.java 也定义了常见的区域信息。我们应该尽量使用Locale类型来表达地域信息变量，不应该使用String类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">static public final Locale ENGLISH = createConstant(&quot;en&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">   /** Useful constant for language.</span><br><span class="line">    */</span><br><span class="line">   static public final Locale FRENCH = createConstant(&quot;fr&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">   /** Useful constant for language.</span><br><span class="line">    */</span><br><span class="line">   static public final Locale GERMAN = createConstant(&quot;de&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">   /** Useful constant for language.</span><br><span class="line">    */</span><br><span class="line">   static public final Locale ITALIAN = createConstant(&quot;it&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">   /** Useful constant for language.</span><br><span class="line">    */</span><br><span class="line">   static public final Locale JAPANESE = createConstant(&quot;ja&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">   /** Useful constant for language.</span><br><span class="line">    */</span><br><span class="line">   static public final Locale KOREAN = createConstant(&quot;ko&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">   /** Useful constant for language.</span><br><span class="line">    */</span><br><span class="line">   static public final Locale CHINESE = createConstant(&quot;zh&quot;, &quot;&quot;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> //从Locale的构造方法中，也看出Locale中可包含语言（language）,国家(country),变体（variant）</span><br><span class="line"> public Locale(String language, String country, String variant) &#123;</span><br><span class="line">        if (language== null || country == null || variant == null) &#123;</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        baseLocale = BaseLocale.getInstance(convertOldISOCodes(language), &quot;&quot;, country, variant);</span><br><span class="line">        localeExtensions = getCompatibilityExtensions(language, &quot;&quot;, country, variant);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="localecontext"><a class="markdownIt-Anchor" href="#localecontext"></a> LocaleContext</h2><p>   Spring中存储用户地域信息的上下文，LocaleContext中采用的是ThreadLocal变量来存储信息，线程隔离，这样就可以让locale参数从各层的方法参数中移除。我们在写业务代码时也尽量不要将Locale参数通过方法参数中传入，利用LocaleContext可以让代码显得更优雅点。此外Spring也提供一些LocaleChangeInterceptor 的实现，并不需要我们自己维护这些信息。</p><ul><li>AcceptHeaderLocaleResolver  通过Accept-Language加载locale信息</li><li>CookieLocaleResolver 通过Cookie加载locale信息</li><li>FixedLocaleResolver  全局静态的，返回一个默认的Locale</li><li>SessionLocaleResolver 通过SessionLocaleResolver加载locale信息</li></ul><h2 id="messagesource"><a class="markdownIt-Anchor" href="#messagesource"></a> MessageSource</h2><p>   对于多语言的翻译，无非就是先定义一些key，然后根据给这些key配置各种locale对应的文本。而Spring中的MessageSource就是维护这些配置信息的组件，Spring中有ResourceBundleMessageSource 和 ReloadableResourceBundleMessageSource的实现，可以将多语言的配置在<span class="katex-error" title="ParseError: KaTeX parse error: Expected group after &#039;_&#039; at position 11: {basename}_̲">{basename}_</span>{locale}.properties文件中。ResourceBundleMessageSource 每次修改配置需要重启服务才能生效，而ReloadableResourceBundleMessageSource可以热更新。</p><p>   当然我们也可以自己实现一个MessageSource从DB或者从其他存储源加载配置，后面我将单独写一篇文章介绍如何自定义MessageSource进行拓展的。</p><h2 id="多语言的处理流程"><a class="markdownIt-Anchor" href="#多语言的处理流程"></a> 多语言的处理流程</h2><p><img src="/images/pasted-1.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  现在大部分成熟的web框架默认就支持多语言，如果业务比较简单，使用框架自身的多语言支持就可以了。本文将以SpringMvc为例介绍一下JavaWeb的多语言中的一些关键类。&lt;/p&gt;
&lt;h2 id=&quot;关键字&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; hr
      
    
    </summary>
    
      <category term="架构总结" scheme="http://liaojiacan.me/categories/%E6%9E%B6%E6%9E%84%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="多语言" scheme="http://liaojiacan.me/tags/%E5%A4%9A%E8%AF%AD%E8%A8%80/"/>
    
      <category term="i18n" scheme="http://liaojiacan.me/tags/i18n/"/>
    
  </entry>
  
  <entry>
    <title>谈谈多语言设计（一）之客户端多语言与服务端多语言</title>
    <link href="http://liaojiacan.me/2018/03/07/%E8%B0%88%E8%B0%88%E5%A4%9A%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8B-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%9A%E8%AF%AD%E8%A8%80%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A4%9A%E8%AF%AD%E8%A8%80/"/>
    <id>http://liaojiacan.me/2018/03/07/谈谈多语言设计（一）之-客户端多语言与服务端多语言/</id>
    <published>2018-03-07T03:56:00.000Z</published>
    <updated>2019-05-22T05:43:18.862Z</updated>
    
    <content type="html"><![CDATA[<p>  2017年的一个风口就是移动互联网的出海，很多公司都战略性地在海外做起了互联网商业化，最近也是接触了一些国际的项目，用户散落在各个国家地区，刚开始大部分是由客户端进行多语言的适配，后来由于产品觉得灵活性太差，于是把部分功能移到服务端来实现，但是发现无论是客户端实现还是服务端实现都存在一些弊端。</p><h2 id="我们先思考一下以下几个问题"><a class="markdownIt-Anchor" href="#我们先思考一下以下几个问题"></a> 我们先思考一下以下几个问题：</h2><ol><li>完全由服务端实现多语言有什么弊端?</li></ol><blockquote><p>对于大部分应用场景，多语言都可以在服务端实现，但有一种情况不适合使用服务端多语言。比如目标用户语言非唯一，IM群发，推送等业务场景，虽然大部分消息推送服务可以按用户属性或者标签进行推送，服务端可以分开推送来实现，但是对于用户群推地域很分散的应用显然不是很合适。</p></blockquote><ol start="2"><li>完全由客户端实现多语言由什么弊端？</li></ol><blockquote><p>大部分情况下都是采用的客户端写多语言配置进行适配，不管是android 还是iOS 还是常见的前端框架都是支持i18n的配置。这种方式有个缺点就是灵活性比较差，修改文案必须发包。</p></blockquote><ol start="3"><li>对于移动应用多语言是该客户端做还是服务端做，如何找到一个平衡点？</li></ol><blockquote><p>无论是客户端多语言还是服务端多语言都有各自的优劣，主要还是看应用场景。<br>个人认为对于移动应用的多语言，应该把两者结合起来使用。对于UI等相对固定的部分采用客户端多语言。对于变动比较大的部分，采用服务端进行多语言的处理，比如名称，描述这些可能会根据运营场景进行调整的信息。</p></blockquote><ol start="4"><li>为什么不采用服务端生成配置客户端加载配置的方式？</li></ol><blockquote><p>这种方式是一种比较灵活的方式，但是对于协议的定义不是很友好（key必须唯一，势必导致接口的返回体变大），而且无论是客户端还是服务端解析也比较耗资源，接口可读性比较差。而且把业务跟多语言的耦合太重，无论是客户端和服务端在编码的时候应该把多语言与业务解构，即便没有多语言部分也不影响业务的执行。</p></blockquote><ol start="5"><li><p>如果将客户端多语言和服务端多语言结合使用，怎么规范比较适合？</p><blockquote><p>简单来说，就是以下几点:</p></blockquote><ul><li>UI部分由客户端实现多语言</li><li>所有客户端主动向服务端拉取的由服务端实现</li><li>对于群发等应用场景，由服务端生成语言包，客户端在一定时机拉取并加载到应用中。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  2017年的一个风口就是移动互联网的出海，很多公司都战略性地在海外做起了互联网商业化，最近也是接触了一些国际的项目，用户散落在各个国家地区，刚开始大部分是由客户端进行多语言的适配，后来由于产品觉得灵活性太差，于是把部分功能移到服务端来实现，但是发现无论是客户端实现还是服
      
    
    </summary>
    
      <category term="架构总结" scheme="http://liaojiacan.me/categories/%E6%9E%B6%E6%9E%84%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="多语言" scheme="http://liaojiacan.me/tags/%E5%A4%9A%E8%AF%AD%E8%A8%80/"/>
    
      <category term="i18n" scheme="http://liaojiacan.me/tags/i18n/"/>
    
  </entry>
  
  <entry>
    <title>Source Tree 配置支持gerrit review</title>
    <link href="http://liaojiacan.me/2018/02/07/Source-Tree-%E9%85%8D%E7%BD%AE%E6%94%AF%E6%8C%81gerrit-review/"/>
    <id>http://liaojiacan.me/2018/02/07/Source-Tree-配置支持gerrit-review/</id>
    <published>2018-02-07T07:34:45.000Z</published>
    <updated>2019-05-22T05:43:18.859Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>source tree 可以支持自定义菜单，我们自定义一个菜单，来实现gerrit push review操作</p></blockquote><p>1.先创建一个脚本，这里我叫 git_push_gerrit.sh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># Push for gerrit review</span><br><span class="line"># Created by Liaojiacan on 6.2.2017.</span><br><span class="line"># Copyright (c) 2018 liaojiacan. All rights reserved.</span><br><span class="line">branch=$(git symbolic-ref --short -q HEAD)</span><br><span class="line">git push origin HEAD:refs/for/$branch</span><br></pre></td></tr></table></figure><p>2.在SourceTree创建一个自定义操作</p><p><img src="/images/pasted-0.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;source tree 可以支持自定义菜单，我们自定义一个菜单，来实现gerrit push review操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.先创建一个脚本，这里我叫 git_push_gerrit.sh&lt;/p&gt;
&lt;figure c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>抽奖业务设计</title>
    <link href="http://liaojiacan.me/2017/12/16/%E6%8A%BD%E5%A5%96%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/"/>
    <id>http://liaojiacan.me/2017/12/16/抽奖业务设计/</id>
    <published>2017-12-16T08:12:00.000Z</published>
    <updated>2019-05-22T05:43:18.861Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>抽奖是一个比较常见的业务，关于抽奖的算法也有很多种实现，下面介绍一种比较容易实现的方式。</p></blockquote><p>1.根据中奖概率的精确度，取一个权重的基线作为（概率-&gt;概率区间）的放大因子。比如，概率的精确度是到万分位，则基线取10000，保证转换后的区间&gt;=1</p><p>2.将奖品按对应的中奖概率*基线 转换成权重区间，并记录权重的上限值。</p><p>3.在权重上限值的范围内产生一个随机数，利用迭代查找或者二分查找算法找到对应的权重区间，即可获取到对应的奖品。</p><p>假设奖品的配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;一等奖&quot;:0.01</span><br><span class="line">&quot;二等奖&quot;:0.1</span><br><span class="line">&quot;三等奖&quot;:0.15</span><br><span class="line">&quot;四等奖&quot;:0.2</span><br><span class="line">&quot;五等奖&quot;:0.25</span><br><span class="line">&quot;六等奖&quot;:0.29</span><br></pre></td></tr></table></figure><p>概率转换到权重区间（放大10000倍）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一等奖:[0.000000,100.000000)</span><br><span class="line">二等奖:[100.000000,1100.000000)</span><br><span class="line">三等奖:[1100.000000,2600.000000)</span><br><span class="line">四等奖:[2600.000000,4100.000000)</span><br><span class="line">五等奖:[4100.000000,6100.000000)</span><br><span class="line">六等奖:[6100.000000,8600.000000)</span><br></pre></td></tr></table></figure><p>算法实现：<a href="https://github.com/liaojiacan/code-snippets/tree/master/function-design/src/main/java/com/github/liaojiacan/lottery" target="_blank" rel="noopener">Github</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class LotteryPrize &#123;</span><br><span class="line">private String id;</span><br><span class="line">private String name;</span><br><span class="line">private double possibility;</span><br><span class="line"></span><br><span class="line">public LotteryPrize() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public LotteryPrize(String id, String name, double possibility) &#123;</span><br><span class="line">this.id = id;</span><br><span class="line">this.name = name;</span><br><span class="line">this.possibility = possibility;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getId() &#123;</span><br><span class="line">return id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setId(String id) &#123;</span><br><span class="line">this.id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public double getPossibility() &#123;</span><br><span class="line">return possibility;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setPossibility(double possibility) &#123;</span><br><span class="line">this.possibility = possibility;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class LotteryMachine &#123;</span><br><span class="line"></span><br><span class="line">private PossibilityArea[] table;</span><br><span class="line">private int bound = 1;</span><br><span class="line">private Random random = new Random();</span><br><span class="line"></span><br><span class="line">private static final int BASE_WEIGHT = 10000;</span><br><span class="line"></span><br><span class="line">class PossibilityArea&#123;</span><br><span class="line">private LotteryPrize prize;</span><br><span class="line">private double start;</span><br><span class="line">private double end;</span><br><span class="line">public PossibilityArea(LotteryPrize prize, double start, double end) &#123;</span><br><span class="line">this.prize = prize;</span><br><span class="line">this.start = start;</span><br><span class="line">this.end = end;</span><br><span class="line">System.out.printf(&quot;%s:[%f,%f)\n&quot;,prize.getName(),start,end);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LotteryMachine(List&lt;LotteryPrize&gt; prizes) &#123;</span><br><span class="line">table = new PossibilityArea[prizes.size()];</span><br><span class="line">double start = 0;</span><br><span class="line">for(int i=0;i&lt;prizes.size();i++)&#123;</span><br><span class="line">LotteryPrize prize = prizes.get(i);</span><br><span class="line">double weight = prize.getPossibility() * BASE_WEIGHT;</span><br><span class="line">Double end = start + weight;</span><br><span class="line">PossibilityArea area = new PossibilityArea(prize,start,end);</span><br><span class="line">table[i]= area;</span><br><span class="line">bound = end.intValue();</span><br><span class="line">start=end;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private LotteryPrize binarySearch(int rnd)&#123;</span><br><span class="line">int low = 0;</span><br><span class="line">int hight = table.length;</span><br><span class="line">while (low&lt;hight)&#123;</span><br><span class="line">int mid = (low + hight) / 2;</span><br><span class="line">PossibilityArea area = table[mid];</span><br><span class="line">if(area.start&lt;=rnd &amp;&amp; area.end&gt;rnd)&#123;</span><br><span class="line">return  area.prize;</span><br><span class="line">&#125;</span><br><span class="line">if(area.end&lt;=rnd)&#123;</span><br><span class="line">low=mid+1;</span><br><span class="line">&#125;</span><br><span class="line">if(area.start&gt;rnd)&#123;</span><br><span class="line">hight=mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LotteryPrize go()&#123;</span><br><span class="line">int rnd = random.nextInt(bound);</span><br><span class="line">return binarySearch(rnd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;抽奖是一个比较常见的业务，关于抽奖的算法也有很多种实现，下面介绍一种比较容易实现的方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.根据中奖概率的精确度，取一个权重的基线作为（概率-&amp;gt;概率区间）的放大因子。比如，概率的精确度是到万分位，则
      
    
    </summary>
    
      <category term="java" scheme="http://liaojiacan.me/categories/java/"/>
    
    
      <category term="业务开发" scheme="http://liaojiacan.me/tags/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
