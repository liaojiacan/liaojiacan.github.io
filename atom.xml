<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jiacan‘s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liaojiacan.me/"/>
  <updated>2019-05-29T12:04:49.335Z</updated>
  <id>http://liaojiacan.me/</id>
  
  <author>
    <name>Jiacan Liao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>生产环境故障处理的一般办法总结</title>
    <link href="http://liaojiacan.me/2019/05/29/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%80%E8%88%AC%E5%8A%9E%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://liaojiacan.me/2019/05/29/生产环境故障处理的一般办法总结/</id>
    <published>2019-05-29T09:45:44.000Z</published>
    <updated>2019-05-29T12:04:49.335Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>任何一个系统上线运营后都或多或少会遇到生产环境故障问题，大部分情况下&quot;重启大法&quot;的确好用，但是能否有更符合我们这些&quot;有经验的&quot;工程师的做法呢？</p><hr><p>故障： 慢了，挂了，出异常。</p><p>处理：找线索、推测原因、再进一步找具体线索验证。</p><h3 id="总体的思路"><a class="markdownIt-Anchor" href="#总体的思路"></a> 总体的思路</h3><p>定位-&gt;保留现场-&gt; 故障快速恢复（重启/限流/降级/会滚）-&gt; 事后分析（日志/软硬件负载等）-&gt; 优化以及针对性加告警。</p><ul><li>线上告警/或者测试/客服反馈故障（模块/用户信息/时间等）</li><li>先看对应的模块工作是否正常（把接口往浏览器一敲，看看能不能访问，😄）</li><li>上机器看服务日志，看是否有异常日志（一般这种运行时异常，都要通过告警系统告警出来）</li><li>如果日志出现异常，回顾是否最近有更新服务，考虑是否需要会滚。</li><li>如果没有日志异常，纯粹是服务慢、超时，就要进一步分析了。</li><li>服务慢、超时，先看看目前的请求量多少，是否超出了当时的设计，一般这些都有做预警，如果没有预警出来，大概率不是这个原因，当然还是排除一下最好。</li><li>如果量不大，那一般就只有几种情况了，一是连接池或者线程池满了，二是GC 导致的停顿，三是数据库。</li><li>连接池和线程池满了都可能导致的新的请求无法处理，这个时候可以看下一些连接池的配置，线程池的配置，像数据库连接池如果用的是durid 可以有可视化的界面看，如果没有，可以通过jmap 把 heap都dump出来，查看链接池对象的属性，看类似idle等counter值，当然你也可以用一些在线的反射工具去看。像线程池的话如果是有届队列的可以通过 自定义拒绝策略类将异常告警出来。</li><li>GC 过程中的STW也可能导致请求超时，这个时候就要看是否堆空间不足，新老年代是否合理，可以考虑隔离一台机器出来把堆dump出来，看是否有内存泄漏。</li><li>数据库的话需要看下数据库服务的情况，慢查询等。</li><li>如果量大，那么是否考虑进行一个扩容，或者限流，或者考虑是否有DDOS攻击和CC攻击。</li><li>当然上一步只是一个分析过程，实际上也不可能让服务一直不回复等我们找到原因，一般都想先收集现场，能打快照的打快照，不能打快照的隔离出一台机器保留现场。</li></ul><h3 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h3><h4 id="1-先对现场数据进行定量归类"><a class="markdownIt-Anchor" href="#1-先对现场数据进行定量归类"></a> 1. 先对现场数据进行定量归类：</h4><ul><li>异常节点数量，少数节点故障还是多数节点故障。</li><li>时间点，出现异常的时间点或者范围，这个很重要，方便定位日志区间。</li><li>共同特征，比如是否都是依赖了某个下游服务，是同机房/ISP/程序版本/操作系统</li></ul><blockquote><p>这些最开始的归类有助于快速定位问题所在，记录故障路径，方便后面复盘。由于这些要求保留故障现场，但是我们也不能让服务一直不恢复，所以这些工作要在短时间内完成，如果公司的基础设施比较完善这些也应该能够在事后在各种监控系统进行复查。</p></blockquote><p>先解决问题再找原因，一般操作就是先保留现场，如果能保留快照（短时间内能完成），就保留快照后进行服务恢复，如果不能（比如JVM  dump heap 一般要很久），留一台线上机器，隔离流量（域名摘掉解析，nginx upstream 去掉，微服务得话将服务节点下线），其他机器重启恢复。</p><h4 id="2-对于无法从服务表象日志接口看出问题的情况就要深入服务运行环境进行分析排查"><a class="markdownIt-Anchor" href="#2-对于无法从服务表象日志接口看出问题的情况就要深入服务运行环境进行分析排查"></a> 2. 对于无法从服务表象（日志/接口）看出问题的情况，就要深入服务运行环境进行分析排查。</h4><ul><li><p>服务的表现：慢、挂、异常； 应用日志、上下游服务状态。</p><blockquote><p>Nginx 的 access log</p><p>一些trace 服务，如 spring cloud 的 Sleuth / Zipkin (dubbo 也可以)</p><p>Metric类的系统，直接定位到业务。</p></blockquote></li><li><p>硬件状态：CPU、内存、磁盘、网络是否有瓶颈。</p><blockquote><p>top 命令</p><p>free -h 看内存</p><p>df -h</p><p>iftop</p><p>nload</p><p>ping</p><p>lsof</p><p>netstat</p></blockquote></li><li><p>系统/容器/VM状态：系统日志，容器日志，VM GC日志等。</p><blockquote><p>jstat -gcutil  [pid] [period] 查看GC信息</p><p>jmap -heap [pid] 查看jvm堆的使用情况</p><p>唯品会开源的一些工具也挺好用的，<a href="https://github.com/vipshop/vjtools" target="_blank" rel="noopener">https://github.com/vipshop/vjtools</a></p></blockquote></li></ul><p>上面这些信息 可以通过一些监控系统，一般上规模的公司都有这些，可以快速获取到这些信息，没有的话，也可以自行上机器通过linux 命令查询到。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h3&gt;
&lt;p&gt;任何一个系统上线运营后都或多或少会遇到生产环境故障问题，大部分情况下&amp;quot;重启大法&amp;quot;的确好用，但是能否有更符合我们这些&amp;quot
      
    
    </summary>
    
      <category term="运维技巧" scheme="http://liaojiacan.me/categories/%E8%BF%90%E7%BB%B4%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="运维技巧" scheme="http://liaojiacan.me/tags/%E8%BF%90%E7%BB%B4%E6%8A%80%E5%B7%A7/"/>
    
      <category term="故障处理" scheme="http://liaojiacan.me/tags/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/"/>
    
      <category term="生产环境" scheme="http://liaojiacan.me/tags/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
  <entry>
    <title>【高可用架构】理解有状态服务和无状态服务？</title>
    <link href="http://liaojiacan.me/2019/05/27/%E3%80%90%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E3%80%91%E7%90%86%E8%A7%A3%E6%9C%89%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1%E5%92%8C%E6%97%A0%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1/"/>
    <id>http://liaojiacan.me/2019/05/27/【高可用架构】理解有状态服务和无状态服务/</id>
    <published>2019-05-27T08:41:14.000Z</published>
    <updated>2019-05-27T11:07:19.572Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>“有状态&quot;和&quot;无状态” 这个两词经常会出现在一些架构设计的文章中，怎么去理解这两个的含义？这2种场景下该如何做高可用，数据一致性怎么解决？</p><h2 id="正文"><a class="markdownIt-Anchor" href="#正文"></a> 正文</h2><p>对于&quot;状态&quot;我个人的理解是， 对于同一时刻同一个请求产生的数据的状态数为一的则为无状态，大于一则认为有状态，至于是否允许多状态共存，取决于对一致性的要求。</p><h3 id="从数据层面看状态"><a class="markdownIt-Anchor" href="#从数据层面看状态"></a> 从数据层面看状态</h3><blockquote><p>数据的状态往往受2个纬度有关，一是与时间相关或者顺序相关的，不同的操作顺序可能导致同一个时间点上的数据状态&gt; 1个，二是与数据的副本状态相关的，数据落在多个副本上，可能出现多种数据状态的组合。</p></blockquote><p><strong>时间状态</strong>： 操作顺序有一定的限制，同一个状态的数据不能出现在2个时间点（重复请求）。</p><ul><li>如有个数据新增 ，更新，删除这3个顺序的请求，在下游业务也需要同样的顺序操作。</li><li>对于单状态的数据，如计数器，不能出现重复添加，也就是这个数据只有第一次出现的时间状态是对的，后来的数据在时间状态上是不允许的，对于这种场景，往往通过把这个&quot;点&quot;状的数据，换成&quot;线&quot;数据，比如换把计数器记录成操作历史，这个点的状态由这些历史数据聚合而成，&quot;线”数据容易做幂等操作。</li></ul><p><strong>位置状态</strong> :   数据落地点的状态。</p><ul><li>数据拆分后的应用，同一个数据就有了状态，他只能落在指定的节点上。</li><li>对于复制集架构，数据是存在多个副本的，也就是说数据落在的位置在集群上需要有一定的数量保证，以满足一定的共识基础，比如要写半数以上节点，也就是说这个数据是存在2个状态的，对于已经写成功的节点是成功状态，对于未写成功的节点是未成功/处理中的状态。如何协调这些状态，往往要引入一些共识协议（Paxos，Raft）。</li></ul><h3 id="从服务层面看状态"><a class="markdownIt-Anchor" href="#从服务层面看状态"></a> 从服务层面看状态</h3><blockquote><p>服务层面的状态取决于实例是单独维护数据还是共享数据，或者说是否存在多个数据闭环让数据的流向产生了多条路径。有状态的服务往往比较难进行水平拓展，在现在容器盛行的环境，把服务设计成无状态的更加高效，即便是有状态的服务，也要将状态内敛在系统的某个范围，比如分布式的存储，对于业务服务，我不需要关系数据在多个副本的状态，数据的状态由分布式存储这个服务本身解决。</p></blockquote><h4 id="有状态服务"><a class="markdownIt-Anchor" href="#有状态服务"></a> 有状态服务</h4><ul><li>服务本身依赖或者存在局部的状态数据，这些数据需要自身持久化或者可以通过其他节点恢复。</li><li>一个请求只能被某个节点（或者同等状态下的节点）处理。</li><li>存储状态数据，实例的拓展需要整个系统参与状态的迁移。</li><li>在一个封闭的系统中，存在多个数据闭环，需要考虑这些闭环的数据一致性问题。</li><li>通常存在于分布式架构中。</li></ul><h4 id="无状态服务"><a class="markdownIt-Anchor" href="#无状态服务"></a> 无状态服务</h4><ul><li>服务不依赖自身的状态，实例的状态数据可以维护在内存中。</li><li>任何一个请求都可以被任意一个实例处理。</li><li>不存储状态数据，实例可以水平拓展，通过负载均衡将请求分发到各个节点。</li><li>在一个封闭的系统中，只存在一个数据闭环。</li><li>通常存在于单体架构的集群中。</li></ul><h3 id="怎么做转换"><a class="markdownIt-Anchor" href="#怎么做转换"></a> 怎么做转换</h3><ol><li>采用复制或者集中式消除数据状态。</li></ol><p><img src="https://raw.githubusercontent.com/liaojiacan/assets/master/img/stateless%20vs%20stateful%20(1).png" alt></p><ul><li>对于Web服务，如果数据存在session中，那么这个服务就有了状态。</li><li>一种是对session进行复制，同步复制还是异步复制，取决于你对数据一致性的敏感程度。</li><li>也可以将session集中式管理，如用redis，出现性能或者容量的瓶颈，再换分布式的缓存，把状态交于缓存服务维护。</li><li>我们可以看出，有状态的服务，它的数据是存在多个闭环的，比如Web01-session-01-&gt; DB 和 Web02-session-&gt;DB 。通过复制，将session-01 和 02 等同于同一个。</li><li>或者我们可以将数据进行分区，让负载均衡器通过hash算法将请求落在固定的处理节点上。</li></ul><ol start="2"><li>采用控制节点来保证集中式存储的高可用和一致性。</li></ol><p><img src="https://raw.githubusercontent.com/liaojiacan/assets/master/img/stateless%20vs%20stateful%20-%20DB.png" alt></p><ul><li>在高可用的架构下，数据往往得存在多副本（鸡蛋别放一个篮子里面）</li><li>CAP理论，C和A不可能同时满足，多副本的存在让A可在有限时间内恢复，而C可用采用Quorum 机制来控制多个副本节点的数据一致性问题，保证半数以上的节点的写成功。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;“有状态&amp;quot;和&amp;quot;无状态” 这个两词经常会出现在一些架构设计的文章中，怎么去理解这两个的含义？这2种场景下该如何做高可
      
    
    </summary>
    
      <category term="高可用架构" scheme="http://liaojiacan.me/categories/%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="系统设计" scheme="http://liaojiacan.me/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="架构设计" scheme="http://liaojiacan.me/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="分布式" scheme="http://liaojiacan.me/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="高可用" scheme="http://liaojiacan.me/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>【系统与架构设计】你知道硬盘能有多快吗？</title>
    <link href="http://liaojiacan.me/2019/05/22/%E3%80%90%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E3%80%91%E4%BD%A0%E7%9F%A5%E9%81%93%E7%A1%AC%E7%9B%98%E8%83%BD%E6%9C%89%E5%A4%9A%E5%BF%AB%E5%90%97/"/>
    <id>http://liaojiacan.me/2019/05/22/【系统与架构设计】你知道硬盘能有多快吗/</id>
    <published>2019-05-22T08:40:14.000Z</published>
    <updated>2019-05-22T11:05:37.070Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>应用软件通常都是由各种类型的软硬件相互配合实现，无论你是单体架构还是分布式架构，任何一个模块或者环节都可能是系统的瓶颈，可能是CPU，可能是网络，也可能是硬盘等。了解一些基础的边界（“量”），有助于我们分析系统的瓶颈。</p></blockquote><h3 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h3><ul><li><p>大部分的应用系统都是IO密集型，同机房的服务一般性能的瓶颈在于磁盘IO，那么一般机械硬盘的性能上限是怎么样的，根据磁盘的最大性能能否判断我们的系统是否有优化的空间？</p></li><li><p>B+ tree 的索引 一般是3～4层，也就是平均情况下需要3到4次的I/O，我们的应用需要1000TPS，普通的机械磁盘的性能是否能达到要求？</p></li><li><p>假如innodb的事务处理能力只受redo log 的写入速度影响，一条操作日志1kb的话，TPS可以到达多少？</p></li><li><p>假如网络带宽限制不计的话，我们从一台机器同步一个1TB的数据，机械硬盘需要多久？</p></li></ul><blockquote><p>这些问题可能都不是正确的问题，我想表达的是假如现在来解答这些问题，能否根据自己的一些印象（磁盘的性能的量级。HDD硬盘100MB/s，SSD 500MB/s ，IOPS 100… 等）来估算一下。</p></blockquote><h3 id="存储设备的2个性能指标"><a class="markdownIt-Anchor" href="#存储设备的2个性能指标"></a> 存储设备的2个性能指标</h3><ul><li><p>IOPS ：(Input/Output Per Second)  每秒的输入输出量，代表存储系统的每秒的I/O请求数。“只关系数量”</p><ul><li>Random Read IOPS(随机读)</li><li>Random Write IOPS(随机写)</li><li>Sequential Read IOPS(顺序读)</li><li>Sequential Write IOPS(顺序写)</li><li>Total IOPS （混合读写）</li></ul></li><li><p>带宽/吞吐量：单位时间内传输的数据大小，比如10MB/秒 。“只关系比特数或者说容量”</p></li></ul><blockquote><p>对于OLTP应用/数据库，我们看重的更多的是随机I/O的性能，这个时候看IOPS更加合理，对于大文件或者顺序读写的应用（hadoop/kafka……），更加看重的是吞吐量。</p></blockquote><h3 id="机械硬盘-hdd"><a class="markdownIt-Anchor" href="#机械硬盘-hdd"></a> 机械硬盘 HDD</h3><ul><li>IOPS ：100左右</li></ul><table><thead><tr><th>设备</th><th>形式</th><th>IOPS</th><th>接口</th><th>注解</th></tr></thead><tbody><tr><td>7,200RPMSATA硬盘驱动器</td><td>硬盘驱动器</td><td>~75-100 IOPS</td><td>SATA 3Gbit/s</td><td></td></tr><tr><td>10,000 RPM SATA硬盘驱动器</td><td>硬盘驱动器</td><td>~125-150 IOPS</td><td>SATA 3 Gbit/s</td><td></td></tr><tr><td>10,000 rpmSAS硬盘驱动器</td><td>硬盘驱动器</td><td>~140 IOPS</td><td>SAS（串列SCSI）</td><td></td></tr><tr><td>15,000 rpmSAS硬盘驱动器</td><td>硬盘驱动器</td><td>~175-210 IOPS</td><td>SAS（串列SCSI）</td><td></td></tr></tbody></table><blockquote><p>数据来源于百度百科 <a href="https://baike.baidu.com/item/IOPS" target="_blank" rel="noopener">https://baike.baidu.com/item/IOPS</a></p></blockquote><ul><li>带宽/吞吐量 ：100MB/s 左右</li></ul><p><img src="https://raw.githubusercontent.com/liaojiacan/assets/master/img/WX20190522-165652.png" alt></p><blockquote><p>数据来源 <a href="https://hdd.userbenchmark.com/" target="_blank" rel="noopener">https://hdd.userbenchmark.com/</a></p></blockquote><p>可以看到 机械硬盘的的读写速度在 ～20.6MB/s - 200MB/S 之间</p><h3 id="固态硬盘-ssd"><a class="markdownIt-Anchor" href="#固态硬盘-ssd"></a> 固态硬盘 SSD</h3><ul><li>IOPS ：8000～80000</li></ul><table><thead><tr><th>设备</th><th>形式</th><th>IOPS</th><th>接口</th><th>注解</th></tr></thead><tbody><tr><td>英特尔Intel X25-M G2（MLC）</td><td>SSD</td><td>~8,600 IOPS</td><td>SATA 3 Gbit/s</td><td>英特尔的数据表声称在4KB数据的写入及读取时，分别有有6,600/8,600 IOPS (80GB/160GB版本)及35,000 IOPS的速度。</td></tr><tr><td>英特尔 Intel X25-E (SLC)</td><td>SSD</td><td>~5,000 IOPS</td><td>SATA 3 Gbit/s</td><td>英特尔数据表声称在写入和读取的速度为3,300 IOPS及35,000 IOPS。写入和读取混和时为5,000 IOPS。英特尔的X25-E G1比X25-M G2快了约三倍</td></tr><tr><td>G.SkillPhoenix Pro</td><td>SSD</td><td>~20,000 IOPS。</td><td>SATA 3 Gbit/s</td><td>SandForce-1200为基础的固态硬件，配合加强版的固件，最快可到50,000 IOPS，性能测试的结果是随机读取可到~25,000 IOPS，随机写入可到~15,000 IOPS。</td></tr><tr><td>OCZVertex 3</td><td>SSD</td><td>最高可到60,000 IOPS</td><td>SATA 6 Gbit/s</td><td>随机写入4KB (Aligned)</td></tr><tr><td>CorsairForce Series GT</td><td>SSD</td><td>最高可到85,000 IOPS</td><td>SATA 6 Gbit/s</td><td>240GB Drive，循序读取为555 MB/s，循序写入为525 MB/s。随机写入4KB (Aligned)</td></tr></tbody></table><blockquote><p>数据来源于百度百科 <a href="https://baike.baidu.com/item/IOPS" target="_blank" rel="noopener">https://baike.baidu.com/item/IOPS</a></p></blockquote><ul><li>带宽/吞吐量： 读548MB/S  | 写 370MB/s</li></ul><p><img src="https://raw.githubusercontent.com/liaojiacan/assets/master/img/WX20190522-181048.png" alt></p><blockquote><p>数据来源 <a href="https://ssd.userbenchmark.com/" target="_blank" rel="noopener">https://ssd.userbenchmark.com/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;应用软件通常都是由各种类型的软硬件相互配合实现，无论你是单体架构还是分布式架构，任何一个模块或者环节都可能是系统的瓶颈，可能是CPU，可能是网络，也可能是硬盘等。了解一些基础的边界（“量”），有助于我们分析系统的瓶颈。&lt;/p&gt;
&lt;/blockquo
      
    
    </summary>
    
      <category term="系统与架构设计" scheme="http://liaojiacan.me/categories/%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="系统设计" scheme="http://liaojiacan.me/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="架构设计" scheme="http://liaojiacan.me/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="存储" scheme="http://liaojiacan.me/tags/%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>一种适合后端团队代码的GIT分支管理办法</title>
    <link href="http://liaojiacan.me/2019/05/21/%E4%B8%80%E7%A7%8D%E9%80%82%E5%90%88%E5%90%8E%E7%AB%AF%E4%BB%A3%E7%A0%81%E7%9A%84GIT%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E5%8A%9E%E6%B3%95/"/>
    <id>http://liaojiacan.me/2019/05/21/一种适合后端代码的GIT分支管理办法/</id>
    <published>2019-05-21T08:45:44.000Z</published>
    <updated>2019-05-22T05:43:18.860Z</updated>
    
    <content type="html"><![CDATA[<p>  每个公司甚至公司中的不同团队对代码的分支管理都是有所差别，网上也有很多人分享了他们的分支管理规范，相信很多有一种感觉就是采用了他们的方法然后真正实践起来总是有些水土不服，我个人认为分支的管理需要结合团队规模、应用类型、发布流程等实际的情况来制定规范。下面我将介绍一种适用于后端开发团队且做toC产品业务后台的代码分支管理办法。</p><h3 id="不同业务代码的管理需求差异"><a class="markdownIt-Anchor" href="#不同业务代码的管理需求差异"></a> 不同业务代码的管理需求差异</h3><table><thead><tr><th></th><th>业务后台</th><th>基础工具SDK/中间件</th><th>独立部署企业软件</th></tr></thead><tbody><tr><td>多版本</td><td>不需要</td><td>需要</td><td>需要</td></tr><tr><td>迭代频率</td><td>1-2周</td><td>少更新</td><td>少更新</td></tr><tr><td>更新方式</td><td>灰度更新</td><td>更新SDK版本号</td><td>补丁包更新，不同版本不同的补丁包</td></tr><tr><td>维护版本</td><td>最近的2个版本，主要是发布失败会滚用</td><td>每个release版本都需要单独维护</td><td>每个客户的版本都要单独维护</td></tr></tbody></table><p>从上面的对比结果看，在做to C 产品的业务后台的，相对于开源软件，企业软件，中间件等对于版本控制的生命周期没有那么长，不需要对每个release版本进行长时间的维护跟踪，我们的服务更新永远只有一条线，因为我们的服务面向的研发只有自己的团队，就算出现版本兼容，在随后的几个版本也能快速升级上来。需要做好版本控制的仅仅在于最近上线的几个版本中。</p><h3 id="一种适合业务后台开发的git分支管理模型"><a class="markdownIt-Anchor" href="#一种适合业务后台开发的git分支管理模型"></a> 一种适合业务后台开发的GIT分支管理模型</h3><p><img src="https://raw.githubusercontent.com/liaojiacan/assets/master/imgGit%20%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B%20(6).png" alt></p><ol><li><code>develop</code>： 开发分支，平常开发的代码都提交到这里，为了简化，这里可以不用根据版本号进行细化分支。</li><li><code>feature/xxx</code>: 特性分支，这个目录下的分支，用于开发一些新特性，或者说是最近不需要上线的功能。</li><li><code>stage</code>： 测试分支，这个分支代表测试环境的代码，测试环境的镜像/程序必须通过该分支来构建，保证测试结果与代码的一致性。</li><li><code>master</code>：生产分支，这个分支代表生产环境的代码，生产环境的镜像/程序必须通过该分支来构建，部署后打tag确定release版本，对应我们的场景(业务后台)，我们只需要维护最近的2个release版本，一般情况下只能回滚最近的版本。</li><li><code>bugfix-xx</code>: 补丁分支，这个是一个临时分支，从待修复版本的起点开分支，每个分支对应一个补丁程序，在本地验证后，需要把补丁合并到stage进行测试验证，验证通过后再将补丁合并到master进行修复，同样也需要把补丁打到develop。</li></ol><h3 id="工作中常见的场景"><a class="markdownIt-Anchor" href="#工作中常见的场景"></a> 工作中常见的场景</h3><ol><li><strong>开发周期中，所有的功能在当前周期都能完成，需求评审确认通过且开发任务符合预期</strong>：</li></ol><p>  时间线：D1→D2→D3→D4→S3→M2 。因为经过评估在下一个发布时间前开发人员能够将D1到D4的4个功能完成开发，所以在次期间我们只需要保证这个分支的功能能正常演进即可，尽量不要引进太多的分支。</p><ol start="2"><li><strong>开发周期中，所有功能在当前周期完成，需求评审确认通过，少部分功能上线时间待定，任务进度符合预期</strong>：</li></ol><p>  这个时候可能存在2条线，大部分人参与当前版本的功能开发（develop分支的演进），少部分人进行未来版本上线的需求开发（F1，F2，F3）。F3→S2 这个合并尽量等到需求拍定上线版本后合并到stage给测试人员测试。</p><ol start="3"><li><strong>线上BUG的修复</strong>：</li></ol><p>  确认BUG后，如果是测试人员反馈回来的一般会是在JIRA 上提单，我们可以根据jira的issue Id，在master 上 创建一个bugfix-jira-xx，接下来在这个分支上完成补丁的开发（B1→B2），之后合并补丁到stage分支进行测试环境的部署（B2→S4），等待测试人员的验证，验证完成后将补丁合并到master和develop分支（B2→M3，B2→D5），并打一个小版本号的tag。</p><ol start="4"><li><strong>有个新功能，老板想立马上线，但是发版的时间还没到</strong>：</li></ol><p>  这种情况，把这个功能当成一个超前的feature处理，我们上面说的feature是一个未来版本的功能，可以走未来版本的测试上线流程，这里的feature 是一个超前的功能，我们需要走类似bugfix的流程，进行一个快速的开发上线。</p><blockquote><p>如果你们有遇到比较棘手的分支管理问题，欢迎留言交流。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  每个公司甚至公司中的不同团队对代码的分支管理都是有所差别，网上也有很多人分享了他们的分支管理规范，相信很多有一种感觉就是采用了他们的方法然后真正实践起来总是有些水土不服，我个人认为分支的管理需要结合团队规模、应用类型、发布流程等实际的情况来制定规范。下面我将介绍一种适用
      
    
    </summary>
    
      <category term="开发规范" scheme="http://liaojiacan.me/categories/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="开发规范" scheme="http://liaojiacan.me/tags/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    
      <category term="代码管理" scheme="http://liaojiacan.me/tags/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
      <category term="GIT" scheme="http://liaojiacan.me/tags/GIT/"/>
    
  </entry>
  
  <entry>
    <title>自定义ClassLoader实现一个支持热加载的应用启动器</title>
    <link href="http://liaojiacan.me/2019/03/17/%E8%87%AA%E5%AE%9A%E4%B9%89ClassLoader%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%94%AF%E6%8C%81%E7%83%AD%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E5%99%A8/"/>
    <id>http://liaojiacan.me/2019/03/17/自定义ClassLoader实现一个支持热加载的应用启动器/</id>
    <published>2019-03-17T08:46:00.000Z</published>
    <updated>2019-05-22T05:43:18.861Z</updated>
    
    <content type="html"><![CDATA[<p>JVM 默认是不支持Class的热加载的，也就是说我们的代码有变动，就要重启JVM来达到加载新的Class目的，但是很多容器如Tomcat、Jetty等都可以支持热加载，其底层的原理就是自定义ClassLoader。OSGI更是将类加载器玩到极至。我们来看看怎么实现一个简单的支持热加载的应用启动器。</p><h3 id="一-实现的目标"><a class="markdownIt-Anchor" href="#一-实现的目标"></a> 一、实现的目标</h3><ul><li>支持热加载</li><li>可配置的启动类</li></ul><h3 id="二-实现"><a class="markdownIt-Anchor" href="#二-实现"></a> 二、实现</h3><h4 id="1-支持热加载"><a class="markdownIt-Anchor" href="#1-支持热加载"></a> 1. 支持热加载</h4><p>关于类的加载，必然要说一下ClassLoader，JDK中存在这几个ClassLoader：</p><ul><li>BootstrapClassLoader 加载基础类</li><li>ExtClassLoader 加载拓展类，父加载器是BootstrapClassLoader</li><li>AppClassLoader 加载应用程序类 ，父加载器是ExtClassLoader</li></ul><p><strong>双亲委派：</strong><br>官方建议开发者，实现类加载器时遵循双亲委派规则，就是加载一个类时，先交给父加载器加载，如果父加载器无法加载，再由当前类加载器加载，从代码上来说，AppClassLoader已经写好了这个模版类，我们只需要覆盖findClass的逻辑即可。</p><blockquote><p>实现热加载需要违背双亲委派规则吗？</p></blockquote><p>由于ClassLoader中的defineClass方法会对已加载的类进行校验，所以我们无法对一个类进行重复加载，要实现热加载只能创建一个新的ClassLoader，假如我们采用双亲委派规则，那么我们需要加载的类会先被父加载器（AppClassLoader）给加载缓存起来，之后我们无论怎么创建一个新的加载器也无法达到热加载的目的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class HotSwapClassLoader extends ClassLoader &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 指定目录下的类可以热加载</span><br><span class="line"> */</span><br><span class="line">private String basePath;</span><br><span class="line"></span><br><span class="line">public HotSwapClassLoader(String basePath) &#123;</span><br><span class="line">this.basePath = basePath;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">// 加载指定目录下的class</span><br><span class="line">if (c == null) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">c = findClass(name);</span><br><span class="line">if (c != null) &#123;</span><br><span class="line">return c;</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">return super.loadClass(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return super.loadClass(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">String classResourcePath = this.basePath + &quot;/&quot; + name.replaceAll(&quot;\\.&quot;, &quot;/&quot;);</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">FileInputStream fileInputStream = new FileInputStream(new File(classResourcePath));</span><br><span class="line">ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();</span><br><span class="line">int len;</span><br><span class="line">byte[] buffer = new byte[1024];</span><br><span class="line">while ((len = fileInputStream.read(buffer)) &gt; 0) &#123;</span><br><span class="line">byteArrayOutputStream.write(buffer, 0, len);</span><br><span class="line">&#125;</span><br><span class="line">byte[] bytes = byteArrayOutputStream.toByteArray();</span><br><span class="line">return defineClass(name, bytes, 0, bytes.length);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">throw new ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-启动器"><a class="markdownIt-Anchor" href="#2-启动器"></a> 2. 启动器</h4><p>上面我们已经实现了一个可以随时替换的ClassLoader，我们还需要一个引导类去维护我们的ClassLoader 还有我们的应用启动入口，管理启动和关闭的时机，就好比Tomcat的Catalina一样，或者说我们的任何类的Main函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Bootstrap &#123;</span><br><span class="line"></span><br><span class="line">private String basePath;</span><br><span class="line">private Object application;</span><br><span class="line">private String applicationClassName;</span><br><span class="line">private volatile ClassLoader applicationClassLoader;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public Bootstrap(String basePath, String applicationClassName) &#123;</span><br><span class="line">this.basePath = basePath;</span><br><span class="line">this.applicationClassLoader = new HotSwapClassLoader(this.basePath);</span><br><span class="line">this.applicationClassName = applicationClassName;</span><br><span class="line">try &#123;</span><br><span class="line">this.application = getApplication();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了上面的那些成员，我们就可以利用Java的反射来实现自定义的Application类的启动（这个类可以方在任意位置，就好比我们的war包可以方在任意位置，只要在tomcat的server.xml中配置好baseApps的路径就好了）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void startApplication() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">this.application.getClass().getDeclaredMethod(&quot;start&quot;, null).invoke(this.application, new Object[0]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void stopApplication() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">this.application.getClass().getDeclaredMethod(&quot;stop&quot;, null).invoke(this.application, new Object[0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，剩下最后一个问题就是，我们怎么知道我们的类需要加载呢？有2种方式就是主动刷新，还有一种就是程序监听文件夹的文件变动。我们可以利用jdk7之后提供的WatchService来监控文件或者目录的变动情况，一发生变动，则先注销之前的Application 然后再创建一个新的HotSwapClassLoader来启动新的Application。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private void registerResourceWatcher() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">WatchService watchService = FileSystems.getDefault().newWatchService();</span><br><span class="line">Path p = Paths.get(basePath);</span><br><span class="line">p.register(watchService, new WatchEvent.Kind[]&#123;ENTRY_MODIFY, ENTRY_CREATE, ENTRY_DELETE&#125;);</span><br><span class="line">while (true) &#123;</span><br><span class="line">WatchKey k = watchService.take();</span><br><span class="line">for (WatchEvent&lt;?&gt; e : k.pollEvents()) &#123;</span><br><span class="line">reloadApplication();</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">k.reset();</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-测试"><a class="markdownIt-Anchor" href="#三-测试"></a> 三、测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">public Integer version = 46;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 应用的启动入口</span><br><span class="line"> */</span><br><span class="line">public void start() &#123;</span><br><span class="line">System.out.println(&quot;Start... version=&quot; + version);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 应用的停止入口</span><br><span class="line"> */</span><br><span class="line">public void stop() &#123;</span><br><span class="line">System.out.println(&quot;Stop... version=&quot; + version);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws IOException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">new Bootstrap(&quot;/Users/liaojiacan/Workspace/java/personal/code-snippets/java-language/target/classes&quot;</span><br><span class="line">,&quot;com.github.liaojiacan.classloader.app.Application&quot;).boot();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动后，我们修改Application的 version=47，然后rebuild project，这个时候这个文件就会发生改变,输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Start... version=46</span><br><span class="line">Stop... version=46</span><br><span class="line">Start... version=47</span><br></pre></td></tr></table></figure><p>完整代码见Github :<a href="https://github.com/liaojiacan/code-snippets/tree/master/java-language/src/main/java/com/github/liaojiacan/classloader" target="_blank" rel="noopener">https://github.com/liaojiacan/code-snippets/tree/master/java-language/src/main/java/com/github/liaojiacan/classloader</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JVM 默认是不支持Class的热加载的，也就是说我们的代码有变动，就要重启JVM来达到加载新的Class目的，但是很多容器如Tomcat、Jetty等都可以支持热加载，其底层的原理就是自定义ClassLoader。OSGI更是将类加载器玩到极至。我们来看看怎么实现一个简单
      
    
    </summary>
    
      <category term="JDK" scheme="http://liaojiacan.me/categories/JDK/"/>
    
    
      <category term="ClassLoader" scheme="http://liaojiacan.me/tags/ClassLoader/"/>
    
      <category term="热加载" scheme="http://liaojiacan.me/tags/%E7%83%AD%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Java中的多线程和锁实现原理</title>
    <link href="http://liaojiacan.me/2019/03/11/Java%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://liaojiacan.me/2019/03/11/Java中的多线程和锁实现原理/</id>
    <published>2019-03-11T09:19:00.000Z</published>
    <updated>2019-05-22T05:43:18.857Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程的实现"><a class="markdownIt-Anchor" href="#线程的实现"></a> 线程的实现</h2><p>Java 规范里面并没有规定JVM要如何实现线程模型，在HotSpot VM 中使用的是1:1的线程模型，即1个java线程对应一个OS的线程（内核线程），在Thread中又很多native方法，就是调用OS的函数进行用户线程和内核线程的绑定。</p><ul><li>每个线程都又一个内核线程与之绑定，用户线程推出，内核线程也会一起退出。</li><li>内核线程的数量是有限制的</li><li>内核线程调用，上下文切换开销很大。</li></ul><h3 id="线程调度"><a class="markdownIt-Anchor" href="#线程调度"></a> 线程调度</h3><h4 id="线程的状态-threadstate枚举"><a class="markdownIt-Anchor" href="#线程的状态-threadstate枚举"></a> 线程的状态 （Thread.State枚举）</h4><ul><li>NEW :</li><li>RUNNABLE : 对应的就绪和运行态</li><li>BLOCKED : 阻塞状态，处于阻塞状态的线程会不断地请求资源，请求成功后就会进入就绪状态。</li><li>WAITING : 等待状态，当线程调用wait,join,park等函数。等待状态下会释放资源，让出CPU和释放锁。需要其他线程唤醒。</li><li>TIMED_WAITING  有限的等待。</li><li>TERMINATED</li></ul><h3 id="线程相关的一些文章"><a class="markdownIt-Anchor" href="#线程相关的一些文章"></a> 线程相关的一些文章</h3><ul><li><a href="https://www.zhihu.com/question/27491155/answer/36847691" target="_blank" rel="noopener">Java的线程管理器能保证每个线程都有执行的机会么?</a></li><li><a href="http://www.hainiubl.com/topics/29" target="_blank" rel="noopener">wait/notify实现原理</a></li></ul><h2 id="锁"><a class="markdownIt-Anchor" href="#锁"></a> 锁</h2><p>因为多线程的共享数据存在线程安全问题，需要通过一些控制来保证共享数据的读写，JVM层面提供sychronized的锁，而java层面current包下面有许多基于AQS的Lock的实现,在jdk1.6后,synchronized 和 ReentrantLock性能上以及没有太大的差距，ReentrantLock的使用更佳灵活，性能稳定，支持超时机制等，而采用synchronized不需要程序自己控制锁的加锁和释放，不容易出现死锁等问题。</p><h3 id="synchronized-的实现原理"><a class="markdownIt-Anchor" href="#synchronized-的实现原理"></a> synchronized 的实现原理</h3><p>JVM规范规定基于进入和退出monitor对象来控制方法和代码块的同步，也是就是monitorenter和monitorexit两个指令，当程序执行到monitorenter指令时会尝试获取对象的monitor所有权，也就是获取对象的锁。在最开始的JVM实现中是采用重量级锁的实现，线程的切换都涉及到用户态到内核态的切换，比较消化资源，所以在jdk1.6对锁进行优化。</p><h4 id="同步原理"><a class="markdownIt-Anchor" href="#同步原理"></a> 同步原理</h4><blockquote><ul><li>JVM是怎么控制多线程程序的交替访问的？</li></ul></blockquote><p>Java中每个对象都有一个内置锁与之对应，所有需要对该对象进行排他性或者一致性访问时需要获取对象的内置锁（synchronized 中的代码，monitorenter指令）。这个内置锁的信息存在对象的对象头中（一些基本信息，其他的condition，队列等是在native heap中的）。一个对象的Monitor只能被一个线程获取到，其他线程得等待持有的Monitor的线程释放。</p><blockquote><p>在一些官方的注释中说的是ObjectMonitor是一个内联锁对象的封装，就好比JVM层面实现的一个类似JUC框架下的Lock（不是说ObjectMonitor是JUC的Lock实现，说的是他们可能实现思路是一样的）。</p></blockquote><p>做好线程的同步协调，我认为需要这3样东西（ObjectMonitor 和J.U.C的AQS 都是这样的）：</p><ol><li>维护一个竞争的互斥量</li><li>一个队列</li><li>线程的挂起和唤醒</li></ol><blockquote><p>实现同步也可以只用一个互斥量，自旋锁就是这么实现的，但是锁竞争太激烈会导致CPU做无用功。</p></blockquote><p>想继续了解ObjectMonitor的实现可以看这几篇文章：</p><ul><li><a href="http://moonfacex.github.io/blog/java/2016/03/31/synchronized_and_monitor.html" target="_blank" rel="noopener">synchronized 与 object’s Monitor</a></li><li><a href="https://www.hollischuang.com/archives/2030" target="_blank" rel="noopener">Moniter实现原理</a></li></ul><h4 id="对象头"><a class="markdownIt-Anchor" href="#对象头"></a> 对象头</h4><blockquote><ul><li>Object的锁信息是存在在哪里的？</li><li>在获取对象的锁的过程中都用到了对象头的哪些数据？</li></ul></blockquote><p>锁的信息存在java对象头里面。如果对象是数组，这虚拟机会用3个Word(32位虚拟机，32bit)来存对象头，如果对象是非数组类型，则用2个Word来存对象头，其中 有一个word用来存储对象的hashcode和锁信息，32bit，叫Mark word。</p><ul><li>Mark Word 不是一个固定的数据结构，具体的信息分布需要先判断2bit的锁标志位，不同的锁标志位，剩余的30bit可能表示不同的意思。</li><li>32bit的信息是不够存Monitor线程同步（调度）所需要的信息的，所以重量级锁是有另外的native heap存储的，之后再把指针存在Mark word 中。</li></ul><table width="500" border="1" cellspacing="0" cellpadding="0"><tbody><tr><td rowspan="2" valign="top" width="76"><strong>锁状态</strong></td><td colspan="3" valign="top" width="106"><p align="center">25 bit</p></td><td rowspan="2" valign="top" width="85"><p align="center">4bit</p></td><td valign="top" width="85">1bit</td><td valign="top" width="78">2bit</td></tr><tr><td colspan="2" valign="top" width="70">23bit</td><td valign="top" width="56">2bit</td><td valign="top" width="120">是否是偏向锁</td><td valign="top" width="100">锁标志位</td></tr><tr><td valign="top" width="90">轻量级锁</td><td colspan="5" valign="top" width="276">指向栈中锁记录的指针</td><td valign="top" width="78">00</td></tr><tr><td valign="top" width="76">重量级锁</td><td colspan="5" valign="top" width="276">指向互斥量（重量级锁）的指针</td><td valign="top" width="78">10</td></tr><tr><td valign="top" width="76">GC标记</td><td colspan="5" valign="top" width="276">空</td><td valign="top" width="78">11</td></tr><tr><td valign="top" width="76">偏向锁</td><td valign="top" width="80">线程ID</td><td colspan="2" valign="top" width="80">Epoch</td><td valign="top" width="120">对象分代年龄</td><td valign="top" width="85">1</td><td valign="top" width="78">01</td></tr></tbody></table><h4 id="锁的优化"><a class="markdownIt-Anchor" href="#锁的优化"></a> 锁的优化</h4><p>在jdk1.6之前synchronized是单纯的重量级锁实现，由于重量级锁，线程获取不到锁就需要挂起等待唤醒，这种切换涉及到了用户态到内核态的转换，开销还是比较大的。在jdk1.6加入了偏向锁、轻量级锁。只有一个线程请求对象锁的时候，启用的是偏向锁，当有第二个线程竞争的时候（应该说是偏向状态出现锁竞争），这个时候会升级为轻量级锁（cas 自旋锁），处于轻量级锁状态下，如果自旋10次（可以配置）还是获取锁失败，则锁升级为重量级锁。</p><ul><li><p>偏向锁 ：在大部分情况下一个同步方法或者一个同步代码块不存在多线程的竞争，这样只需要在对象头和当前线程的栈帧中存一个线程ID，每次获取锁的时候只需要判断一些线程ID释放一致就行了，不用进行CAS的加锁和解锁。如果有第二个线程需要竞争锁，这个时候会通过CAS设置Mark Word中的锁状态位，成功则修改为偏向当前线程，失败的话就进行锁的升级，锁升级涉及到偏向锁的撤销，会将偏向锁线程挂起。</p><blockquote><p><a href="https://stackoverflow.com/questions/14717736/where-is-objects-hash-code-stored-if-biased-locking-is-enabled-in-hotspot-jvm" target="_blank" rel="noopener">偏向锁会将Mark Word设置为当前threadId，那么hashCode存哪里了?</a><br>如果处于偏向的的对象调用的hashCode方法就会触发撤销偏向锁</p></blockquote></li><li><p>轻量级锁：线程在获取锁之前，当前线程会在栈帧中创建一个Mark Word的拷贝作为锁记录，官方称为Displaced Mark Word。然后将对象头中替换成锁记录的指针（CAS），如果失败则会自旋10次（在1.6之后是采用自适应锁，这个时间已经不能自己配置了），之后升级为重量级锁。</p><blockquote><p>为什么一定要拷贝到Displaced Mark Word，而不直接就采用一个threadId？一个原因是需要恢复hash和GC分代的信息，一个就是解决重入锁的问题。</p></blockquote></li><li><p>重量级锁：ObjectMonitor有更多的空间来实现线程同步，可以更好像的实现线程同步（挂起和唤醒）。<a href="https://www.zhihu.com/question/41930877/answer/136699311" target="_blank" rel="noopener">轻量级锁为什么要膨胀？</a></p></li></ul><h4 id="优缺点"><a class="markdownIt-Anchor" href="#优缺点"></a> 优缺点</h4><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>使用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>只需比较threadId释放是否是当前线程<br>没有CAS的消耗</td><td>当出现锁竞争的时候会有锁撤销的消耗</td><td>单个线程</td></tr><tr><td>轻量级锁</td><td>线程一直在用户态，不用挂起。没有线程切换的消耗</td><td>自旋会导致CPU做无用功</td><td>同步代码块执行较快。</td></tr><tr><td>重量级锁</td><td>线程挂起，不用进行自旋</td><td>用户态到内核态转化，开销大</td><td>同步代码块执行时间较长，锁竞争激烈</td></tr></tbody></table><h3 id="juc中的锁"><a class="markdownIt-Anchor" href="#juc中的锁"></a> J.U.C中的锁</h3><p>上面锁的synchronzied是JVM的内置锁，在1.6之前性能比较差，Doug Lea就写个并发框架(java.util.current)，在1.6之后synchronized的性能已经跟Lock查不不多了，但是还少了锁的获取和释放的操作性，不支持超时，只有一个condition等。</p><h4 id="aqs"><a class="markdownIt-Anchor" href="#aqs"></a> AQS</h4><p>AbstractQueueSynchronizer是J.U.C中其他锁或者同步器的基础框架（ReentrantLock,ReentrantReadWriteLock,CountdDownLatch,CyclicBarrier等），这些框架在AQS的基础上进行了扩展，通常是继承AQS然后实现了AQS的几个抽象方法。</p><blockquote><p>我在上面说ObjectMonitor有说到，同步器为了完成同步工作，需要3个东西：</p></blockquote><ol><li>用于同步的状态量</li><li>一个队列或者一个保存等待线程的容器</li><li>线程的挂起和唤醒</li></ol><p>我们看下AQS是怎么围绕这3个部分进行实现的。</p><h5 id="1-同步的状态量互斥量"><a class="markdownIt-Anchor" href="#1-同步的状态量互斥量"></a> 1. 同步的状态量(互斥量)</h5><p>AQS中维护一个volatile 的int 变量state，线程通过cas来获取这个互斥量。AQS提供一下几个方法来对state变量进行操作。</p><ul><li>getState()</li><li>compareAndSetState(int expect, int update)</li><li>setState(int state)</li></ul><p>有了上面的3个方法，同步器就可以实现自旋锁，但是如果想实现公平锁，上面的三个方法或者说单用一个state变量是无法做到了。这个时候就需要一个FIFO的队列来维护这些线程。此外为了实现重入锁，我们还得需要一个变量来存当前持有的锁是什么线程。</p><h5 id="2等待线程队列"><a class="markdownIt-Anchor" href="#2等待线程队列"></a> 2.等待线程队列</h5><p>AQS 用了一个CLH的双向队列，Node的数据结构大概如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">statci final class Node&#123;</span><br><span class="line">    </span><br><span class="line">    volatile int waitStatus;</span><br><span class="line">    volatile Node prev;</span><br><span class="line">    volatile Node next;</span><br><span class="line">    Node nextWaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS维护一个头节点和一个尾节点，入队的时候通过CAS加入到未尾节点中。入队后开始开始自旋。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            // 前趋节点是头节点，并且获取到互斥量，说明获取锁成功。</span><br><span class="line">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = null; // help GC</span><br><span class="line">                failed = false;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            // 判断是否需要挂起</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码片段可以看出，加入队列的线程节点并不是完全的自旋，shouldParkAfterFailedAcquire方法判断当前线程是否需要挂起。</p><blockquote><p>下面的这个方法表明shouldParkAfterFailedAcquire 会在调用1到2次后会返回true（如果期间节点没有发生改变的话）。也就是自旋锁只自旋了2次就会被挂起。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">        int ws = pred.waitStatus;</span><br><span class="line">        if (ws == Node.SIGNAL)</span><br><span class="line">            /*</span><br><span class="line">             * This node has already set status asking a release</span><br><span class="line">             * to signal it, so it can safely park.</span><br><span class="line">             */</span><br><span class="line">            return true;</span><br><span class="line">        if (ws &gt; 0) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * Predecessor was cancelled. Skip over predecessors and</span><br><span class="line">             * indicate retry.</span><br><span class="line">             */</span><br><span class="line">            do &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /* </span><br><span class="line">             * 进行到这里说明前驱节点的waitStatus 是0 或者PROPAGATE ，利用CAS的设置为SIGNAL，这样下次自旋就会阻塞了，这里不返回true的目的是让当前线程再自旋一次，确保挂起前是无法获取到锁（避免发生刚挂起就被唤醒的情况）。</span><br><span class="line">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="line">             * need a signal, but don&apos;t park yet.  Caller will need to</span><br><span class="line">             * retry to make sure it cannot acquire before parking.</span><br><span class="line">             */</span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="3线程的挂起和唤醒"><a class="markdownIt-Anchor" href="#3线程的挂起和唤醒"></a> 3.线程的挂起和唤醒</h5><p>AQS中实现线程的挂起和唤醒是通过LockSupport这个工具，LockSupport的底层实现是调用Unsafe的native方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void unpark(Thread thread) &#123;</span><br><span class="line">    if (thread != null)</span><br><span class="line">        UNSAFE.unpark(thread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void park(Object blocker) &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    setBlocker(t, blocker);</span><br><span class="line">    UNSAFE.park(false, 0L);</span><br><span class="line">    setBlocker(t, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="conditionobject"><a class="markdownIt-Anchor" href="#conditionobject"></a> ConditionObject</h5><p>ConditionObject 是AQS实现类似object类的wait/notify/notifyAll方法的，ConditionObject提供的是aw<br>ait/awaitNanos(long nanos)/awaitUtil(Date date)/awaitUniterrutibly()/signal()/signalAll()。底层的实现也是各自维护一个队列，Node.nextWaiter。</p><ul><li>对于超时机制也是用LockSupport中的实现，但并不是所有情况下都使用系统的休眠，有个休眠的自旋时间阀值<code>spinForTimeoutThreshold = 1000L</code> ，默认是1000 纳秒，少于这个阀值的都不用休眠，而是直接自旋。</li></ul><h3 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h3><ul><li><a href="http://moonfacex.github.io/blog/java/2016/03/31/synchronized_and_monitor.html" target="_blank" rel="noopener">synchronized 与 object’s Monitor</a></li><li><a href="http://ifeve.com/introduce-abstractqueuedsynchronizer/" target="_blank" rel="noopener">AbstractQueuedSynchronizer的介绍和原理分析</a></li><li><a href="https://blog.csdn.net/chenssy/article/details/65449785" target="_blank" rel="noopener">J.U.C之AQS：阻塞和唤醒线程</a></li><li><a href="https://blog.csdn.net/m_xiaoer/article/details/73274642" target="_blank" rel="noopener">关于synchronized的Monitor Object机制的研究</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html" target="_blank" rel="noopener">Intrinsic Locks and Synchronization</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;线程的实现&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#线程的实现&quot;&gt;&lt;/a&gt; 线程的实现&lt;/h2&gt;
&lt;p&gt;Java 规范里面并没有规定JVM要如何实现线程模型，在HotSpot VM 中使用的是1:1的线程模型，即1个java线程对
      
    
    </summary>
    
      <category term="jdk" scheme="http://liaojiacan.me/categories/jdk/"/>
    
    
      <category term="多线程" scheme="http://liaojiacan.me/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="synchronized" scheme="http://liaojiacan.me/tags/synchronized/"/>
    
      <category term="AQS" scheme="http://liaojiacan.me/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>Innodb中的锁总结</title>
    <link href="http://liaojiacan.me/2019/02/28/Innodb%E4%B8%AD%E7%9A%84%E9%94%81%E6%80%BB%E7%BB%93/"/>
    <id>http://liaojiacan.me/2019/02/28/Innodb中的锁总结/</id>
    <published>2019-02-28T11:22:00.000Z</published>
    <updated>2019-05-22T05:43:18.856Z</updated>
    
    <content type="html"><![CDATA[<h3 id="锁的种类"><a class="markdownIt-Anchor" href="#锁的种类"></a> 锁的种类</h3><h4 id="表锁"><a class="markdownIt-Anchor" href="#表锁"></a> 表锁</h4><ul><li>LOCK TABLE <em>table_name</em> READ : 用读锁锁表，阻塞其他事务修改</li><li>LOCK TABLE <em>table_name</em> WRITE: 用写锁锁表，阻塞其他事务读和写</li></ul><h4 id="行锁"><a class="markdownIt-Anchor" href="#行锁"></a> 行锁</h4><ul><li>X锁：排他锁，允许对数据进行删除和更新/插入</li><li>S锁：共享锁，允许对数据进行读取，可理解为读锁</li></ul><blockquote><p>锁的兼容性：如果两个事务能对一行数据同时加锁，就认为这个锁是兼容的，如果是要等待其他事务释放，则认为这2个锁是不兼容的。</p></blockquote><table><thead><tr><th>*</th><th>X</th><th>S</th></tr></thead><tbody><tr><td>X</td><td>不兼容</td><td>不兼容</td></tr><tr><td>S</td><td>不兼容</td><td>兼容</td></tr></tbody></table><h4 id="意向锁"><a class="markdownIt-Anchor" href="#意向锁"></a> 意向锁</h4><p>MySQL innodb 是支持多粒度锁的，比如可以同时存在表锁和行锁，为了更好的实现多粒度锁，innodb引入了意向锁，在innodb中的意向锁是表级的锁，意向锁与意向锁之间是兼容了，假如不存在表锁，不会有事务在加意向锁的时候阻塞。</p><ul><li>IS锁：意向共享锁，表明表中存在一行或者多行的S锁，即在给一行数据加S锁之前必在这个表加IS锁。</li><li>IX锁：意向排他锁，表明表中存在一行或者多行的X锁，即在给一行数据加S锁之前必在这个表加IX锁。</li></ul><blockquote><p>思考：为什么需要这个意向锁？</p></blockquote><p>我们比如思考一下这个场景，事务1给某个表中的N行加了行锁，这个时候事务2想给这个表加个表锁，那么事务2需要确认的事情有：</p><ol><li>这个表是否存在不兼容的表锁，比如我想加个X锁，但是已经有其他事务加了S锁。</li><li>这个表中是否已经存在不兼容的行锁。</li></ol><p>显然在确认第二个条件时，如果采用全表扫描的话，效率太低，所以意向锁的目的就是在粗粒度的锁（表锁）可以快速判断是否与低粒度的锁存在冲突。</p><table><thead><tr><th>*</th><th>IX</th><th>S</th><th>IS</th></tr></thead><tbody><tr><td>X</td><td>不兼容</td><td>不兼容</td><td>不兼容</td></tr><tr><td>IX</td><td>不兼容</td><td>兼容</td><td>不兼容</td></tr><tr><td>S</td><td>不兼容</td><td>不兼容</td><td>兼容</td></tr><tr><td>IS</td><td>不兼容</td><td>兼容</td><td>兼容</td></tr></tbody></table><h3 id="innodb行锁的形式或者算法"><a class="markdownIt-Anchor" href="#innodb行锁的形式或者算法"></a> innodb行锁的形式或者算法</h3><blockquote><p>Innodb中行锁都是加在索引上的，针对不同的场景都有不同的加锁策略。</p></blockquote><h4 id="record-lock"><a class="markdownIt-Anchor" href="#record-lock"></a> Record Lock</h4><p>记录锁，顾名思义就是锁住记录本身，锁主主键和唯一索引，如果表中没有加任何索引，锁会加在隐式生成的主键上。</p><h4 id="gap-lock"><a class="markdownIt-Anchor" href="#gap-lock"></a> Gap Lock</h4><p>间隙锁，当存在范围扫描的时候，给扫描范围加间隙锁，[起始地址，终止)</p><ol><li>不同事务对同一个区间加间隙锁是不冲突的，所以S Gap Lock 和 X Gap Lock不存在区别。</li><li>READ_COMMITED 隔离级别下不会启用间隙锁。</li></ol><h4 id="next-key-lock"><a class="markdownIt-Anchor" href="#next-key-lock"></a> Next Key Lock</h4><p>临键锁，Record Lock + Gap Lock ,锁主当前值区间+下一个区间(不一定)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10, 11, 13, 20</span><br><span class="line">(negative infinity, 10]</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, positive infinity)</span><br></pre></td></tr></table></figure><ol><li>解决的是当前读下的幻读问题。</li></ol><h4 id="insert-intention-lock"><a class="markdownIt-Anchor" href="#insert-intention-lock"></a> Insert Intention Lock</h4><p>插入意向锁，是一种特殊的间隙锁；insert之前会向插入区间加上Insert Intention Lock。</p><ol><li>Gap Lock / Next key Lock 与 Insert Intention Lock不兼容。</li><li>Gap lock 和Next key lock 的目的就是防止有数据插入间隙</li></ol><h3 id="不同sql产生的锁"><a class="markdownIt-Anchor" href="#不同sql产生的锁"></a> 不同SQL产生的锁</h3><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locks-set.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-locks-set.html</a></p><ol><li>SELECT…FROM</li></ol><blockquote><p>一致性非锁定读，除了在 SERIALIZABLE隔离级别下会存在S锁，其他隔离级别下都不会有锁。</p></blockquote><ol start="2"><li>SELECT…FOR UPDATE/SELECT…LOCK IN SHARE MODE</li></ol><blockquote><ul><li>也叫做当前读，会在给扫描过程中的索引加X或S锁，跟Where条件实际上没有强关系，只跟扫描的过程有关，所以where条件是否能够命中索引比较重要。</li><li>在检索的过程中会给用到的索引加Next Key Lock。不过如果检索条件是唯一索引能定位到一行数据，则只加Record Lock</li></ul></blockquote><ol start="3"><li>UPDATE…WHERE…</li></ol><blockquote><p>同样给检索到的记录加next key lock, 如果WHERE条件中是使用主键或者唯一索引进行限定的话，只在索引加了Record Lock。<br>如果UPDATE的是聚簇索引记录，会对受影响的辅助索引加隐式锁，当有新的辅助索引插入前的重复检测，以及在执行插入新的辅助索引记录时，对受影响的索引记录加S锁。</p></blockquote><ol start="4"><li>DELETE FROM … WHERE …</li></ol><blockquote><p>与UPDATE基本一致</p></blockquote><ol start="5"><li>INSERT</li></ol><blockquote><ul><li>给插入索引的记录加一个X锁</li><li>插入前前会加个Insert Intention Lock。</li><li>如果发生唯一键异常（duplicate-key error ），会在原记录上加S锁，这个如果和delete和update一起使用可能会导致死锁。</li></ul></blockquote><ol start="6"><li>INSERT … ON DUPLICATE KEY UPDATE</li></ol><blockquote><ul><li>跟INSERT语句有点不同的就是，当发生重复键异常是，这里加的是排他锁，而不是共享锁。</li><li>如果是唯一键异常，则加的是Next key lock。</li></ul></blockquote><ol start="7"><li>REPLACE</li></ol><blockquote><ul><li>如果没有发生冲突，则行为跟INSERT是一致的。</li><li>如果发生冲突，则对唯一键加的是Next key lock。</li></ul></blockquote><ol start="8"><li>INSERT INTO T SELECT … FROM S WHERE …</li></ol><blockquote><ul><li>给子查询语句加的X锁。</li><li>如果是READ COMMITED 隔离基本，则采用的是快照读</li></ul></blockquote><ol start="9"><li>外键约束</li></ol><blockquote><p>在进行外键约束检测时，会给记录加行级共享锁。</p></blockquote><h3 id="死锁"><a class="markdownIt-Anchor" href="#死锁"></a> 死锁</h3><blockquote><p>死锁是只当2个或者2个以上的事务抢占各自的资源，导致的相互等待的现象。</p></blockquote><h4 id="案例"><a class="markdownIt-Anchor" href="#案例"></a> 案例</h4><ol><li><a href="http://liaojiacan.me/2019/02/27/Insert-ignore-%E5%92%8Cupdate-%E5%AF%BC%E8%87%B4%E7%9A%84%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/">Insert-ignore-和update-导致的死锁问题分析</a></li></ol><h4 id="解决死锁和进行死锁检测"><a class="markdownIt-Anchor" href="#解决死锁和进行死锁检测"></a> 解决死锁和进行死锁检测</h4><ol><li>设置超时时间,事务有限时间超时,回滚其中一个事务。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;%innodb_lock_wait_timeout%&quot;;</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">| Variable_name            | Value |</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">| innodb_lock_wait_timeout | 50    |</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">1 row in set (0.07 sec)</span><br></pre></td></tr></table></figure><ol start="2"><li>wait-graph 等待图死锁检测</li></ol><ul><li>锁的信息链</li><li>事务等待链</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;锁的种类&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#锁的种类&quot;&gt;&lt;/a&gt; 锁的种类&lt;/h3&gt;
&lt;h4 id=&quot;表锁&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#表锁&quot;&gt;&lt;/a&gt; 表锁&lt;/h4&gt;
&lt;ul&gt;
      
    
    </summary>
    
      <category term="数据库" scheme="http://liaojiacan.me/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Innodb" scheme="http://liaojiacan.me/tags/Innodb/"/>
    
  </entry>
  
  <entry>
    <title>Insert ignore 和update 导致的死锁问题分析</title>
    <link href="http://liaojiacan.me/2019/02/27/Insert-ignore-%E5%92%8Cupdate-%E5%AF%BC%E8%87%B4%E7%9A%84%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <id>http://liaojiacan.me/2019/02/27/Insert-ignore-和update-导致的死锁问题分析/</id>
    <published>2019-02-27T12:13:00.000Z</published>
    <updated>2019-05-22T05:43:18.857Z</updated>
    
    <content type="html"><![CDATA[<h3 id="业务逻辑以及死锁现象"><a class="markdownIt-Anchor" href="#业务逻辑以及死锁现象"></a> 业务逻辑以及死锁现象</h3><p>业务逻辑大概如下：</p><ol><li>在粉丝表新增一条关系记录。</li><li>假如关注者也是当前用户的粉丝，则更新2者的标记为相互关注。</li></ol><p>业务代码如下, 最初是考虑用insert ignore 来解决幂等的问题，所以<strong>允许重复调用</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//是否 关注的用户是操作者的粉丝（互粉）</span><br><span class="line">boolean isHisFans = fansDao.isFans(fansUserId,followingUserId);</span><br><span class="line"></span><br><span class="line">//insert ignore into </span><br><span class="line">//  fans(fans_user_id,following_user_id,following_each_other)</span><br><span class="line">//values(#&#123;fansUserId&#125;, #&#123;followingUserId&#125;,#&#123;followingEachOther&#125;)</span><br><span class="line">int updateNum = fansDao.addFans(fansUserId, followingUserId,isHisFans);</span><br><span class="line"></span><br><span class="line">boolean addAndCheck = false;</span><br><span class="line"></span><br><span class="line">if(isHisFans)&#123;</span><br><span class="line">    // update fans</span><br><span class="line">// set following_each_other = #&#123;followingEachOther&#125;</span><br><span class="line">// where (fans_user_id = #&#123;fansUserId&#125; and following_user_id =  #&#123;followingUserId&#125; ) or (fans_user_id = #&#123;followingUserId&#125; and following_user_id = #&#123;fansUserId&#125; )</span><br><span class="line">int num = fansDao.setFollowingEachOther(followingUserId,fansUserId,true);</span><br><span class="line">if( num &gt;0 )&#123;</span><br><span class="line">//重新调整数据</span><br><span class="line">addAndCheck = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线上产生的死锁的信息(show engine innodb status)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">LATEST DETECTED DEADLOCK</span><br><span class="line">------------------------</span><br><span class="line">2019-02-12 23:24:45 7fa406a4f700</span><br><span class="line">*** (1) TRANSACTION:</span><br><span class="line">TRANSACTION 515545684, ACTIVE 0 sec starting index read</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">LOCK WAIT 3 lock struct(s), heap size 1184, 2 row lock(s)</span><br><span class="line">MySQL thread id 2121, OS thread handle 0x7fa406b12700, query id 1702086 10.10.17.63 jb-glive Searching rows for update</span><br><span class="line">update fans</span><br><span class="line">set following_each_other = 1</span><br><span class="line">where (fans_user_id = &apos;1776093&apos; and following_user_id = &apos;1331089&apos; ) or (fans_user_id = &apos;1331089&apos; and following_user_id = &apos;1776093&apos; )</span><br><span class="line">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 1023 page no 37913 n bits 400 index `UK_USER_ID` of table `glive`.`fans` trx id 515545684 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 334 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 7; hex 31333331303839; asc 1331089;;</span><br><span class="line"> 1: len 7; hex 31373736303933; asc 1776093;;</span><br><span class="line"> 2: len 8; hex 8000000001282c31; asc      (,1;;</span><br><span class="line"></span><br><span class="line">*** (2) TRANSACTION:</span><br><span class="line">TRANSACTION 515545683, ACTIVE 0 sec starting index read</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">5 lock struct(s), heap size 1184, 4 row lock(s)</span><br><span class="line">MySQL thread id 3485, OS thread handle 0x7fa406a4f700, query id 1702085 10.10.17.61 jb-glive Searching rows for update</span><br><span class="line">update fans</span><br><span class="line">set following_each_other = 1</span><br><span class="line">where (fans_user_id = &apos;1776093&apos; and following_user_id = &apos;1331089&apos; ) or (fans_user_id = &apos;1331089&apos; and following_user_id = &apos;1776093&apos; )</span><br><span class="line">*** (2) HOLDS THE LOCK(S):</span><br><span class="line">RECORD LOCKS space id 1023 page no 37913 n bits 400 index `UK_USER_ID` of table `glive`.`fans` trx id 515545683 lock_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 334 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 7; hex 31333331303839; asc 1331089;;</span><br><span class="line"> 1: len 7; hex 31373736303933; asc 1776093;;</span><br><span class="line"> 2: len 8; hex 8000000001282c31; asc      (,1;;</span><br><span class="line"></span><br><span class="line">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 1023 page no 38446 n bits 360 index `UK_USER_ID` of table `glive`.`fans` trx id 515545683 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 294 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 7; hex 31373736303933; asc 1776093;;</span><br><span class="line"> 1: len 7; hex 31333331303839; asc 1331089;;</span><br><span class="line"> 2: len 8; hex 8000000001282c59; asc      (,Y;;</span><br><span class="line"></span><br><span class="line">*** WE ROLL BACK TRANSACTION (1)</span><br></pre></td></tr></table></figure><p>锁分析：</p><ol><li>事务T2持有 (fans_user_id=1331089,following_user_id=1776093,主键=hex8000000001282c31) X 锁；</li><li>事务T2等待行锁<br>(fans_user_id=1776093,following_user_id=1331089,主键=hex8000000001282c59) X 锁；</li><li>事务T1等待T2持有的锁。</li><li>事务T1此时应该还持有T2等待的锁，只是没显示出来。</li></ol><blockquote><p>看起来就是典型的AB-BA问题</p></blockquote><h2 id="重现"><a class="markdownIt-Anchor" href="#重现"></a> 重现</h2><p>我们先简化上面的业务代码逻辑，假设fans_user_id=11000,following_user_id=10086，其实就是执行2个SQL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. insert ignore into fans(fans_user_id,following_user_id) values(11000,10086);</span><br><span class="line">2. update fans set following_each_other = 1</span><br><span class="line">where (fans_user_id = &apos;11000&apos; and following_user_id = &apos;10086&apos; ) </span><br><span class="line">or (fans_user_id = &apos;10086&apos; and following_user_id = &apos;11000&apos; );</span><br></pre></td></tr></table></figure><p>场景一：不存在fans_user_id=11000,following_user_id=10086的这条数据。</p><table><thead><tr><th>T1</th><th>T2</th></tr></thead><tbody><tr><td>&gt;begin;</td><td>&gt;begin;</td></tr><tr><td>insert ignore into fans(fans_user_id,following_user_id)<br> values(11000,10086);</td><td>*</td></tr><tr><td>*</td><td>insert ignore into fans(fans_user_id,following_user_id)<br> values(11000,10086); //阻塞</td></tr><tr><td>update fans<br> set following_each_other = 1 <br> where (fans_user_id = ‘11000’ and following_user_id = ‘10086’ ) <br> or (fans_user_id = ‘10086’ and following_user_id = ‘11000’ )</td><td>*</td></tr><tr><td>commit;</td><td>insert 语句开始执行</td></tr><tr><td>*</td><td>update fans<br> set following_each_other = 1 <br> where (fans_user_id = ‘11000’ and following_user_id = ‘10086’ ) <br> or (fans_user_id = ‘10086’ and following_user_id = ‘11000’ )</td></tr><tr><td>*</td><td>commit;</td></tr></tbody></table><blockquote><p>分析：</p><ol><li>由于数据库并没有这条记录，所以<strong>事务T1</strong>在执行insert ignore into 时可以执行成功，并给这行数据加了X锁。</li><li><strong>事务T2</strong>在执行insert ignore into 时由于获取不到行锁，直接阻塞。</li><li>后面都是顺序执行，所以并不会出现死锁的问题。</li></ol></blockquote><p>场景二：数据库已经存在fans_user_id=11000,following_user_id=10086的这条数据。</p><table><thead><tr><th>T1</th><th>T2</th></tr></thead><tbody><tr><td>&gt;begin;</td><td>&gt;begin;</td></tr><tr><td>insert ignore into fans(fans_user_id,following_user_id)<br> values(11000,10086);</td><td>*</td></tr><tr><td>*</td><td>insert ignore into fans(fans_user_id,following_user_id)<br> values(11000,10086); //执行成功</td></tr><tr><td>update fans<br> set following_each_other = 1 <br> where (fans_user_id = ‘11000’ and following_user_id = ‘10086’ ) <br> or (fans_user_id = ‘10086’ and following_user_id = ‘11000’ )</td><td>*</td></tr><tr><td>阻塞等待</td><td>*</td></tr><tr><td>*</td><td>update fans<br> set following_each_other = 1 <br> where (fans_user_id = ‘11000’ and following_user_id = ‘10086’ ) <br> or (fans_user_id = ‘10086’ and following_user_id = ‘11000’ )</td></tr><tr><td>*</td><td>Deadlock found when trying to get lock; <br>try restarting transaction</td></tr></tbody></table><blockquote><p>分析：</p><ol><li>由于数据库已经存在该记录，所以事务T1执行insert ignore into 会插入失败，并给该记录加了个S锁。</li><li>由于S锁是相互兼容的，所以事务T2也给该记录加了S锁。</li><li>T1继续执行update语句，尝试给2行数据加X锁，但是其中有一行数据已经被T2加了S锁，此时T1回到等待队列中继续等待。</li><li>T2继续执行update语句，尝试给2行数据加X锁，但是发现T1已经对这2行数据请求了X锁，且在等待T2释放S锁，而T1又因为T2不释放S锁而无法升级为X锁。</li></ol><p>可以参考mysql官方的例子，原理是一样的。<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-deadlock-example.html" target="_blank" rel="noopener">innodb-死锁例子</a></p></blockquote><p>下面是场景二的DEADLOCK信息（show engine innodb status），你会发现其实跟生产环境的锁是又区别的，线上的死锁信息中T2 持有的是一个X锁（这个不知道怎么解释，无法重现）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">LATEST DETECTED DEADLOCK</span><br><span class="line">------------------------</span><br><span class="line">2019-02-27 14:15:00 0x7000034b5000</span><br><span class="line">*** (1) TRANSACTION:</span><br><span class="line">TRANSACTION 620686, ACTIVE 19 sec starting index read</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">LOCK WAIT 5 lock struct(s), heap size 1136, 4 row lock(s)</span><br><span class="line">MySQL thread id 63, OS thread handle 123145355350016, query id 1172740 localhost 127.0.0.1 root updating</span><br><span class="line">update fans</span><br><span class="line">set following_each_other = 1</span><br><span class="line">where (fans_user_id = &apos;11000&apos; and following_user_id = &apos;10086&apos; ) or (fans_user_id = &apos;10086&apos; and following_user_id = &apos;11000&apos; )</span><br><span class="line">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 107 page no 7 n bits 624 index UK_USER_ID of table `test`.`fans` trx id 620686 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 280 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 5; hex 3131303030; asc 11000;;</span><br><span class="line"> 1: len 5; hex 3130303836; asc 10086;;</span><br><span class="line"> 2: len 8; hex 800000000143abeb; asc      C  ;;</span><br><span class="line"></span><br><span class="line">*** (2) TRANSACTION:</span><br><span class="line">TRANSACTION 620687, ACTIVE 16 sec starting index read</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">3 lock struct(s), heap size 1136, 2 row lock(s)</span><br><span class="line">MySQL thread id 61, OS thread handle 123145357578240, query id 1172741 localhost 127.0.0.1 root updating</span><br><span class="line">update fans</span><br><span class="line">set following_each_other = 1</span><br><span class="line">where (fans_user_id = &apos;11000&apos; and following_user_id = &apos;10086&apos; ) or (fans_user_id = &apos;10086&apos; and following_user_id = &apos;11000&apos; )</span><br><span class="line">*** (2) HOLDS THE LOCK(S):</span><br><span class="line">RECORD LOCKS space id 107 page no 7 n bits 624 index UK_USER_ID of table `test`.`fans` trx id 620687 lock mode S</span><br><span class="line">Record lock, heap no 280 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 5; hex 3131303030; asc 11000;;</span><br><span class="line"> 1: len 5; hex 3130303836; asc 10086;;</span><br><span class="line"> 2: len 8; hex 800000000143abeb; asc      C  ;;</span><br><span class="line"></span><br><span class="line">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 107 page no 7 n bits 624 index UK_USER_ID of table `test`.`fans` trx id 620687 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 279 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 5; hex 3130303836; asc 10086;;</span><br><span class="line"> 1: len 5; hex 3131303030; asc 11000;;</span><br><span class="line"> 2: len 8; hex 800000000143abdb; asc      C  ;;</span><br><span class="line"></span><br><span class="line">*** WE ROLL BACK TRANSACTION (2)</span><br></pre></td></tr></table></figure><h2 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h2><p>在这个案例中，发生死锁的原因主要是insert ignore 在数据已经存在时只是加了S锁。所以解决的办法其实又几个。</p><ol><li>使用其他的幂等处理办法，不要依赖insert ignore。在这个案例中，其实应该直接使用insert，不允许重复执行，可以捕获唯一key异常来获取updateNum进行下个业务处理。</li><li>直接在业务开头使用select for … update 来加排他锁保证业务是串形执行（只是从死锁这个问题考虑，如果考虑性能需要找其他方案）。</li><li>假如就非得使用insert ignore 和 update，那么我们可以考虑在这个业务加个重试，数据库的死锁并不是致命的，设置好数据库的事物超时时间，然后遇到死锁问题，我们可以在业务进行重试解决。</li></ol><h2 id="未分析清楚的点"><a class="markdownIt-Anchor" href="#未分析清楚的点"></a> 未分析清楚的点</h2><ol><li>为什么线上的锁他是一个X锁，并不是一个S锁？是否有场景三？MySQL官方文档有一段话，感觉有点关联，但是无法对应上现象,说的是insert 和 delete 语句其实并不是真正原子的行锁。</li></ol><blockquote><p>InnoDB uses automatic row-level locking. You can get deadlocks even in the case of transactions that just insert or delete a single row. That is because these operations are not really “atomic”; they automatically set locks on the (possibly several) index records of the row inserted or deleted.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;业务逻辑以及死锁现象&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#业务逻辑以及死锁现象&quot;&gt;&lt;/a&gt; 业务逻辑以及死锁现象&lt;/h3&gt;
&lt;p&gt;业务逻辑大概如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在粉丝表新增一条关系记录。&lt;/li&gt;
&lt;li&gt;假如
      
    
    </summary>
    
      <category term="死锁" scheme="http://liaojiacan.me/categories/%E6%AD%BB%E9%94%81/"/>
    
    
      <category term="MySQL" scheme="http://liaojiacan.me/tags/MySQL/"/>
    
      <category term="innodb" scheme="http://liaojiacan.me/tags/innodb/"/>
    
  </entry>
  
  <entry>
    <title>JDK1.7 ConcurrentHashMap的源码解读</title>
    <link href="http://liaojiacan.me/2019/02/26/JDK1-7-ConcurrentHashMap%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>http://liaojiacan.me/2019/02/26/JDK1-7-ConcurrentHashMap的源码解读/</id>
    <published>2019-02-26T03:18:00.000Z</published>
    <updated>2019-05-22T05:43:18.857Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-concurrenthashmap的数据结构jdk7"><a class="markdownIt-Anchor" href="#一-concurrenthashmap的数据结构jdk7"></a> 一、 ConcurrentHashMap的数据结构(JDK7)。</h3><ol><li>segments[] : Segment&lt;K,V&gt; extends ReentrantLock</li></ol><blockquote><p><strong>分段锁</strong>，HashMap 用一个Entry[] table 去存数据，ConcurrentHashMap 则是将 这个table 拆分出 n 个段（一个最接近concurrencyLevel的2的幂）分别存储，Segment 中的 用一个HashEntry table[] 来存数据，table中hash冲突的解决算法基本与HashMap一致。同一个段的put和get操作是需要加锁的，Segment继承了ReentrantLock 故有了锁的功能。</p></blockquote><ol start="2"><li>concurrencyLevel : int</li></ol><blockquote><p><strong>并发等级</strong>，默认是16，可以在构造函数指定该值，这个值直接影响segment数组的大小。如果这个值不是2的幂，则会计算出一个最接近（向上取）的2的幂来初始化segments数组。</p></blockquote><ol start="3"><li>segmentMask : int</li></ol><blockquote><p><strong>掩码</strong>，是一个bit位都是1的数，跟segments的长度有关，比如默认segments的长度是16=2的4次方（二进制为10000）。假如我们需要获取到一个数落在[0,16) 这个区间，则只需要用这个数跟1111做与运算, 得到的结果肯定是落在0到16之间，这个比取模运算更加高效。</p></blockquote><ol start="4"><li>segmentShift : int</li></ol><blockquote><p><strong>位移数</strong>，获取高ssize(segments size)位需要的左移的位数（32-ssize），hash函数算出来的是一个32 位int的整型，ConcurrentHashMap对segments的hash算法采用的是一个取高位进行hash的做法。比如一个key算出来的值为1024，如果我想取高ssize位 ，假如ssize为4，那么就要将1024&gt;&gt;&gt;(32-4)，取得高4位。获取到高4位后会与segmentMask进行与运算获取到一个[0,ssize)的数。这就是ConcurrentHashMap中对segment采用的hash算法。</p></blockquote><ul><li>为什么要采用高位运算？</li></ul><blockquote><p>源码中似乎没有说明，我猜是为了跟segment中的HashEntry[] table 的hash算法区分开来，降低冲突的概率。假如采用同样的hash算法，有2个key Hash到同一个segment中那么再进行 段中的二次hash的时候可能还是命中到同一个节点导致链越来越长。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// segment[] 的hash算法 （hash的高位参与运算）</span><br><span class="line"> int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">// table[] 的hash算法 （hash的低位参与运算）</span><br><span class="line"> int index = (tab.length - 1) &amp; hash;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/liaojiacan/assets/blob/master/issue/ConcurrentHashMap_jdk1.7.png?raw=true" alt="image"></p><h3 id="二-segment中独占锁的加锁逻辑"><a class="markdownIt-Anchor" href="#二-segment中独占锁的加锁逻辑"></a> 二、segment中独占锁的加锁逻辑</h3><blockquote><p>分段锁的目的就是将锁冲突分离开，只有hash到同一个segment中的操作才会存在锁竞争，CurrentHashMap 中put和remove以及size是有加锁操作的。</p></blockquote><p>put操作加锁</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashEntry&lt;K,V&gt; node = tryLock() ? null :scanAndLockForPut(key, hash, value);</span><br></pre></td></tr></table></figure><p>reomve操作加锁</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (!tryLock())</span><br><span class="line">   scanAndLock(key, hash);</span><br></pre></td></tr></table></figure><p>如果 tryLock() 不能能加锁成功则进行自旋，scanAndLockForPut和scanAndLock有点区别但是逻辑差不多。</p><p>1.有限重试次数，多核心CPU的话是64次，单核1次，超过次数则阻塞等待获取锁。</p><p>2.获取锁之前和获取到锁期间头节点不能发生改变，否则需要从头开始重试。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void scanAndLock(Object key, int hash) &#123;</span><br><span class="line">    // similar to but simpler than scanAndLockForPut</span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(this, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    int retries = -1;</span><br><span class="line">    while (!tryLock()) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; f;</span><br><span class="line">        if (retries &lt; 0) &#123;</span><br><span class="line">            if (e == null || key.equals(e.key))</span><br><span class="line">                retries = 0;</span><br><span class="line">            else</span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果头节点发生改变，从头开始扫描</span><br><span class="line">        else if ((retries &amp; 1) == 0 &amp;&amp;</span><br><span class="line">                 (f = entryForHash(this, hash)) != first) &#123;</span><br><span class="line">            e = first = f;</span><br><span class="line">            retries = -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>get没有加排他锁，是否有线程安全问题？</li></ul><p>先说下结论，ConcurrentHashMap get方法不存在线程安全问题，他的线程安全是由CAS 和 &quot;volatile&quot;保证的:</p><pre><code>1. UNSAFE.putOrderedObject/UNSAFE.getObjectVolatile2. volatile HashEntry&lt;K,V&gt; next;3. volatile V value;</code></pre><p>我们整理下，要保证get不发生线程安全问题需要保证什么？</p><pre><code>1. get操作和put或remove操作并行的时候，get能操作能够获取到正确的segment和头节点table[i]。2. 在entries的遍历中能顺利走到未节点。3. 在1和2的前提下get操作时能够保证value值的可见性。</code></pre><p>我们先看第1点时怎么保证的，我们都知道java中有个volatile用了保证变量在多线程下的可见性，volatile可以保证可见性，但是不能保证线程安全，如果当前赋值语句依赖当前值时是线程不安全的，比如a +=1 这种操作就是不安全的，显然在ConcurrentHashMap的并不需要这种操作，只存在简单的引用赋值操作。</p><p>但是需要注意的是一点，volatile修饰引用型变量时，只能保证当前引用的可见性，对于引用对象的内部变量仍然是无法保证可见性的，这就是为什么在对segments[] 数组和table[] 数组的的操作需要借助Unsafe类，而不是直接segments[i] = new Segment(…);</p><p>由前面的分析看，volatile/Unsafe.getObjectVolatile/Unsafe.putOrderedOject保证链当get操作晚与put操作时是可以获取到刚插入的节点(作为一个新头节点连接到旧节点并更新table)，对与一个早于put操作的get操作一个情况就是新插入的元素表头，但是get操作已经获取到了旧表头，所以并不影响get操作进行链表的遍历查找。</p><p>我们在看进行remove时是否会影响entries的遍历，从源码中看，HashEntry中的next成员是被volatile修饰的，这就保证了get可以安全得遍历到未节点。</p><h3 id="三-size的实现逻辑"><a class="markdownIt-Anchor" href="#三-size的实现逻辑"></a> 三、size的实现逻辑</h3><p>  假如ConcurrentHashMap采用HashMap维护一个全局的size来变量统计大小，那么为了线程安全，也必定得改用原子类AtomicLong或者全局加锁。这显然与分段锁的设计背离。那么有没有一种比较折衷的办法呢？</p><p>  ConcurrentHashMap中将size的统计拆分到各个segment取去护，每次执行size的时候将每个segment的count加起来，最终得到的结果就是map的大小。这个看似乎很合理，但是如果在进行统计的过程中有一个segment发生put或者remove操作呢，这样得到的结果就是错误的，显然我们可以在统计前先将每个segment给锁起来，再sum，得到的结果肯定是正确的。</p><p>  <strong>存在一种情况就是你的程序中并发很少，出现并发更新的情况很少，这个时候你执行size的时候将所有的segment加锁和不加锁的情况可能得到的结果是一样的，因为这个时候没有其他线程进行修改。似乎我们可以乐观地考虑一下大部分情况下是不需要进行锁操作的。</strong></p><p>  Doug Lea采用类一种跟JDK集合类中大多数存在的fail-safe错误检查机制，对在每个segment中于更新操作维护一个modCount来记录更新的次数，统计前和统计后的modCount是一样的说明没有发生变化，当前的统计结果有效。ConcurrentHashMap的size方法的实现逻辑如下：</p><ul><li>先采用无锁的方式统计2次，如果前后的modCount总和是一样的，此次统计结果有效，返回结果。</li><li>假如前后的modCount总和不一样，第三次进行有锁的统计。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public int size() &#123;</span><br><span class="line">        // Try a few times to get accurate count. On failure due to</span><br><span class="line">        // continuous async changes in table, resort to locking.</span><br><span class="line">        final Segment&lt;K,V&gt;[] segments = this.segments;</span><br><span class="line">        int size;</span><br><span class="line">        boolean overflow; // true if size overflows 32 bits</span><br><span class="line">        long sum;         // sum of modCounts</span><br><span class="line">        long last = 0L;   // previous sum</span><br><span class="line">        int retries = -1; // first iteration isn&apos;t retry</span><br><span class="line">        try &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                //第三次进行上锁</span><br><span class="line">                if (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                    for (int j = 0; j &lt; segments.length; ++j)</span><br><span class="line">                        ensureSegment(j).lock(); // force creation</span><br><span class="line">                &#125;</span><br><span class="line">                sum = 0L;</span><br><span class="line">                size = 0;</span><br><span class="line">                overflow = false;</span><br><span class="line">                for (int j = 0; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                    Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                    if (seg != null) &#123;</span><br><span class="line">                        sum += seg.modCount;</span><br><span class="line">                        int c = seg.count;</span><br><span class="line">                        if (c &lt; 0 || (size += c) &lt; 0)</span><br><span class="line">                            overflow = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // 前后2次的统计结果一致，可以返回</span><br><span class="line">                if (sum == last)</span><br><span class="line">                    break;</span><br><span class="line">                last = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                for (int j = 0; j &lt; segments.length; ++j)</span><br><span class="line">                    segmentAt(segments, j).unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="四-unsafegetobjectvolatileunsafeputorderedoject对偏移量的计算问题"><a class="markdownIt-Anchor" href="#四-unsafegetobjectvolatileunsafeputorderedoject对偏移量的计算问题"></a> 四、Unsafe.getObjectVolatile/Unsafe.putOrderedOject对偏移量的计算问题</h3><p>  ConcurrentHashMap中使用量Unsafe类来对segment数组和table数组进行数组填充和取值操作，其中对位置i的内存偏移计算用了位运算来代替乘法运算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// segment[0] 的偏移地址</span><br><span class="line">int baseOffset = UNSAFE.arrayBaseOffset(Segment[].class);</span><br><span class="line">// 每个位置的大小</span><br><span class="line">int indexScale = UNSAFE.arrayIndexScale(Segment[].class);</span><br><span class="line">//那么第i个元素的内存偏移就是</span><br><span class="line">long offset = baseOffset+i*indexScale ;</span><br></pre></td></tr></table></figure><p>上面的计算方法是利用乘法来计算的，但是乘法的计算还是比较慢的，如果能用位运算更佳。由于jvm给对象分配内存的时候会进行内存对对齐，也就是说indexScale其实会是一个2的n次方的数。一个整数i乘以一个2的n次方可以转化成 i&lt;&lt;n;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">3 * 2 = 3 &lt;&lt; 1</span><br><span class="line">3 * 4 = 3 &lt;&lt; 2</span><br><span class="line">3 * 8 = 3 &lt;&lt; 3</span><br><span class="line">3 * 16 = 3 &lt;&lt; 4</span><br><span class="line">3 * 32 = 3 &lt;&lt; 5</span><br><span class="line">3 * 64 = 3 &lt;&lt; 6</span><br><span class="line">3 * 128 = 3 &lt;&lt; 7</span><br><span class="line">3 * 256 = 3 &lt;&lt; 8</span><br></pre></td></tr></table></figure><p>所以你会看到ConcurrentHashMap中有这样的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 31 - Integer.numberOfLeadingZeros(ssize) 这个是求一个数x的2对数 </span><br><span class="line"> SSHIFT = 31 - Integer.numberOfLeadingZeros(ssize);</span><br><span class="line"> ...</span><br><span class="line"> // 所以元素i在内存中的偏移就是</span><br><span class="line"> long offset = SBASE +(i&lt;&lt;SSHIFT)</span><br></pre></td></tr></table></figure><p><a href="https://github.com/liaojiacan/code-snippets/blob/master/java-language/src/main/java/com/github/liaojiacan/unsafe/UnsafeArrayOperationTests.java" target="_blank" rel="noopener">测试用例-ConcurrentHashMap中利用Unsafe进行数组操作的测试用例</a>;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-concurrenthashmap的数据结构jdk7&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-concurrenthashmap的数据结构jdk7&quot;&gt;&lt;/a&gt; 一、 ConcurrentHashMap的数据结构(JDK7)
      
    
    </summary>
    
      <category term="源码解读" scheme="http://liaojiacan.me/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="JDK" scheme="http://liaojiacan.me/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/JDK/"/>
    
    
      <category term="J.U.C" scheme="http://liaojiacan.me/tags/J-U-C/"/>
    
      <category term="ConcurrentHashMap" scheme="http://liaojiacan.me/tags/ConcurrentHashMap/"/>
    
  </entry>
  
  <entry>
    <title>谈谈多语言设计（三）Spring-i18n 拓展之自定义MessageSource</title>
    <link href="http://liaojiacan.me/2018/04/13/%E8%B0%88%E8%B0%88%E5%A4%9A%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%89%EF%BC%89Spring-i18n-%E6%8B%93%E5%B1%95%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89MessageSource/"/>
    <id>http://liaojiacan.me/2018/04/13/谈谈多语言设计（三）Spring-i18n-拓展之自定义MessageSource/</id>
    <published>2018-04-13T08:08:00.000Z</published>
    <updated>2019-05-22T05:43:18.862Z</updated>
    
    <content type="html"><![CDATA[<p>  Spring框架中有两个MessageSource的实现，分别是ResourceBundleMessageSource和ReloadableResourceBundleMessageSource，前者第一次初始化就固定下来，后者可以根据配置文件是否发生变进行更新。</p><p>  对于Web网页（UI上的文案），这种配置在配置文件的方式是可以接受的，因为一般这些文案都是固定的。但是对于一些需要动态新增配置的场景显然就是不适合了，比如商品信息，抽奖的奖品，直播间的道具，礼物等，这些都是根据运营人员需要动态调整的，显然需要把配置存储在数据库中。</p><p>  在写这部分的实现的时候，参考了一个开源项目，<a href="https://github.com/synyx/messagesource" target="_blank" rel="noopener">https://github.com/synyx/messagesource</a>。<br>感兴趣的同学，可以在我的Github查看完整的代码。<a href="https://github.com/liaojiacan/spring-i18n-support" target="_blank" rel="noopener">https://github.com/liaojiacan/spring-i18n-support</a></p><h2 id="uml"><a class="markdownIt-Anchor" href="#uml"></a> UML</h2><p><img src="/images/pasted-3.png" alt="upload successful"></p><h2 id="关于messagesourceprovider"><a class="markdownIt-Anchor" href="#关于messagesourceprovider"></a> 关于MessageSourceProvider</h2><p>   在MessageSource的实现中 ，抽出一个Provider层将存储介质解耦，可以在最后的应用中，选择使用JDBC还是Redis还是远程的配置服务中心的实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface MessageSourceProvider &#123;</span><br><span class="line"></span><br><span class="line">List&lt;MessageEntry&gt; load();</span><br><span class="line"></span><br><span class="line">int addMessage(Locale locale,String code,String type,String message);</span><br><span class="line"></span><br><span class="line">int updateMessage(Locale locale,String code,String type,String message);</span><br><span class="line"></span><br><span class="line">int deleteMessage(Locale locale,String code);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="jdbcmessagesoucreprovider"><a class="markdownIt-Anchor" href="#jdbcmessagesoucreprovider"></a> JdbcMessageSoucreProvider</h2><p>   因为只是简单的对数据进行CURD，所以采用JdbcTemple的方式减少相关的依赖，采用java原生的jdbc也是可以的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- ----------------------------</span><br><span class="line">-- Table structure for i18n_message</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP TABLE IF EXISTS `i18n_message`;</span><br><span class="line">CREATE TABLE `i18n_message` (</span><br><span class="line">  `code` varchar(250) NOT NULL COMMENT &apos;mapping code&apos;,</span><br><span class="line">  `locale` varchar(100) NOT NULL COMMENT &apos;language tag&apos;,</span><br><span class="line">  `type` varchar(100) DEFAULT NULL COMMENT &apos;type for group&apos;,</span><br><span class="line">  `message` text NOT NULL COMMENT &apos;message content&apos;,</span><br><span class="line">  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT &apos;create time&apos;,</span><br><span class="line">  `update_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &apos;last modify time&apos;,</span><br><span class="line">  PRIMARY KEY (`code`,`locale`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;i18n message data&apos;;</span><br><span class="line"></span><br><span class="line">SET FOREIGN_KEY_CHECKS = 1;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">public class JdbcMessageSoucreProvider implements MessageSourceProvider &#123;</span><br><span class="line"></span><br><span class="line">private JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">protected static final String QUERY_TPL_INSERT_MESSAGE_ENTRY =</span><br><span class="line">&quot;INSERT INTO %s (%s, %s, %s, %s) VALUES (?, ?, ?, ?)&quot;;</span><br><span class="line">protected static final String QUERY_TPL_DELETE_MESSAGE_ENTRY = &quot;DELETE FROM %s WHERE %s = ? and %s= ?&quot;;</span><br><span class="line">protected static final String QUERY_TPL_SELECT_MESSAGE_ENTRIES = &quot;SELECT %s,%s,%s,%s FROM %s&quot;;</span><br><span class="line">protected static final String QUERY_TPL_UPDATE_MESSAGE_ENTRY = &quot;UPDATE %s set %s=?,%s=?,%s=? WHERE %s=? and %s=?&quot;;</span><br><span class="line"></span><br><span class="line">private String localeColumn = &quot;locale&quot;;</span><br><span class="line">private String typeColumn = &quot;type&quot;;</span><br><span class="line">private String codeColumn = &quot;code&quot;;</span><br><span class="line">private String messageColumn = &quot;message&quot;;</span><br><span class="line">private String tableName = &quot;i18n_message&quot;;</span><br><span class="line">private String delimiter = &quot;`&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public List&lt;MessageEntry&gt; load() &#123;</span><br><span class="line">// @formatter:off</span><br><span class="line">String sql = String.format(getQueryTplSelectMessageEntries(),</span><br><span class="line">addDelimiter(getCodeColumn()),</span><br><span class="line">addDelimiter(getLocaleColumn()),</span><br><span class="line">addDelimiter(getTypeColumn()),</span><br><span class="line">addDelimiter(getMessageColumn()),</span><br><span class="line">addDelimiter(getTableName()));</span><br><span class="line">return jdbcTemplate.query(sql,new BeanPropertyRowMapper(MessageEntry.class));</span><br><span class="line">// @formatter:on</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int addMessage(Locale locale, String code, String type, String message) &#123;</span><br><span class="line">// @formatter:off</span><br><span class="line">String sql = String.format(getQueryTplInsertMessageEntry(),</span><br><span class="line">addDelimiter(getTableName()),</span><br><span class="line">addDelimiter(getLocaleColumn()),</span><br><span class="line">addDelimiter(getCodeColumn()),</span><br><span class="line">addDelimiter(getTypeColumn()),</span><br><span class="line">addDelimiter(getMessageColumn()));</span><br><span class="line">// @formatter:on</span><br><span class="line">return jdbcTemplate.update(sql,locale.toLanguageTag(),code,type,message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int updateMessage(Locale locale, String code, String type, String message) &#123;</span><br><span class="line">// @formatter:off</span><br><span class="line">String sql = String.format(getQueryTplUpdateMessageEntry(),</span><br><span class="line">addDelimiter(getTableName()),</span><br><span class="line">addDelimiter(getLocaleColumn()),</span><br><span class="line">addDelimiter(getTypeColumn()),</span><br><span class="line">addDelimiter(getMessageColumn()),</span><br><span class="line">addDelimiter(getCodeColumn()),addDelimiter(getLocaleColumn()));</span><br><span class="line">// @formatter:on</span><br><span class="line">return jdbcTemplate.update(sql,locale.toLanguageTag(),type,message,code,locale.toLanguageTag());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int deleteMessage(Locale locale, String code) &#123;</span><br><span class="line">String sql = String.format(getQueryTplDeleteMessageEntry(),addDelimiter(getTableName()),addDelimiter(getCodeColumn()),addDelimiter(getLocaleColumn()));</span><br><span class="line">return jdbcTemplate.update(sql,code,locale.toLanguageTag());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Method that &quot;wraps&quot; a field-name (or table-name) into the delimiter.</span><br><span class="line"> * @param name the name of the field/table</span><br><span class="line"> * @return the wrapped field/table</span><br><span class="line"> */</span><br><span class="line">protected String addDelimiter(String name) &#123;</span><br><span class="line">return String.format(&quot;%s%s%s&quot;, delimiter, name, delimiter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public JdbcTemplate getJdbcTemplate() &#123;</span><br><span class="line">return jdbcTemplate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;</span><br><span class="line">this.jdbcTemplate = jdbcTemplate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static String getQueryTplInsertMessageEntry() &#123;</span><br><span class="line">return QUERY_TPL_INSERT_MESSAGE_ENTRY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static String getQueryTplDeleteMessageEntry() &#123;</span><br><span class="line">return QUERY_TPL_DELETE_MESSAGE_ENTRY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static String getQueryTplSelectMessageEntries() &#123;</span><br><span class="line">return QUERY_TPL_SELECT_MESSAGE_ENTRIES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static String getQueryTplUpdateMessageEntry() &#123;</span><br><span class="line">return QUERY_TPL_UPDATE_MESSAGE_ENTRY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getLocaleColumn() &#123;</span><br><span class="line">return localeColumn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setLocaleColumn(String localeColumn) &#123;</span><br><span class="line">this.localeColumn = localeColumn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getTypeColumn() &#123;</span><br><span class="line">return typeColumn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setTypeColumn(String typeColumn) &#123;</span><br><span class="line">this.typeColumn = typeColumn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getCodeColumn() &#123;</span><br><span class="line">return codeColumn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setCodeColumn(String codeColumn) &#123;</span><br><span class="line">this.codeColumn = codeColumn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getMessageColumn() &#123;</span><br><span class="line">return messageColumn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setMessageColumn(String messageColumn) &#123;</span><br><span class="line">this.messageColumn = messageColumn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getTableName() &#123;</span><br><span class="line">return tableName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setTableName(String tableName) &#123;</span><br><span class="line">this.tableName = tableName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getDelimiter() &#123;</span><br><span class="line">return delimiter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setDelimiter(String delimiter) &#123;</span><br><span class="line">this.delimiter = delimiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="refreshablemessagesource"><a class="markdownIt-Anchor" href="#refreshablemessagesource"></a> RefreshableMessageSource</h2><p>  RefreshableMessageSource的实现相对简单，在初始化的时候将MessageSourceProvider的数据解析成MessageFormat存在Map中，解析的时候根据code和locale索引到对应的MessageFormat。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author liaojiacan https://github.com/liaojiacan</span><br><span class="line"> */</span><br><span class="line">public class RefreshableMessageSource extends AbstractMessageSource implements Refreshable,InitializingBean&#123;</span><br><span class="line"></span><br><span class="line">private MessageSourceProvider provider;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Setting : return origin code when the message not found.</span><br><span class="line"> */</span><br><span class="line">protected Boolean returnUnresolvedCode = false;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The MessageFormat cache</span><br><span class="line"> */</span><br><span class="line">private Map&lt;String,Map&lt;Locale,MessageFormat&gt;&gt; messageEntryMap = Collections.emptyMap();</span><br><span class="line"></span><br><span class="line">public RefreshableMessageSource(MessageSourceProvider provider) &#123;</span><br><span class="line">this.provider = provider;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void refresh()&#123;</span><br><span class="line">List&lt;MessageEntry&gt; messageEntries = provider.load();</span><br><span class="line">if(!CollectionUtils.isEmpty(messageEntries))&#123;</span><br><span class="line">final Map&lt;String,Map&lt;Locale,MessageFormat&gt;&gt; finalMap = new HashMap&lt;&gt;();</span><br><span class="line">messageEntries.forEach(messageEntry -&gt; &#123;</span><br><span class="line">String code  = messageEntry.getCode();</span><br><span class="line">Locale locale = Locale.forLanguageTag(messageEntry.getLocale());</span><br><span class="line">Map&lt;Locale, MessageFormat&gt; localeMapping = finalMap.get(code);</span><br><span class="line">if(localeMapping == null)&#123;</span><br><span class="line">localeMapping = new HashMap&lt;&gt;();</span><br><span class="line">finalMap.put(code,localeMapping);</span><br><span class="line">&#125;</span><br><span class="line">localeMapping.put(locale,createMessageFormat(messageEntry.getMessage(),locale));</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">messageEntryMap = finalMap;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected MessageFormat resolveCode(String code, Locale locale) &#123;</span><br><span class="line">Map&lt;Locale, MessageFormat&gt; localeMessageMap = messageEntryMap.get(code);</span><br><span class="line">if(localeMessageMap != null )&#123;</span><br><span class="line">MessageFormat mf = localeMessageMap.get(locale);</span><br><span class="line">if(mf!=null)&#123;</span><br><span class="line">return  mf;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(returnUnresolvedCode)&#123;</span><br><span class="line">return createMessageFormat(code,locale);</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">this.refresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public MessageSourceProvider getProvider() &#123;</span><br><span class="line">return provider;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setProvider(MessageSourceProvider provider) &#123;</span><br><span class="line">this.provider = provider;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Boolean getReturnUnresolvedCode() &#123;</span><br><span class="line">return returnUnresolvedCode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setReturnUnresolvedCode(Boolean returnUnresolvedCode) &#123;</span><br><span class="line">this.returnUnresolvedCode = returnUnresolvedCode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  Spring框架中有两个MessageSource的实现，分别是ResourceBundleMessageSource和ReloadableResourceBundleMessageSource，前者第一次初始化就固定下来，后者可以根据配置文件是否发生变进行更新。&lt;/p
      
    
    </summary>
    
      <category term="架构总结" scheme="http://liaojiacan.me/categories/%E6%9E%B6%E6%9E%84%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="多语言" scheme="http://liaojiacan.me/tags/%E5%A4%9A%E8%AF%AD%E8%A8%80/"/>
    
      <category term="i18n" scheme="http://liaojiacan.me/tags/i18n/"/>
    
  </entry>
  
  <entry>
    <title>Idea使用骨架生成项目卡住的解决办法</title>
    <link href="http://liaojiacan.me/2018/03/09/Idea%E4%BD%BF%E7%94%A8%E9%AA%A8%E6%9E%B6%E7%94%9F%E6%88%90%E9%A1%B9%E7%9B%AE%E5%8D%A1%E4%BD%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://liaojiacan.me/2018/03/09/Idea使用骨架生成项目卡住的解决办法/</id>
    <published>2018-03-09T11:01:00.000Z</published>
    <updated>2019-05-22T05:43:18.855Z</updated>
    
    <content type="html"><![CDATA[<p>  Idea在使用骨架生成项目时（Create from archetype）有时候会发现卡住了，控制台停留在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Generating project in Batch mode</span><br></pre></td></tr></table></figure><p>通过debug日志发现是搜索archetype-catalog.xml卡住了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Generating project in Batch mode</span><br><span class="line">[DEBUG] Searching for remote catalog: http://repo.maven.apache.org/maven2/archetype-catalog.xml</span><br></pre></td></tr></table></figure><p>解决方法：</p><p>   修改archetypeCatalog参数，archetypeCatalog=internal。Idea可以在maven的runner配置中指定。如图：</p><p><img src="/images/pasted-2.png" alt="upload successful"></p><p>archetypeCatalog参数取值可以从maven的文档查到.<a href="http://maven.apache.org/archetype/maven-archetype-plugin/examples/generate-alternative-catalog.html" target="_blank" rel="noopener">Generate project using an alternative catalog<br></a></p><p>archetypeCatalog 可配置的值有</p><ul><li>internal to use the internal catalog only.</li><li>local to use the local catalog only.</li><li>remote to use the maven’s remote catalog.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">No catalog is currently provided.</span><br><span class="line">The default value is remote,local. Thus the local catalog is shown just after the remote one.</span><br></pre></td></tr></table></figure><p>默认是remote,local. 这里解决方法其实有两个，<br>一个就是上面所说修改archetypeCatalog=internal,直接使用网络。另外一个就是修改远程仓库，如使用阿里的镜像。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  Idea在使用骨架生成项目时（Create from archetype）有时候会发现卡住了，控制台停留在&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span clas
      
    
    </summary>
    
      <category term="工具使用" scheme="http://liaojiacan.me/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="Idea" scheme="http://liaojiacan.me/tags/Idea/"/>
    
      <category term="archetypeCatalog" scheme="http://liaojiacan.me/tags/archetypeCatalog/"/>
    
  </entry>
  
  <entry>
    <title>谈谈多语言设计（二）之Spring多语言</title>
    <link href="http://liaojiacan.me/2018/03/08/%E8%B0%88%E8%B0%88%E5%A4%9A%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B9%8BSpring%E5%A4%9A%E8%AF%AD%E8%A8%80/"/>
    <id>http://liaojiacan.me/2018/03/08/谈谈多语言设计（二）之Spring多语言/</id>
    <published>2018-03-08T11:07:00.000Z</published>
    <updated>2019-05-22T05:43:18.862Z</updated>
    
    <content type="html"><![CDATA[<p>  现在大部分成熟的web框架默认就支持多语言，如果业务比较简单，使用框架自身的多语言支持就可以了。本文将以SpringMvc为例介绍一下JavaWeb的多语言中的一些关键类。</p><h2 id="关键字"><a class="markdownIt-Anchor" href="#关键字"></a> 关键字</h2><ul><li>i18n</li><li>Locale</li><li>LocaleContext</li><li>MessageSource</li></ul><h2 id="i18n"><a class="markdownIt-Anchor" href="#i18n"></a> I18N</h2><p>   i18n(其来源是英文单词 internationalization的首末字符i和n，18为中间的字符数),除了i18n还有L10n、g11n、m17n。</p><h2 id="locale"><a class="markdownIt-Anchor" href="#locale"></a> Locale</h2><p>  Locale是区域信息，通常locale信息包含应该语言信息和区域标识符，如zh_CN:zh为中文,CN为中国的国家代码。常见的Locale代码可以上网获取。<a href="https://www.science.co.il/language/Locale-codes.php" target="_blank" rel="noopener"> Locale Codes</a>。java中的Locale.java 也定义了常见的区域信息。我们应该尽量使用Locale类型来表达地域信息变量，不应该使用String类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">static public final Locale ENGLISH = createConstant(&quot;en&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">   /** Useful constant for language.</span><br><span class="line">    */</span><br><span class="line">   static public final Locale FRENCH = createConstant(&quot;fr&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">   /** Useful constant for language.</span><br><span class="line">    */</span><br><span class="line">   static public final Locale GERMAN = createConstant(&quot;de&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">   /** Useful constant for language.</span><br><span class="line">    */</span><br><span class="line">   static public final Locale ITALIAN = createConstant(&quot;it&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">   /** Useful constant for language.</span><br><span class="line">    */</span><br><span class="line">   static public final Locale JAPANESE = createConstant(&quot;ja&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">   /** Useful constant for language.</span><br><span class="line">    */</span><br><span class="line">   static public final Locale KOREAN = createConstant(&quot;ko&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">   /** Useful constant for language.</span><br><span class="line">    */</span><br><span class="line">   static public final Locale CHINESE = createConstant(&quot;zh&quot;, &quot;&quot;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> //从Locale的构造方法中，也看出Locale中可包含语言（language）,国家(country),变体（variant）</span><br><span class="line"> public Locale(String language, String country, String variant) &#123;</span><br><span class="line">        if (language== null || country == null || variant == null) &#123;</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        baseLocale = BaseLocale.getInstance(convertOldISOCodes(language), &quot;&quot;, country, variant);</span><br><span class="line">        localeExtensions = getCompatibilityExtensions(language, &quot;&quot;, country, variant);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="localecontext"><a class="markdownIt-Anchor" href="#localecontext"></a> LocaleContext</h2><p>   Spring中存储用户地域信息的上下文，LocaleContext中采用的是ThreadLocal变量来存储信息，线程隔离，这样就可以让locale参数从各层的方法参数中移除。我们在写业务代码时也尽量不要将Locale参数通过方法参数中传入，利用LocaleContext可以让代码显得更优雅点。此外Spring也提供一些LocaleChangeInterceptor 的实现，并不需要我们自己维护这些信息。</p><ul><li>AcceptHeaderLocaleResolver  通过Accept-Language加载locale信息</li><li>CookieLocaleResolver 通过Cookie加载locale信息</li><li>FixedLocaleResolver  全局静态的，返回一个默认的Locale</li><li>SessionLocaleResolver 通过SessionLocaleResolver加载locale信息</li></ul><h2 id="messagesource"><a class="markdownIt-Anchor" href="#messagesource"></a> MessageSource</h2><p>   对于多语言的翻译，无非就是先定义一些key，然后根据给这些key配置各种locale对应的文本。而Spring中的MessageSource就是维护这些配置信息的组件，Spring中有ResourceBundleMessageSource 和 ReloadableResourceBundleMessageSource的实现，可以将多语言的配置在<span class="katex-error" title="ParseError: KaTeX parse error: Expected group after &#039;_&#039; at position 11: {basename}_̲">{basename}_</span>{locale}.properties文件中。ResourceBundleMessageSource 每次修改配置需要重启服务才能生效，而ReloadableResourceBundleMessageSource可以热更新。</p><p>   当然我们也可以自己实现一个MessageSource从DB或者从其他存储源加载配置，后面我将单独写一篇文章介绍如何自定义MessageSource进行拓展的。</p><h2 id="多语言的处理流程"><a class="markdownIt-Anchor" href="#多语言的处理流程"></a> 多语言的处理流程</h2><p><img src="/images/pasted-1.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  现在大部分成熟的web框架默认就支持多语言，如果业务比较简单，使用框架自身的多语言支持就可以了。本文将以SpringMvc为例介绍一下JavaWeb的多语言中的一些关键类。&lt;/p&gt;
&lt;h2 id=&quot;关键字&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; hr
      
    
    </summary>
    
      <category term="架构总结" scheme="http://liaojiacan.me/categories/%E6%9E%B6%E6%9E%84%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="多语言" scheme="http://liaojiacan.me/tags/%E5%A4%9A%E8%AF%AD%E8%A8%80/"/>
    
      <category term="i18n" scheme="http://liaojiacan.me/tags/i18n/"/>
    
  </entry>
  
  <entry>
    <title>谈谈多语言设计（一）之客户端多语言与服务端多语言</title>
    <link href="http://liaojiacan.me/2018/03/07/%E8%B0%88%E8%B0%88%E5%A4%9A%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8B-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%9A%E8%AF%AD%E8%A8%80%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A4%9A%E8%AF%AD%E8%A8%80/"/>
    <id>http://liaojiacan.me/2018/03/07/谈谈多语言设计（一）之-客户端多语言与服务端多语言/</id>
    <published>2018-03-07T03:56:00.000Z</published>
    <updated>2019-05-22T05:43:18.861Z</updated>
    
    <content type="html"><![CDATA[<p>  2017年的一个风口就是移动互联网的出海，很多公司都战略性地在海外做起了互联网商业化，最近也是接触了一些国际的项目，用户散落在各个国家地区，刚开始大部分是由客户端进行多语言的适配，后来由于产品觉得灵活性太差，于是把部分功能移到服务端来实现，但是发现无论是客户端实现还是服务端实现都存在一些弊端。</p><h2 id="我们先思考一下以下几个问题"><a class="markdownIt-Anchor" href="#我们先思考一下以下几个问题"></a> 我们先思考一下以下几个问题：</h2><ol><li>完全由服务端实现多语言有什么弊端?</li></ol><blockquote><p>对于大部分应用场景，多语言都可以在服务端实现，但有一种情况不适合使用服务端多语言。比如目标用户语言非唯一，IM群发，推送等业务场景，虽然大部分消息推送服务可以按用户属性或者标签进行推送，服务端可以分开推送来实现，但是对于用户群推地域很分散的应用显然不是很合适。</p></blockquote><ol start="2"><li>完全由客户端实现多语言由什么弊端？</li></ol><blockquote><p>大部分情况下都是采用的客户端写多语言配置进行适配，不管是android 还是iOS 还是常见的前端框架都是支持i18n的配置。这种方式有个缺点就是灵活性比较差，修改文案必须发包。</p></blockquote><ol start="3"><li>对于移动应用多语言是该客户端做还是服务端做，如何找到一个平衡点？</li></ol><blockquote><p>无论是客户端多语言还是服务端多语言都有各自的优劣，主要还是看应用场景。<br>个人认为对于移动应用的多语言，应该把两者结合起来使用。对于UI等相对固定的部分采用客户端多语言。对于变动比较大的部分，采用服务端进行多语言的处理，比如名称，描述这些可能会根据运营场景进行调整的信息。</p></blockquote><ol start="4"><li>为什么不采用服务端生成配置客户端加载配置的方式？</li></ol><blockquote><p>这种方式是一种比较灵活的方式，但是对于协议的定义不是很友好（key必须唯一，势必导致接口的返回体变大），而且无论是客户端还是服务端解析也比较耗资源，接口可读性比较差。而且把业务跟多语言的耦合太重，无论是客户端和服务端在编码的时候应该把多语言与业务解构，即便没有多语言部分也不影响业务的执行。</p></blockquote><ol start="5"><li><p>如果将客户端多语言和服务端多语言结合使用，怎么规范比较适合？</p><blockquote><p>简单来说，就是以下几点:</p></blockquote><ul><li>UI部分由客户端实现多语言</li><li>所有客户端主动向服务端拉取的由服务端实现</li><li>对于群发等应用场景，由服务端生成语言包，客户端在一定时机拉取并加载到应用中。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  2017年的一个风口就是移动互联网的出海，很多公司都战略性地在海外做起了互联网商业化，最近也是接触了一些国际的项目，用户散落在各个国家地区，刚开始大部分是由客户端进行多语言的适配，后来由于产品觉得灵活性太差，于是把部分功能移到服务端来实现，但是发现无论是客户端实现还是服
      
    
    </summary>
    
      <category term="架构总结" scheme="http://liaojiacan.me/categories/%E6%9E%B6%E6%9E%84%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="多语言" scheme="http://liaojiacan.me/tags/%E5%A4%9A%E8%AF%AD%E8%A8%80/"/>
    
      <category term="i18n" scheme="http://liaojiacan.me/tags/i18n/"/>
    
  </entry>
  
  <entry>
    <title>Source Tree 配置支持gerrit review</title>
    <link href="http://liaojiacan.me/2018/02/07/Source-Tree-%E9%85%8D%E7%BD%AE%E6%94%AF%E6%8C%81gerrit-review/"/>
    <id>http://liaojiacan.me/2018/02/07/Source-Tree-配置支持gerrit-review/</id>
    <published>2018-02-07T07:34:45.000Z</published>
    <updated>2019-05-22T05:43:18.859Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>source tree 可以支持自定义菜单，我们自定义一个菜单，来实现gerrit push review操作</p></blockquote><p>1.先创建一个脚本，这里我叫 git_push_gerrit.sh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># Push for gerrit review</span><br><span class="line"># Created by Liaojiacan on 6.2.2017.</span><br><span class="line"># Copyright (c) 2018 liaojiacan. All rights reserved.</span><br><span class="line">branch=$(git symbolic-ref --short -q HEAD)</span><br><span class="line">git push origin HEAD:refs/for/$branch</span><br></pre></td></tr></table></figure><p>2.在SourceTree创建一个自定义操作</p><p><img src="/images/pasted-0.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;source tree 可以支持自定义菜单，我们自定义一个菜单，来实现gerrit push review操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.先创建一个脚本，这里我叫 git_push_gerrit.sh&lt;/p&gt;
&lt;figure c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>抽奖业务设计</title>
    <link href="http://liaojiacan.me/2017/12/16/%E6%8A%BD%E5%A5%96%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1/"/>
    <id>http://liaojiacan.me/2017/12/16/抽奖业务设计/</id>
    <published>2017-12-16T08:12:00.000Z</published>
    <updated>2019-05-22T05:43:18.861Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>抽奖是一个比较常见的业务，关于抽奖的算法也有很多种实现，下面介绍一种比较容易实现的方式。</p></blockquote><p>1.根据中奖概率的精确度，取一个权重的基线作为（概率-&gt;概率区间）的放大因子。比如，概率的精确度是到万分位，则基线取10000，保证转换后的区间&gt;=1</p><p>2.将奖品按对应的中奖概率*基线 转换成权重区间，并记录权重的上限值。</p><p>3.在权重上限值的范围内产生一个随机数，利用迭代查找或者二分查找算法找到对应的权重区间，即可获取到对应的奖品。</p><p>假设奖品的配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;一等奖&quot;:0.01</span><br><span class="line">&quot;二等奖&quot;:0.1</span><br><span class="line">&quot;三等奖&quot;:0.15</span><br><span class="line">&quot;四等奖&quot;:0.2</span><br><span class="line">&quot;五等奖&quot;:0.25</span><br><span class="line">&quot;六等奖&quot;:0.29</span><br></pre></td></tr></table></figure><p>概率转换到权重区间（放大10000倍）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一等奖:[0.000000,100.000000)</span><br><span class="line">二等奖:[100.000000,1100.000000)</span><br><span class="line">三等奖:[1100.000000,2600.000000)</span><br><span class="line">四等奖:[2600.000000,4100.000000)</span><br><span class="line">五等奖:[4100.000000,6100.000000)</span><br><span class="line">六等奖:[6100.000000,8600.000000)</span><br></pre></td></tr></table></figure><p>算法实现：<a href="https://github.com/liaojiacan/code-snippets/tree/master/function-design/src/main/java/com/github/liaojiacan/lottery" target="_blank" rel="noopener">Github</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class LotteryPrize &#123;</span><br><span class="line">private String id;</span><br><span class="line">private String name;</span><br><span class="line">private double possibility;</span><br><span class="line"></span><br><span class="line">public LotteryPrize() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public LotteryPrize(String id, String name, double possibility) &#123;</span><br><span class="line">this.id = id;</span><br><span class="line">this.name = name;</span><br><span class="line">this.possibility = possibility;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getId() &#123;</span><br><span class="line">return id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setId(String id) &#123;</span><br><span class="line">this.id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public double getPossibility() &#123;</span><br><span class="line">return possibility;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setPossibility(double possibility) &#123;</span><br><span class="line">this.possibility = possibility;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class LotteryMachine &#123;</span><br><span class="line"></span><br><span class="line">private PossibilityArea[] table;</span><br><span class="line">private int bound = 1;</span><br><span class="line">private Random random = new Random();</span><br><span class="line"></span><br><span class="line">private static final int BASE_WEIGHT = 10000;</span><br><span class="line"></span><br><span class="line">class PossibilityArea&#123;</span><br><span class="line">private LotteryPrize prize;</span><br><span class="line">private double start;</span><br><span class="line">private double end;</span><br><span class="line">public PossibilityArea(LotteryPrize prize, double start, double end) &#123;</span><br><span class="line">this.prize = prize;</span><br><span class="line">this.start = start;</span><br><span class="line">this.end = end;</span><br><span class="line">System.out.printf(&quot;%s:[%f,%f)\n&quot;,prize.getName(),start,end);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LotteryMachine(List&lt;LotteryPrize&gt; prizes) &#123;</span><br><span class="line">table = new PossibilityArea[prizes.size()];</span><br><span class="line">double start = 0;</span><br><span class="line">for(int i=0;i&lt;prizes.size();i++)&#123;</span><br><span class="line">LotteryPrize prize = prizes.get(i);</span><br><span class="line">double weight = prize.getPossibility() * BASE_WEIGHT;</span><br><span class="line">Double end = start + weight;</span><br><span class="line">PossibilityArea area = new PossibilityArea(prize,start,end);</span><br><span class="line">table[i]= area;</span><br><span class="line">bound = end.intValue();</span><br><span class="line">start=end;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private LotteryPrize binarySearch(int rnd)&#123;</span><br><span class="line">int low = 0;</span><br><span class="line">int hight = table.length;</span><br><span class="line">while (low&lt;hight)&#123;</span><br><span class="line">int mid = (low + hight) / 2;</span><br><span class="line">PossibilityArea area = table[mid];</span><br><span class="line">if(area.start&lt;=rnd &amp;&amp; area.end&gt;rnd)&#123;</span><br><span class="line">return  area.prize;</span><br><span class="line">&#125;</span><br><span class="line">if(area.end&lt;=rnd)&#123;</span><br><span class="line">low=mid+1;</span><br><span class="line">&#125;</span><br><span class="line">if(area.start&gt;rnd)&#123;</span><br><span class="line">hight=mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public LotteryPrize go()&#123;</span><br><span class="line">int rnd = random.nextInt(bound);</span><br><span class="line">return binarySearch(rnd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;抽奖是一个比较常见的业务，关于抽奖的算法也有很多种实现，下面介绍一种比较容易实现的方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.根据中奖概率的精确度，取一个权重的基线作为（概率-&amp;gt;概率区间）的放大因子。比如，概率的精确度是到万分位，则
      
    
    </summary>
    
      <category term="java" scheme="http://liaojiacan.me/categories/java/"/>
    
    
      <category term="业务开发" scheme="http://liaojiacan.me/tags/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java根据指定的country和lang格式化时间</title>
    <link href="http://liaojiacan.me/2017/10/16/Java%E6%A0%B9%E6%8D%AE%E6%8C%87%E5%AE%9A%E7%9A%84country%E5%92%8Clang%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%B6%E9%97%B4/"/>
    <id>http://liaojiacan.me/2017/10/16/Java根据指定的country和lang格式化时间/</id>
    <published>2017-10-16T13:18:00.000Z</published>
    <updated>2019-05-22T05:43:18.858Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>服务端或者客户端在做一些多语言的时候可能会涉及到时间戳的格式化，不同的语言或者不同的国家的时间的表达格式可能不同。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public  String formatDate(Date date,String lang,String country)&#123;</span><br><span class="line">    Locale locale = new Locale(lang,country,&quot;&quot;);</span><br><span class="line">    DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.DEFAULT,DateFormat.MEDIUM,locale);</span><br><span class="line">    return dateFormat.format(date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;服务端或者客户端在做一些多语言的时候可能会涉及到时间戳的格式化，不同的语言或者不同的国家的时间的表达格式可能不同。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
    
      <category term="java" scheme="http://liaojiacan.me/tags/java/"/>
    
      <category term="业务开发" scheme="http://liaojiacan.me/tags/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Iedis破解思路</title>
    <link href="http://liaojiacan.me/2017/10/12/Iedis%E7%A0%B4%E8%A7%A3%E6%80%9D%E8%B7%AF/"/>
    <id>http://liaojiacan.me/2017/10/12/Iedis破解思路/</id>
    <published>2017-10-12T07:01:00.000Z</published>
    <updated>2019-05-22T05:43:18.856Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Iedis是IDEA上的一个收费redis插件，java编写的，既然是java写的，收费这些自然是很容易绕过的。由于Java太容易被反编译，作者还是做了些代码混淆和字符串加密。</p></blockquote><h3 id="利用jd-gui反编译出来的代码片段"><a class="markdownIt-Anchor" href="#利用jd-gui反编译出来的代码片段"></a> 利用JD-GUI反编译出来的代码片段</h3><p>可以看出类名和字符串都被混淆和加密了，从代码上很难去定位和分析他的注册流程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package com.seventh7.widget.iedis.config;</span><br><span class="line"></span><br><span class="line">import com.intellij.icons.AllIcons.General;</span><br><span class="line">import com.intellij.openapi.actionSystem.AnActionEvent;</span><br><span class="line">import com.intellij.openapi.ui.Messages;</span><br><span class="line"></span><br><span class="line">class i</span><br><span class="line">  extends e</span><br><span class="line">&#123;</span><br><span class="line">  private static final String[] ib;</span><br><span class="line">  private static final String[] jb;</span><br><span class="line">  </span><br><span class="line">  i(n paramn)</span><br><span class="line">  &#123;</span><br><span class="line">    super(a(20539, 52876), a(20539, 52876), AllIcons.General.Remove, a(20537, 55341), paramn);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  void a(AnActionEvent paramAnActionEvent, P paramP)</span><br><span class="line">  &#123;</span><br><span class="line">    String str1 = String.format(a(20538, 25199), new Object[] &#123; paramP.f() &#125;);</span><br><span class="line">    String str2 = a(20536, 20012);</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      if (Messages.showOkCancelDialog(a(), str1, str2, Messages.getQuestionIcon()) == 0) &#123;</span><br><span class="line">        com.seventh7.widget.iedis.d.e.a().a(a(), paramP.b());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (RuntimeException localRuntimeException)</span><br><span class="line">    &#123;</span><br><span class="line">      throw d(localRuntimeException);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="破解的2个思路"><a class="markdownIt-Anchor" href="#破解的2个思路"></a> 破解的2个思路</h3><ul><li>还原代码中的所有加密字符串，根据字符串的内定位到相关的代码，利用javassist修改class文件，将文件替换掉原来的文件</li><li>逆向出他的认证算法，然后做个注册机之类的。iedis是采用服务器认证的，每次启动都要去服务器查询激活，所以注册机不适合。但是我们可以本地架设一个认证服务。</li></ul><blockquote><p>架设认证服务器还是比较简单的，下面还是主要研究一下第一种思路。</p></blockquote><h3 id="还原字符串"><a class="markdownIt-Anchor" href="#还原字符串"></a> 还原字符串</h3><p>从那些混淆的代码去定位软件的运行逻辑很难下手，但是我们可以换个思路，将软件运行过程中字符串都打印出来，这样我们基本上就可以得到一份软件的运行日志，对java程序进行运行时插入语句看似很麻烦，其实JVM默认就支持javaagent，写个javaagent即可达到效果，javaagent的使用可以参考<a href="http://liaojiacan.me/2017/10/10/javaagent-%E7%9A%84%E4%BD%BF%E7%94%A8/">《javaagent-的使用》</a></p><ol><li>编写javaagent程序</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 给iedis的加密字符串函数 插入打印代码</span><br><span class="line"> */</span><br><span class="line">public class IedisTransformer implements ClassFileTransformer &#123;</span><br><span class="line"></span><br><span class="line">private final static String IDEA_LIB=&quot;/Applications/IntelliJ IDEA.app/Contents/lib/*&quot;;</span><br><span class="line">private final static String IDEIS_LIB=&quot;/Users/liaojiacan/Library/Application Support/IntelliJIdea2017.2/Iedis/lib/*&quot;;</span><br><span class="line"></span><br><span class="line">public IedisTransformer() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">ClassPool.getDefault().appendClassPath(IDEA_LIB);</span><br><span class="line">ClassPool.getDefault().appendClassPath(IDEIS_LIB);</span><br><span class="line">&#125; catch (NotFoundException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException &#123;</span><br><span class="line"></span><br><span class="line">if(className.startsWith(&quot;com/seventh7/widget/iedis&quot;))&#123;</span><br><span class="line">try &#123;</span><br><span class="line">CtClass clazz = ClassPool.getDefault().makeClass(new ByteArrayInputStream(classfileBuffer));</span><br><span class="line">CtMethod[] methods = clazz.getDeclaredMethods();</span><br><span class="line">CtClass string = ClassPool.getDefault().getCtClass(String.class.getName());</span><br><span class="line">for(CtMethod method :methods)&#123;</span><br><span class="line"></span><br><span class="line">if(method.getLongName().startsWith(&quot;com.seventh7.widget.iedis.a.p.f&quot;))&#123;</span><br><span class="line">System.out.println(&quot;Inject :: SUCCESS!&quot;);</span><br><span class="line">method.insertBefore(&quot;if(true)&#123;return true;&#125; &quot;);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(method.getReturnType().equals(string))&#123;</span><br><span class="line">String name = method.getLongName();</span><br><span class="line">System.out.println(&quot;transform the iedis method:&quot;+name);</span><br><span class="line">method.insertAfter(&quot;System.out.println(\&quot;--------------------\&quot;);&quot; +</span><br><span class="line">&quot; System.out.println(\&quot;&quot;+name+&quot;\&quot;); &quot; +</span><br><span class="line">&quot; System.out.println(java.util.Arrays.toString($args)); &quot; +</span><br><span class="line">&quot; System.out.println(\&quot;return:\&quot;+$_);&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return clazz.toBytecode();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (NotFoundException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (CannotCompileException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>修改System.out，把所有的print打印到我们指定的文件中 /tmp/system.out</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">public static void premain(String agentOps, Instrumentation inst) &#123;</span><br><span class="line">PrintStream out = null;</span><br><span class="line">try &#123;</span><br><span class="line">out = new PrintStream(&quot;/tmp/system.out&quot;);</span><br><span class="line">&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.setOut(out);</span><br><span class="line">System.setErr(out);</span><br><span class="line"></span><br><span class="line">if (&quot;iedis&quot;.equals(agentOps))&#123;</span><br><span class="line">inst.addTransformer(new IedisTransformer());</span><br><span class="line">&#125;else if(&quot;injectPrint&quot;.equals(agentOps)) &#123;</span><br><span class="line">inst.addTransformer(new InjectPrintTransformer());</span><br><span class="line">&#125;else &#123;</span><br><span class="line">inst.addTransformer(new SimpleTransformer());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(helloWorld());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static String helloWorld()&#123;</span><br><span class="line">return &quot;This is a javaagent!&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>配置idea启动配置，加入我们的javaagent</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#修改idea.vmoptions文件加入下面一行配置</span><br><span class="line">-javaagent:/Users/liaojiacan/Workspace/tools/decomplie/javaagent/javaagent-1.0-SNAPSHOT.jar=iedis</span><br><span class="line">-Xms128m</span><br><span class="line">-Xmx750m</span><br><span class="line">-XX:ReservedCodeCacheSize=240m</span><br><span class="line">-XX:+UseCompressedOops</span><br><span class="line">-Dfile.encoding=UTF-8</span><br><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-XX:SoftRefLRUPolicyMSPerMB=50</span><br><span class="line">-ea</span><br><span class="line">-Dsun.io.useCanonCaches=false</span><br><span class="line">-Djava.net.preferIPv4Stack=true</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:-OmitStackTraceInFastThrow</span><br><span class="line">-Xverify:none</span><br><span class="line"></span><br><span class="line">-XX:ErrorFile=$USER_HOME/java_error_in_idea_%p.log</span><br><span class="line">-XX:HeapDumpPath=$USER_HOME/java_error_in_idea.hprof</span><br><span class="line">-Xbootclasspath/a:../lib/boot.jar</span><br></pre></td></tr></table></figure><p>启动Idea 后我们可以在/tmp/system.out中可以看到这些关键的日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">--------------------</span><br><span class="line">com.seventh7.widget.iedis.L.a(java.lang.String)</span><br><span class="line">return:&#123;&quot;trailing&quot;:true,&quot;daysLeft&quot;:9,&quot;popup&quot;:true,&quot;activated&quot;:false&#125;</span><br><span class="line">--------------------</span><br><span class="line">com.seventh7.widget.iedis.B.a()</span><br><span class="line">return:186b474e0ffffffb70ffffff96680ffffffc0240ffffff89456b0fffffffa320ffffffa70ffffff92</span><br><span class="line">--------------------</span><br><span class="line">com.seventh7.widget.iedis.x.a(byte[])</span><br><span class="line">return:MTg2YjQ3NGUwZmZmZmZmYjcwZmZmZmZmOTY2ODBmZmZmZmZjMDI0MGZmZmZmZjg5NDU2YjBmZmZm</span><br><span class="line">ZmZmYTMyMGZmZmZmZmE3MGZmZmZmZjkyOjI=</span><br><span class="line">--------------------</span><br><span class="line">com.seventh7.widget.iedis.L.a(java.lang.String)</span><br><span class="line">return:&#123;&quot;trailing&quot;:true,&quot;daysLeft&quot;:9,&quot;popup&quot;:true,&quot;activated&quot;:false&#125;</span><br><span class="line">--------------------</span><br><span class="line"></span><br><span class="line">com.seventh7.widget.iedis.L.a(java.lang.String)</span><br><span class="line">[https://www.codesmagic.com/q2?t=MTg2YjQ3NGUwZmZmZmZmYjcwZmZmZmZmOTY2ODBmZmZmZmZjMDI0MGZmZmZmZjg5NDU2YjBmZmZmZmZmYTMyMGZmZmZmZmE3MGZmZmZmZjkyOjI=]</span><br><span class="line">return:&#123;&quot;trailing&quot;:true,&quot;daysLeft&quot;:9,&quot;popup&quot;:true,&quot;activated&quot;:false&#125;</span><br><span class="line">--------------------</span><br><span class="line">com.seventh7.widget.iedis.a.p.b(int,int)</span><br><span class="line">[-13938, -6118]</span><br><span class="line">return:trailing</span><br><span class="line">--------------------</span><br><span class="line">com.seventh7.widget.iedis.a.p.b(int,int)</span><br><span class="line">[-13937, -25088]</span><br><span class="line">return:daysLeft</span><br><span class="line">--------------------</span><br><span class="line">com.seventh7.widget.iedis.a.p.b(int,int)</span><br><span class="line">[-13939, 7216]</span><br><span class="line">return:popup</span><br></pre></td></tr></table></figure><p>从上面的日志可以看出一些关键点：</p><ul><li><p><a href="https://www.codesmagic.com/q2?t=" target="_blank" rel="noopener">https://www.codesmagic.com/q2?t=</a> 是注册的服务器</p></li><li><p>com.seventh7.widget.iedis.a.o 这个类是很关键的类</p></li><li><p>认证服务器返回的认证结果为<br>{“trailing”:true,“daysLeft”:9,“popup”:true,“activated”:false}</p></li></ul><blockquote><p>查看反编译的代码，可以看出这个类是一个抽象类，他的唯一子类是com.seventh7.widget.iedis.a.p，根据外面获取到的运行日志，大概可以推断出 f这个方法是认证的方法。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">package com.seventh7.widget.iedis.a;</span><br><span class="line"></span><br><span class="line">import com.seventh7.widget.iedis.b.d.a;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import com.seventh7.widget.iedis.L;</span><br><span class="line"></span><br><span class="line">class p extends o</span><br><span class="line">&#123;</span><br><span class="line">    private static final String[] kb;</span><br><span class="line">    private static final String[] lb;</span><br><span class="line">    </span><br><span class="line">    //基本上可以推断出 这个就是认证的方法，最直接的方法就是直接return true</span><br><span class="line">    @Override</span><br><span class="line">    protected boolean f() throws IOException &#123;</span><br><span class="line">        //this.d() 是调用https://www.codesmagic.com/q2去注册的</span><br><span class="line">        //Map的返回值&#123;&quot;trailing&quot;:true,&quot;daysLeft&quot;:9,&quot;popup&quot;:true,&quot;activated&quot;:false&#125;</span><br><span class="line">        final Map d = this.d();</span><br><span class="line">        //trailing</span><br><span class="line">        final boolean booleanValue = L.a(d, b(-13938, -6118));</span><br><span class="line">        //this.d()执行后的异常信息。</span><br><span class="line">        final a[] b = av.b();</span><br><span class="line">        //daysLeft</span><br><span class="line">        final int b2 = L.b(d, b(-13937, -25088));</span><br><span class="line">        //popup</span><br><span class="line">        final boolean booleanValue2 = L.a(d, b(-13939, 7216));</span><br><span class="line">        boolean booleanValue3 = false;</span><br><span class="line">        Label_0104: &#123;</span><br><span class="line">            Label_0074: &#123;</span><br><span class="line">                boolean b3;</span><br><span class="line">                try &#123;</span><br><span class="line">                    b3 = (booleanValue3 = booleanValue);</span><br><span class="line">                    if (b != null) &#123;</span><br><span class="line">                        break Label_0104;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (b3) &#123;</span><br><span class="line">                        break Label_0074;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break Label_0074;</span><br><span class="line">                &#125;</span><br><span class="line">                catch (IOException ex) &#123;</span><br><span class="line">                    throw b(ex);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (b3) &#123;</span><br><span class="line">                        this.a(b2, booleanValue2);</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                catch (IOException ex2) &#123;</span><br><span class="line">                    throw b(ex2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //actived</span><br><span class="line">            booleanValue3 = L.a(d, b(-13940, 8507));</span><br><span class="line">        &#125;</span><br><span class="line">        final boolean b4 = booleanValue3;</span><br><span class="line">        </span><br><span class="line">        //如果已经过了试用，就检测激活</span><br><span class="line">        Label_0122: &#123;</span><br><span class="line">            boolean b5;</span><br><span class="line">            try &#123;</span><br><span class="line">                final boolean b6;</span><br><span class="line">                b5 = (b6 = b4);</span><br><span class="line">                // b = av.b()</span><br><span class="line">                if (b != null) &#123;</span><br><span class="line">                    return b6;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!b5) &#123;</span><br><span class="line">                    break Label_0122;</span><br><span class="line">                &#125;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            catch (IOException ex3) &#123;</span><br><span class="line">                throw b(ex3);</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (!b5) &#123;</span><br><span class="line">                    this.c();</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            catch (IOException ex4) &#123;</span><br><span class="line">                throw b(ex4);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private static IOException b(final IOException ex) &#123;</span><br><span class="line">        return ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的分享结果可以看出，有两种破解思路</p><ul><li><p>方法一 修改 com.seventh7.widget.iedis.a.p.f 永远return true</p></li><li><p>方法二 搭建一个认证服务器，本地替换host，认证服务器返回的结果为</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;trailing&quot;: false, &quot;popup&quot;: true, &quot;activated&quot;: true, &quot;daysLeft&quot;: 0 &#125;</span><br></pre></td></tr></table></figure><p>方法一的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class IedisCracker &#123;</span><br><span class="line"></span><br><span class="line">private final static String IDEA_LIB=&quot;/Applications/IntelliJ IDEA.app/Contents/lib/*&quot;;</span><br><span class="line">private final static String IDEIS_LIB=&quot;/Users/liaojiacan/Library/Application Support/IntelliJIdea2017.2/Iedis/lib/*&quot;;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">ClassPool.getDefault().appendClassPath(IDEA_LIB);</span><br><span class="line">ClassPool.getDefault().appendClassPath(IDEIS_LIB);</span><br><span class="line"></span><br><span class="line">CtClass clazz = ClassPool.getDefault().getCtClass(&quot;com.seventh7.widget.iedis.a.p&quot;);</span><br><span class="line"></span><br><span class="line">CtMethod[] mds = clazz.getDeclaredMethods();</span><br><span class="line">for(CtMethod method : mds)&#123;</span><br><span class="line">if(method.getLongName().startsWith(&quot;com.seventh7.widget.iedis.a.p.f&quot;))&#123;</span><br><span class="line">System.out.println(&quot;Inject :: SUCCESS!&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">method.insertBefore(&quot;if(true)&#123;return true;&#125; &quot;);</span><br><span class="line">&#125; catch (CannotCompileException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">clazz.writeFile(&quot;/tmp/p.class&quot;);</span><br><span class="line"></span><br><span class="line">&#125; catch (NotFoundException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (CannotCompileException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Iedis是IDEA上的一个收费redis插件，java编写的，既然是java写的，收费这些自然是很容易绕过的。由于Java太容易被反编译，作者还是做了些代码混淆和字符串加密。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;利用jd-gui反
      
    
    </summary>
    
      <category term="逆向" scheme="http://liaojiacan.me/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="java逆向" scheme="http://liaojiacan.me/tags/java%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>proto变量类型与java类型对照表</title>
    <link href="http://liaojiacan.me/2017/10/11/proto%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%B8%8Ejava%E7%B1%BB%E5%9E%8B%E5%AF%B9%E7%85%A7%E8%A1%A8/"/>
    <id>http://liaojiacan.me/2017/10/11/proto变量类型与java类型对照表/</id>
    <published>2017-10-11T02:53:00.000Z</published>
    <updated>2019-05-22T05:43:18.860Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>proto type</th><th>java type</th></tr></thead><tbody><tr><td>double</td><td>double</td></tr><tr><td>float</td><td>float</td></tr><tr><td>int32</td><td>int</td></tr><tr><td>int64</td><td>long</td></tr><tr><td>uint32</td><td>int</td></tr><tr><td>uint64</td><td>long</td></tr><tr><td>sint32</td><td>int</td></tr><tr><td>sint64</td><td>long</td></tr><tr><td>fixed32</td><td>int</td></tr><tr><td>fixed64</td><td>long</td></tr><tr><td>sfixed32</td><td>int</td></tr><tr><td>sfixed32</td><td>long</td></tr><tr><td>bool</td><td>boolean</td></tr><tr><td>string</td><td>string</td></tr><tr><td>bytes</td><td>ByteString</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;proto type&lt;/th&gt;
&lt;th&gt;java type&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;float
      
    
    </summary>
    
    
      <category term="rpc" scheme="http://liaojiacan.me/tags/rpc/"/>
    
      <category term="Protobuf" scheme="http://liaojiacan.me/tags/Protobuf/"/>
    
  </entry>
  
  <entry>
    <title>proto文件</title>
    <link href="http://liaojiacan.me/2017/10/10/proto%E6%96%87%E4%BB%B6/"/>
    <id>http://liaojiacan.me/2017/10/10/proto文件/</id>
    <published>2017-10-10T11:52:00.000Z</published>
    <updated>2019-05-22T05:43:18.860Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>proto文件是Proto buffers的描述文件</p></blockquote><ul><li>syntax 指定pd编译器的版本，可以设置proto2或者proto3</li><li>message 类似java中的class关键字，在PB这里叫消息体</li><li>service 服务声明</li><li>修饰符<ul><li>required 非空，必须存在</li><li>optional 可选</li><li>repeated 可重复出现，类似集合的概念吧</li></ul></li><li>更多介绍参考官方文档，<a href="https://developers.google.com/protocol-buffers/docs/proto3#simple" target="_blank" rel="noopener">Protocal Buffers</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">service SearchService&#123;</span><br><span class="line">    rpc search(SearchRequest) returns (SearchResponse) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message SearchRequest &#123;</span><br><span class="line">  required string query = 1;</span><br><span class="line">  optional int32 page_number = 2;</span><br><span class="line">  optional int32 result_per_page = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message SearchResponse &#123;</span><br><span class="line">  string result = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;proto文件是Proto buffers的描述文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;syntax 指定pd编译器的版本，可以设置proto2或者proto3&lt;/li&gt;
&lt;li&gt;message 类似java中的class关键字
      
    
    </summary>
    
    
      <category term="rpc" scheme="http://liaojiacan.me/tags/rpc/"/>
    
      <category term="Protobuf" scheme="http://liaojiacan.me/tags/Protobuf/"/>
    
  </entry>
  
  <entry>
    <title>javaagent 的使用</title>
    <link href="http://liaojiacan.me/2017/10/10/javaagent-%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://liaojiacan.me/2017/10/10/javaagent-的使用/</id>
    <published>2017-10-10T03:40:00.000Z</published>
    <updated>2019-05-22T05:43:18.859Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>javaagent 是类似一个JVM的插件，利用JVM提供的Instrumentation API实现获取或者修改加载到JVM中的类字节码。</p></blockquote><p>编写一个javagent的jar的方式如下：</p><p>1.实现一个ClassFileTransformer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleTransformer implements ClassFileTransformer &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException &#123;</span><br><span class="line">System.out.println(className);</span><br><span class="line">System.out.println(protectionDomain.toString());</span><br><span class="line">return new byte[0];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.实现一个Premain-Class</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">public static void premain(String agentOps, Instrumentation inst) &#123;</span><br><span class="line">inst.addTransformer(new SimpleTransformer());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(&quot;This is a javaagent!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.MANIFEST.MF配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Premain-Class: com.github.liaojiacan.Main</span><br><span class="line">Can-Redefine-Classes: true</span><br><span class="line">Can-Retransform-Classes: true</span><br><span class="line">Can-Set-Native-Method-Prefix: true</span><br></pre></td></tr></table></figure><p>4.运行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:agent.jar -jar app.jar</span><br></pre></td></tr></table></figure><p>代码和assembly的打包配置可以参考，<a href="https://github.com/liaojiacan/code-snippets/tree/master/javaagent" target="_blank" rel="noopener">github</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;javaagent 是类似一个JVM的插件，利用JVM提供的Instrumentation API实现获取或者修改加载到JVM中的类字节码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;编写一个javagent的jar的方式如下：&lt;/p&gt;
&lt;p&gt;1.
      
    
    </summary>
    
      <category term="逆向" scheme="http://liaojiacan.me/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="java逆向" scheme="http://liaojiacan.me/tags/java%E9%80%86%E5%90%91/"/>
    
      <category term="java" scheme="http://liaojiacan.me/tags/java/"/>
    
  </entry>
  
</feed>
